
EnergyAgent-1Ch.elf:     filformat elf32-msp430


Disassemblering af sektion __interrupt_vector_8:

0000ffee <__interrupt_vector_8>:
    ffee:	ea c2       	interrupt service routine at 0xc2ea

Disassemblering af sektion __interrupt_vector_10:

0000fff2 <__interrupt_vector_10>:
    fff2:	4a b4       	interrupt service routine at 0xb44a

Disassemblering af sektion .text:

00008268 <__crt0_start>:
    8268:	31 40 00 0a 	mov	#2560,	r1	;#0x0a00

0000826c <__crt0_init_bss>:
    826c:	3c 40 1a 02 	mov	#538,	r12	;#0x021a
    8270:	0d 43       	clr	r13		;
    8272:	3e 40 f8 02 	mov	#760,	r14	;#0x02f8
    8276:	b0 12 f0 d4 	call	#54512		;#0xd4f0

0000827a <__crt0_movedata>:
    827a:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    827e:	3d 40 40 d5 	mov	#54592,	r13	;#0xd540
    8282:	0d 9c       	cmp	r12,	r13	;
    8284:	04 24       	jz	$+10     	;abs 0x828e
    8286:	3e 40 1a 00 	mov	#26,	r14	;#0x001a
    828a:	b0 12 ac d4 	call	#54444		;#0xd4ac

0000828e <__crt0_call_init_then_main>:
    828e:	b0 12 24 d5 	call	#54564		;#0xd524
    8292:	0c 43       	clr	r12		;
    8294:	b0 12 46 b6 	call	#46662		;#0xb646

00008298 <_msp430_run_init_array>:
    8298:	34 40 5c 82 	mov	#33372,	r4	;#0x825c
    829c:	35 40 5c 82 	mov	#33372,	r5	;#0x825c
    82a0:	26 43       	mov	#2,	r6	;r3 As==10
    82a2:	30 40 c4 82 	br	#0x82c4		;

000082a6 <_msp430_run_preinit_array>:
    82a6:	34 40 5c 82 	mov	#33372,	r4	;#0x825c
    82aa:	35 40 5c 82 	mov	#33372,	r5	;#0x825c
    82ae:	26 43       	mov	#2,	r6	;r3 As==10
    82b0:	30 40 c4 82 	br	#0x82c4		;

000082b4 <_msp430_run_fini_array>:
    82b4:	34 40 5c 82 	mov	#33372,	r4	;#0x825c
    82b8:	35 40 5c 82 	mov	#33372,	r5	;#0x825c
    82bc:	36 40 fe ff 	mov	#65534,	r6	;#0xfffe
    82c0:	30 40 c4 82 	br	#0x82c4		;

000082c4 <_msp430_run_array>:
    82c4:	05 94       	cmp	r4,	r5	;
    82c6:	05 24       	jz	$+12     	;abs 0x82d2
    82c8:	27 44       	mov	@r4,	r7	;
    82ca:	04 56       	add	r6,	r4	;
    82cc:	a7 12       	call	@r7		;
    82ce:	10 40 f4 ff 	br	0xfff4		;PC rel. 0x82c4

000082d2 <_msp430_run_done>:
    82d2:	30 41       	ret			

000082d4 <deregister_tm_clones>:
    82d4:	3c 40 40 d5 	mov	#54592,	r12	;#0xd540
    82d8:	3c 80 3f d5 	sub	#54591,	r12	;#0xd53f
    82dc:	2d 43       	mov	#2,	r13	;r3 As==10
    82de:	0d 9c       	cmp	r12,	r13	;
    82e0:	07 2c       	jc	$+16     	;abs 0x82f0
    82e2:	3d 40 00 00 	mov	#0,	r13	;
    82e6:	0d 93       	cmp	#0,	r13	;r3 As==00
    82e8:	03 24       	jz	$+8      	;abs 0x82f0
    82ea:	3c 40 40 d5 	mov	#54592,	r12	;#0xd540
    82ee:	8d 12       	call	r13		;
    82f0:	30 41       	ret			

000082f2 <register_tm_clones>:
    82f2:	0a 12       	push	r10		;
    82f4:	3a 40 40 d5 	mov	#54592,	r10	;#0xd540
    82f8:	3a 80 40 d5 	sub	#54592,	r10	;#0xd540
    82fc:	0a 11       	rra	r10		;
    82fe:	0c 4a       	mov	r10,	r12	;
    8300:	b0 12 60 d2 	call	#53856		;#0xd260
    8304:	0c 5a       	add	r10,	r12	;
    8306:	0d 4c       	mov	r12,	r13	;
    8308:	0d 11       	rra	r13		;
    830a:	0d 93       	cmp	#0,	r13	;r3 As==00
    830c:	07 24       	jz	$+16     	;abs 0x831c
    830e:	3e 40 00 00 	mov	#0,	r14	;
    8312:	0e 93       	cmp	#0,	r14	;r3 As==00
    8314:	03 24       	jz	$+8      	;abs 0x831c
    8316:	3c 40 40 d5 	mov	#54592,	r12	;#0xd540
    831a:	8e 12       	call	r14		;
    831c:	3a 41       	pop	r10		;
    831e:	30 41       	ret			

00008320 <__do_global_dtors_aux>:
    8320:	0a 12       	push	r10		;
    8322:	c2 93 1a 02 	cmp.b	#0,	&0x021a	;r3 As==00
    8326:	20 20       	jnz	$+66     	;abs 0x8368
    8328:	1c 42 1c 02 	mov	&0x021c,r12	;0x021c
    832c:	3a 40 66 82 	mov	#33382,	r10	;#0x8266
    8330:	3a 80 64 82 	sub	#33380,	r10	;#0x8264
    8334:	0a 11       	rra	r10		;
    8336:	3a 53       	add	#-1,	r10	;r3 As==11
    8338:	0c 9a       	cmp	r10,	r12	;
    833a:	0b 2c       	jc	$+24     	;abs 0x8352
    833c:	1c 53       	inc	r12		;
    833e:	82 4c 1c 02 	mov	r12,	&0x021c	;
    8342:	0c 5c       	rla	r12		;
    8344:	1c 4c 64 82 	mov	-32156(r12),r12	;0xffff8264
    8348:	8c 12       	call	r12		;
    834a:	1c 42 1c 02 	mov	&0x021c,r12	;0x021c
    834e:	0c 9a       	cmp	r10,	r12	;
    8350:	f5 2b       	jnc	$-20     	;abs 0x833c
    8352:	b0 12 d4 82 	call	#33492		;#0x82d4
    8356:	3d 40 00 00 	mov	#0,	r13	;
    835a:	0d 93       	cmp	#0,	r13	;r3 As==00
    835c:	03 24       	jz	$+8      	;abs 0x8364
    835e:	3c 40 58 82 	mov	#33368,	r12	;#0x8258
    8362:	8d 12       	call	r13		;
    8364:	d2 43 1a 02 	mov.b	#1,	&0x021a	;r3 As==01
    8368:	3a 41       	pop	r10		;
    836a:	30 41       	ret			

0000836c <call___do_global_dtors_aux>:
    836c:	30 41       	ret			

0000836e <frame_dummy>:
    836e:	3e 40 00 00 	mov	#0,	r14	;
    8372:	0e 93       	cmp	#0,	r14	;r3 As==00
    8374:	05 24       	jz	$+12     	;abs 0x8380
    8376:	3c 40 58 82 	mov	#33368,	r12	;#0x8258
    837a:	3d 40 1e 02 	mov	#542,	r13	;#0x021e
    837e:	8e 12       	call	r14		;
    8380:	3c 40 00 02 	mov	#512,	r12	;#0x0200
    8384:	8c 93 00 00 	cmp	#0,	0(r12)	;r3 As==00
    8388:	03 20       	jnz	$+8      	;abs 0x8390
    838a:	b0 12 f2 82 	call	#33522		;#0x82f2
    838e:	30 41       	ret			
    8390:	3d 40 00 00 	mov	#0,	r13	;
    8394:	0d 93       	cmp	#0,	r13	;r3 As==00
    8396:	f9 27       	jz	$-12     	;abs 0x838a
    8398:	8d 12       	call	r13		;
    839a:	30 40 8a 83 	br	#0x838a		;

0000839e <call_frame_dummy>:
    839e:	30 41       	ret			

000083a0 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    83a0:	0a 12       	push	r10		;
    83a2:	09 12       	push	r9		;
    83a4:	08 12       	push	r8		;
    83a6:	21 83       	decd	r1		;
    83a8:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    83aa:	18 4c 04 00 	mov	4(r12),	r8	;
    83ae:	0c 48       	mov	r8,	r12	;
    83b0:	b0 12 ec d1 	call	#53740		;#0xd1ec
    83b4:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    83b6:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    83ba:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    83be:	00 00 
    83c0:	0c 48       	mov	r8,	r12	;
    83c2:	0d 4f       	mov	r15,	r13	;
    83c4:	0e 4f       	mov	r15,	r14	;
    83c6:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    83c8:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    83cc:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    83ce:	2c da       	bis	@r10,	r12	;
    83d0:	21 53       	incd	r1		;
    83d2:	30 40 70 d1 	br	#0xd170		;

000083d6 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    83d6:	0a 12       	push	r10		;
    83d8:	09 12       	push	r9		;
    83da:	08 12       	push	r8		;
    83dc:	07 12       	push	r7		;
    83de:	06 12       	push	r6		;
    83e0:	05 12       	push	r5		;
    83e2:	21 83       	decd	r1		;
    83e4:	0a 4c       	mov	r12,	r10	;
    83e6:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    83ea:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    83ee:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    83f2:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    83f6:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    83fa:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    83fe:	00 00 
    8400:	0c 49       	mov	r9,	r12	;
    8402:	0d 45       	mov	r5,	r13	;
    8404:	0e 46       	mov	r6,	r14	;
    8406:	0f 47       	mov	r7,	r15	;
    8408:	88 12       	call	r8		;
    840a:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    840e:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8412:	00 00 
    8414:	0c 49       	mov	r9,	r12	;
    8416:	0d 45       	mov	r5,	r13	;
    8418:	0e 46       	mov	r6,	r14	;
    841a:	0f 47       	mov	r7,	r15	;
    841c:	88 12       	call	r8		;
    841e:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    8422:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8426:	21 53       	incd	r1		;
    8428:	30 40 6a d1 	br	#0xd16a		;

0000842c <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    842c:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8430:	04 00 
    y[1] = x[1];
    8432:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8436:	02 00 
    y[0] = x[0];
    8438:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    843c:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    8440:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    8444:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    8448:	30 41       	ret			

0000844a <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    844a:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    844e:	04 00 
    y[1] = x[1];
    8450:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8454:	02 00 
    y[0] = x[0];
    8456:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    845a:	30 41       	ret			

0000845c <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    845c:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    8460:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    8464:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    8468:	30 41       	ret			

0000846a <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    846a:	0f 43       	clr	r15		;
    846c:	0f 4e       	mov	r14,	r15	;
    846e:	0f 5f       	rla	r15		;
    8470:	0f 7f       	subc	r15,	r15	;
    8472:	3f e3       	inv	r15		;
    8474:	8c 5d 00 00 	add	r13,	0(r12)	;
    8478:	8c 6e 02 00 	addc	r14,	2(r12)	;
    847c:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    8480:	30 41       	ret			

00008482 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8482:	0c 93       	cmp	#0,	r12	;r3 As==00
    8484:	04 24       	jz	$+10     	;abs 0x848e
    {
        n--;
    8486:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8488:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    848a:	0c 93       	cmp	#0,	r12	;r3 As==00
    848c:	fc 23       	jnz	$-6      	;abs 0x8486
    {
        n--;
        __no_operation();
    }
}
    848e:	30 41       	ret			

00008490 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    8490:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8494:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8498:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    849c:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    84a0:	30 41       	ret			

000084a2 <dc_filter>:
{
#if defined(__GNUC__)  &&  defined(__MSP430__)
    int32_t z;

    z = 0x12345678;
    __asm__ (
    84a2:	3e 40 78 56 	mov	#22136,	r14	;#0x5678
    84a6:	3f 40 34 12 	mov	#4660,	r15	;#0x1234
    84aa:	0f 4d       	mov	r13,	r15	;
    84ac:	0e 43       	clr	r14		;
    84ae:	2e 8c       	sub	@r12,	r14	;
    84b0:	1f 7c 02 00 	subc	2(r12),	r15	;
    84b4:	0e 5e       	rla	r14		;
    84b6:	0f 6f       	rlc	r15		;
    84b8:	06 2c       	jc	$+14     	;abs 0x84c6
    84ba:	0e 6e       	rlc	r14		;
    84bc:	0f 6f       	rlc	r15		;
    84be:	0e 6e       	rlc	r14		;
    84c0:	3e f0 03 00 	and	#3,	r14	;
    84c4:	05 3c       	jmp	$+12     	;abs 0x84d0
    84c6:	0e 6e       	rlc	r14		;
    84c8:	0f 6f       	rlc	r15		;
    84ca:	0e 6e       	rlc	r14		;
    84cc:	3e d0 fc ff 	bis	#65532,	r14	;#0xfffc
    84d0:	2f 5c       	add	@r12,	r15	;
    84d2:	1e 6c 02 00 	addc	2(r12),	r14	;
    84d6:	8c 4f 00 00 	mov	r15,	0(r12)	;
    84da:	8c 4e 02 00 	mov	r14,	2(r12)	;
    84de:	0d 8e       	sub	r14,	r13	;
#else
    *p += ((((int32_t) x << 16) - *p) >> 14);
    x -= (*p >> 16);
    return x;
#endif
}
    84e0:	0c 4d       	mov	r13,	r12	;
    84e2:	30 41       	ret			

000084e4 <dc_filter_no_update>:

int16_t dc_filter_no_update(const int32_t *p, int16_t x)
{
    84e4:	0a 12       	push	r10		;
    84e6:	0a 4d       	mov	r13,	r10	;
    return x - (*p >> 16);
    84e8:	1d 4c 02 00 	mov	2(r12),	r13	;
    84ec:	2c 4c       	mov	@r12,	r12	;
    84ee:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    84f2:	b0 12 5a d2 	call	#53850		;#0xd25a
}
    84f6:	0a 8c       	sub	r12,	r10	;
    84f8:	0c 4a       	mov	r10,	r12	;
    84fa:	3a 41       	pop	r10		;
    84fc:	30 41       	ret			

000084fe <dc_filter_init>:

void dc_filter_init(int32_t *p, int16_t x)
{
    84fe:	0a 12       	push	r10		;
    8500:	0a 4c       	mov	r12,	r10	;
    *p = (int32_t) x << 16;
    8502:	0c 4d       	mov	r13,	r12	;
    8504:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    8508:	0d 7d       	subc	r13,	r13	;
    850a:	3d e3       	inv	r13		;
    850c:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8510:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    8514:	8a 4c 00 00 	mov	r12,	0(r10)	;
    8518:	8a 4d 02 00 	mov	r13,	2(r10)	;
}
    851c:	3a 41       	pop	r10		;
    851e:	30 41       	ret			

00008520 <dc_filter16_estimate>:

int32_t dc_filter16_estimate(const int32_t *p)
{
    return *p >> 8;
    8520:	1d 4c 02 00 	mov	2(r12),	r13	;
    8524:	2c 4c       	mov	@r12,	r12	;
    8526:	b0 12 32 d2 	call	#53810		;#0xd232
}
    852a:	30 41       	ret			

0000852c <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    852c:	0a 12       	push	r10		;
    852e:	09 12       	push	r9		;
    8530:	08 12       	push	r8		;
    8532:	21 83       	decd	r1		;
    8534:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8536:	18 4c 04 00 	mov	4(r12),	r8	;
    853a:	0c 48       	mov	r8,	r12	;
    853c:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8540:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8542:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8546:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    854a:	00 00 
    854c:	0c 48       	mov	r8,	r12	;
    854e:	0d 4f       	mov	r15,	r13	;
    8550:	0e 4f       	mov	r15,	r14	;
    8552:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8554:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8558:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    855a:	2c da       	bis	@r10,	r12	;
    855c:	21 53       	incd	r1		;
    855e:	30 40 70 d1 	br	#0xd170		;

00008562 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8562:	0a 12       	push	r10		;
    8564:	09 12       	push	r9		;
    8566:	08 12       	push	r8		;
    8568:	07 12       	push	r7		;
    856a:	06 12       	push	r6		;
    856c:	05 12       	push	r5		;
    856e:	21 83       	decd	r1		;
    8570:	0a 4c       	mov	r12,	r10	;
    8572:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8576:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    857a:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    857e:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8582:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8586:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    858a:	00 00 
    858c:	0c 49       	mov	r9,	r12	;
    858e:	0d 45       	mov	r5,	r13	;
    8590:	0e 46       	mov	r6,	r14	;
    8592:	0f 47       	mov	r7,	r15	;
    8594:	88 12       	call	r8		;
    8596:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    859a:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    859e:	00 00 
    85a0:	0c 49       	mov	r9,	r12	;
    85a2:	0d 45       	mov	r5,	r13	;
    85a4:	0e 46       	mov	r6,	r14	;
    85a6:	0f 47       	mov	r7,	r15	;
    85a8:	88 12       	call	r8		;
    85aa:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    85ae:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    85b2:	21 53       	incd	r1		;
    85b4:	30 40 6a d1 	br	#0xd16a		;

000085b8 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    85b8:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    85bc:	04 00 
    y[1] = x[1];
    85be:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    85c2:	02 00 
    y[0] = x[0];
    85c4:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    85c8:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    85cc:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    85d0:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    85d4:	30 41       	ret			

000085d6 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    85d6:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    85da:	04 00 
    y[1] = x[1];
    85dc:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    85e0:	02 00 
    y[0] = x[0];
    85e2:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    85e6:	30 41       	ret			

000085e8 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    85e8:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    85ec:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    85f0:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    85f4:	30 41       	ret			

000085f6 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    85f6:	0f 43       	clr	r15		;
    85f8:	0f 4e       	mov	r14,	r15	;
    85fa:	0f 5f       	rla	r15		;
    85fc:	0f 7f       	subc	r15,	r15	;
    85fe:	3f e3       	inv	r15		;
    8600:	8c 5d 00 00 	add	r13,	0(r12)	;
    8604:	8c 6e 02 00 	addc	r14,	2(r12)	;
    8608:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    860c:	30 41       	ret			

0000860e <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    860e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8610:	04 24       	jz	$+10     	;abs 0x861a
    {
        n--;
    8612:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8614:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8616:	0c 93       	cmp	#0,	r12	;r3 As==00
    8618:	fc 23       	jnz	$-6      	;abs 0x8612
    {
        n--;
        __no_operation();
    }
}
    861a:	30 41       	ret			

0000861c <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    861c:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8620:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8624:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    8628:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    862c:	30 41       	ret			

0000862e <dc_filter24>:
#include <msp430.h>
#endif
#include "emeter-toolkit.h"

int32_t dc_filter24(int16_t p[3], int32_t x)
{
    862e:	0a 12       	push	r10		;
    8630:	09 12       	push	r9		;
    8632:	08 12       	push	r8		;
    8634:	07 12       	push	r7		;
    8636:	06 12       	push	r6		;
    8638:	05 12       	push	r5		;
    863a:	04 12       	push	r4		;
    863c:	31 80 0e 00 	sub	#14,	r1	;#0x000e
    8640:	07 4c       	mov	r12,	r7	;
    8642:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    8646:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c
    int64_t tmp;

    tmp = p[2];
    864a:	19 4c 04 00 	mov	4(r12),	r9	;
    864e:	0c 49       	mov	r9,	r12	;
    8650:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8654:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    8656:	3a 40 14 cd 	mov	#52500,	r10	;#0xcd14
    865a:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    865e:	00 00 
    8660:	0c 49       	mov	r9,	r12	;
    8662:	0d 4f       	mov	r15,	r13	;
    8664:	0e 4f       	mov	r15,	r14	;
    8666:	8a 12       	call	r10		;
    8668:	04 4c       	mov	r12,	r4	;
    866a:	05 4d       	mov	r13,	r5	;
    866c:	06 4e       	mov	r14,	r6	;
    866e:	08 4f       	mov	r15,	r8	;
    tmp |= p[1];
    8670:	19 47 02 00 	mov	2(r7),	r9	;
    8674:	0c 49       	mov	r9,	r12	;
    8676:	b0 12 ec d1 	call	#53740		;#0xd1ec
    867a:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    867c:	0c 44       	mov	r4,	r12	;
    867e:	0c d9       	bis	r9,	r12	;
    8680:	0d 45       	mov	r5,	r13	;
    8682:	0d df       	bis	r15,	r13	;
    8684:	0e 46       	mov	r6,	r14	;
    8686:	0e df       	bis	r15,	r14	;
    8688:	0f d8       	bis	r8,	r15	;
    868a:	8a 12       	call	r10		;
    868c:	06 4c       	mov	r12,	r6	;
    868e:	04 4d       	mov	r13,	r4	;
    8690:	05 4e       	mov	r14,	r5	;
    8692:	09 4f       	mov	r15,	r9	;
    tmp |= p[0];
    8694:	2a 47       	mov	@r7,	r10	;
    8696:	0c 4a       	mov	r10,	r12	;
    8698:	b0 12 ec d1 	call	#53740		;#0xd1ec
    869c:	0a d6       	bis	r6,	r10	;
    869e:	04 dc       	bis	r12,	r4	;
    86a0:	05 dc       	bis	r12,	r5	;
    86a2:	09 dc       	bis	r12,	r9	;
    86a4:	81 49 02 00 	mov	r9,	2(r1)	;
    tmp += ((((int32_t) x << 16) - tmp) >> 14);
    86a8:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    86ac:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    86b0:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    86b4:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    86b8:	09 4d       	mov	r13,	r9	;
    86ba:	08 4c       	mov	r12,	r8	;
    86bc:	06 4d       	mov	r13,	r6	;
    86be:	0c 4d       	mov	r13,	r12	;
    86c0:	b0 12 ec d1 	call	#53740		;#0xd1ec
    86c4:	0b 4c       	mov	r12,	r11	;
    86c6:	0c 48       	mov	r8,	r12	;
    86c8:	0c 8a       	sub	r10,	r12	;
    86ca:	1e 43       	mov	#1,	r14	;r3 As==01
    86cc:	08 9c       	cmp	r12,	r8	;
    86ce:	01 28       	jnc	$+4      	;abs 0x86d2
    86d0:	0e 43       	clr	r14		;
    86d2:	09 84       	sub	r4,	r9	;
    86d4:	18 43       	mov	#1,	r8	;r3 As==01
    86d6:	06 99       	cmp	r9,	r6	;
    86d8:	01 28       	jnc	$+4      	;abs 0x86dc
    86da:	08 43       	clr	r8		;
    86dc:	0d 49       	mov	r9,	r13	;
    86de:	0d 8e       	sub	r14,	r13	;
    86e0:	1e 43       	mov	#1,	r14	;r3 As==01
    86e2:	09 9d       	cmp	r13,	r9	;
    86e4:	01 28       	jnc	$+4      	;abs 0x86e8
    86e6:	0e 43       	clr	r14		;
    86e8:	08 de       	bis	r14,	r8	;
    86ea:	09 4b       	mov	r11,	r9	;
    86ec:	09 85       	sub	r5,	r9	;
    86ee:	1f 43       	mov	#1,	r15	;r3 As==01
    86f0:	0b 99       	cmp	r9,	r11	;
    86f2:	01 28       	jnc	$+4      	;abs 0x86f6
    86f4:	0f 43       	clr	r15		;
    86f6:	0e 49       	mov	r9,	r14	;
    86f8:	0e 88       	sub	r8,	r14	;
    86fa:	18 43       	mov	#1,	r8	;r3 As==01
    86fc:	09 9e       	cmp	r14,	r9	;
    86fe:	01 28       	jnc	$+4      	;abs 0x8702
    8700:	08 43       	clr	r8		;
    8702:	0f d8       	bis	r8,	r15	;
    8704:	1b 81 02 00 	sub	2(r1),	r11	;
    8708:	b1 40 0e 00 	mov	#14,	0(r1)	;#0x000e
    870c:	00 00 
    870e:	0b 8f       	sub	r15,	r11	;
    8710:	0f 4b       	mov	r11,	r15	;
    8712:	b0 12 90 cd 	call	#52624		;#0xcd90
    8716:	08 4d       	mov	r13,	r8	;
    8718:	0b 4e       	mov	r14,	r11	;
    871a:	0a 5c       	add	r12,	r10	;
    871c:	16 43       	mov	#1,	r6	;r3 As==01
    871e:	0a 9c       	cmp	r12,	r10	;
    8720:	01 28       	jnc	$+4      	;abs 0x8724
    8722:	06 43       	clr	r6		;
    8724:	0d 54       	add	r4,	r13	;
    8726:	19 43       	mov	#1,	r9	;r3 As==01
    8728:	0d 98       	cmp	r8,	r13	;
    872a:	01 28       	jnc	$+4      	;abs 0x872e
    872c:	09 43       	clr	r9		;
    872e:	06 5d       	add	r13,	r6	;
    8730:	1c 43       	mov	#1,	r12	;r3 As==01
    8732:	06 9d       	cmp	r13,	r6	;
    8734:	01 28       	jnc	$+4      	;abs 0x8738
    8736:	0c 43       	clr	r12		;
    8738:	09 dc       	bis	r12,	r9	;
    873a:	0e 55       	add	r5,	r14	;
    873c:	18 43       	mov	#1,	r8	;r3 As==01
    873e:	0e 9b       	cmp	r11,	r14	;
    8740:	01 28       	jnc	$+4      	;abs 0x8744
    8742:	08 43       	clr	r8		;
    8744:	09 5e       	add	r14,	r9	;
    8746:	1c 43       	mov	#1,	r12	;r3 As==01
    8748:	09 9e       	cmp	r14,	r9	;
    874a:	01 28       	jnc	$+4      	;abs 0x874e
    874c:	0c 43       	clr	r12		;
    874e:	08 dc       	bis	r12,	r8	;
    8750:	1f 51 02 00 	add	2(r1),	r15	;
    8754:	08 5f       	add	r15,	r8	;
    x -= (tmp >> 16);
    8756:	35 40 90 cd 	mov	#52624,	r5	;#0xcd90
    875a:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    875e:	00 00 
    8760:	0c 4a       	mov	r10,	r12	;
    8762:	0d 46       	mov	r6,	r13	;
    8764:	0e 49       	mov	r9,	r14	;
    8766:	0f 48       	mov	r8,	r15	;
    8768:	85 12       	call	r5		;
    876a:	81 4c 02 00 	mov	r12,	2(r1)	;
    876e:	81 4d 04 00 	mov	r13,	4(r1)	;
    8772:	81 4e 06 00 	mov	r14,	6(r1)	;
    8776:	81 4f 08 00 	mov	r15,	8(r1)	;
    877a:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    877e:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    8782:	1c 81 02 00 	sub	2(r1),	r12	;
    8786:	1d 71 04 00 	subc	4(r1),	r13	;
    878a:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a
    878e:	81 4d 0c 00 	mov	r13,	12(r1)	; 0x000c
    p[2] = (tmp >> 32) & 0xFFFF;
    8792:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8796:	00 00 
    8798:	0c 4a       	mov	r10,	r12	;
    879a:	0d 46       	mov	r6,	r13	;
    879c:	0e 49       	mov	r9,	r14	;
    879e:	0f 48       	mov	r8,	r15	;
    87a0:	85 12       	call	r5		;
    87a2:	87 4c 04 00 	mov	r12,	4(r7)	;
    p[1] = (tmp >> 16) & 0xFFFF;
    87a6:	97 41 02 00 	mov	2(r1),	2(r7)	;
    87aa:	02 00 
    p[0] = tmp & 0xFFFF;
    87ac:	87 4a 00 00 	mov	r10,	0(r7)	;
    return x;
}
    87b0:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    87b4:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    87b8:	31 50 0e 00 	add	#14,	r1	;#0x000e
    87bc:	30 40 68 d1 	br	#0xd168		;

000087c0 <dc_filter24_no_update>:

int32_t dc_filter24_no_update(const int16_t p[3], int32_t x)
{
    87c0:	0a 12       	push	r10		;
    87c2:	09 12       	push	r9		;
    87c4:	08 12       	push	r8		;
    87c6:	07 12       	push	r7		;
    87c8:	06 12       	push	r6		;
    87ca:	05 12       	push	r5		;
    87cc:	04 12       	push	r4		;
    87ce:	21 83       	decd	r1		;
    87d0:	0a 4c       	mov	r12,	r10	;
    87d2:	08 4d       	mov	r13,	r8	;
    87d4:	09 4e       	mov	r14,	r9	;
    int64_t tmp;

    tmp = p[2];
    87d6:	17 4c 04 00 	mov	4(r12),	r7	;
    87da:	0c 47       	mov	r7,	r12	;
    87dc:	b0 12 ec d1 	call	#53740		;#0xd1ec
    87e0:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    87e2:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    87e6:	00 00 
    87e8:	0c 47       	mov	r7,	r12	;
    87ea:	0d 4f       	mov	r15,	r13	;
    87ec:	0e 4f       	mov	r15,	r14	;
    87ee:	b0 12 14 cd 	call	#52500		;#0xcd14
    87f2:	04 4c       	mov	r12,	r4	;
    87f4:	05 4d       	mov	r13,	r5	;
    87f6:	06 4e       	mov	r14,	r6	;
    87f8:	07 4f       	mov	r15,	r7	;
    tmp |= p[1];
    87fa:	1a 4a 02 00 	mov	2(r10),	r10	;
    87fe:	0c 4a       	mov	r10,	r12	;
    8800:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8804:	0f 4c       	mov	r12,	r15	;
    8806:	0b 44       	mov	r4,	r11	;
    8808:	0b da       	bis	r10,	r11	;
    880a:	0c 45       	mov	r5,	r12	;
    880c:	0c df       	bis	r15,	r12	;
    x -= tmp;
    880e:	08 8b       	sub	r11,	r8	;
    8810:	09 7c       	subc	r12,	r9	;
    return x;
}
    8812:	0c 48       	mov	r8,	r12	;
    8814:	0d 49       	mov	r9,	r13	;
    8816:	21 53       	incd	r1		;
    8818:	30 40 68 d1 	br	#0xd168		;

0000881c <dc_filter24_init>:

void dc_filter24_init(int16_t p[3], int32_t x)
{
    881c:	0a 12       	push	r10		;
    881e:	09 12       	push	r9		;
    8820:	08 12       	push	r8		;
    8822:	07 12       	push	r7		;
    8824:	06 12       	push	r6		;
    8826:	21 83       	decd	r1		;
    8828:	09 4c       	mov	r12,	r9	;
#if !defined(__MSP430__)
    int64_t tmp;
#endif
    int64_t tmp;	//omn

    tmp = x << 16;
    882a:	0c 4d       	mov	r13,	r12	;
    882c:	0d 4e       	mov	r14,	r13	;
    882e:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8832:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    8836:	08 4d       	mov	r13,	r8	;
    8838:	07 4c       	mov	r12,	r7	;
    883a:	0c 4d       	mov	r13,	r12	;
    883c:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8840:	0a 4c       	mov	r12,	r10	;
    p[2] = (tmp >> 32) & 0xFFFF;
    8842:	36 40 90 cd 	mov	#52624,	r6	;#0xcd90
    8846:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    884a:	00 00 
    884c:	0c 47       	mov	r7,	r12	;
    884e:	0d 48       	mov	r8,	r13	;
    8850:	0e 4a       	mov	r10,	r14	;
    8852:	0f 4a       	mov	r10,	r15	;
    8854:	86 12       	call	r6		;
    8856:	89 4c 04 00 	mov	r12,	4(r9)	;
    p[1] = (tmp >> 16) & 0xFFFF;
    885a:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    885e:	00 00 
    8860:	0c 47       	mov	r7,	r12	;
    8862:	0d 48       	mov	r8,	r13	;
    8864:	0e 4a       	mov	r10,	r14	;
    8866:	0f 4a       	mov	r10,	r15	;
    8868:	86 12       	call	r6		;
    886a:	89 4c 02 00 	mov	r12,	2(r9)	;
    p[0] = tmp & 0xFFFF;
    886e:	89 43 00 00 	mov	#0,	0(r9)	;r3 As==00
}
    8872:	21 53       	incd	r1		;
    8874:	30 40 6c d1 	br	#0xd16c		;

00008878 <dc_filter24_estimate>:

int32_t dc_filter24_estimate(const int16_t p[3])
{
    8878:	0a 12       	push	r10		;
    887a:	09 12       	push	r9		;
    887c:	08 12       	push	r8		;
    887e:	07 12       	push	r7		;
    8880:	06 12       	push	r6		;
    8882:	05 12       	push	r5		;
    8884:	04 12       	push	r4		;
    8886:	21 83       	decd	r1		;
    8888:	0a 4c       	mov	r12,	r10	;
    int64_t tmp;

    tmp = p[2];
    888a:	18 4c 04 00 	mov	4(r12),	r8	;
    888e:	0c 48       	mov	r8,	r12	;
    8890:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8894:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    8896:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    889a:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    889e:	00 00 
    88a0:	0c 48       	mov	r8,	r12	;
    88a2:	0d 4f       	mov	r15,	r13	;
    88a4:	0e 4f       	mov	r15,	r14	;
    88a6:	89 12       	call	r9		;
    88a8:	04 4c       	mov	r12,	r4	;
    88aa:	05 4d       	mov	r13,	r5	;
    88ac:	06 4e       	mov	r14,	r6	;
    88ae:	07 4f       	mov	r15,	r7	;
    tmp |= p[1];
    88b0:	18 4a 02 00 	mov	2(r10),	r8	;
    88b4:	0c 48       	mov	r8,	r12	;
    88b6:	b0 12 ec d1 	call	#53740		;#0xd1ec
    88ba:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    88bc:	0c 44       	mov	r4,	r12	;
    88be:	0c d8       	bis	r8,	r12	;
    88c0:	0d 45       	mov	r5,	r13	;
    88c2:	0d df       	bis	r15,	r13	;
    88c4:	0e 46       	mov	r6,	r14	;
    88c6:	0e df       	bis	r15,	r14	;
    88c8:	0f d7       	bis	r7,	r15	;
    88ca:	89 12       	call	r9		;
    88cc:	06 4c       	mov	r12,	r6	;
    88ce:	07 4d       	mov	r13,	r7	;
    88d0:	08 4e       	mov	r14,	r8	;
    88d2:	09 4f       	mov	r15,	r9	;
    tmp |= p[0];
    88d4:	2a 4a       	mov	@r10,	r10	;
    88d6:	0c 4a       	mov	r10,	r12	;
    88d8:	b0 12 ec d1 	call	#53740		;#0xd1ec
    88dc:	0f 4c       	mov	r12,	r15	;
    return tmp >> 8;
    88de:	b1 42 00 00 	mov	#8,	0(r1)	;r2 As==11
    88e2:	0c 46       	mov	r6,	r12	;
    88e4:	0c da       	bis	r10,	r12	;
    88e6:	0d 47       	mov	r7,	r13	;
    88e8:	0d df       	bis	r15,	r13	;
    88ea:	0e 48       	mov	r8,	r14	;
    88ec:	0e df       	bis	r15,	r14	;
    88ee:	0f d9       	bis	r9,	r15	;
    88f0:	b0 12 90 cd 	call	#52624		;#0xcd90
}
    88f4:	21 53       	incd	r1		;
    88f6:	30 40 68 d1 	br	#0xd168		;

000088fa <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    88fa:	0a 12       	push	r10		;
    88fc:	09 12       	push	r9		;
    88fe:	08 12       	push	r8		;
    8900:	21 83       	decd	r1		;
    8902:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8904:	18 4c 04 00 	mov	4(r12),	r8	;
    8908:	0c 48       	mov	r8,	r12	;
    890a:	b0 12 ec d1 	call	#53740		;#0xd1ec
    890e:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8910:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8914:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8918:	00 00 
    891a:	0c 48       	mov	r8,	r12	;
    891c:	0d 4f       	mov	r15,	r13	;
    891e:	0e 4f       	mov	r15,	r14	;
    8920:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8922:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8926:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    8928:	2c da       	bis	@r10,	r12	;
    892a:	21 53       	incd	r1		;
    892c:	30 40 70 d1 	br	#0xd170		;

00008930 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8930:	0a 12       	push	r10		;
    8932:	09 12       	push	r9		;
    8934:	08 12       	push	r8		;
    8936:	07 12       	push	r7		;
    8938:	06 12       	push	r6		;
    893a:	05 12       	push	r5		;
    893c:	21 83       	decd	r1		;
    893e:	0a 4c       	mov	r12,	r10	;
    8940:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8944:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    8948:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    894c:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8950:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8954:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8958:	00 00 
    895a:	0c 49       	mov	r9,	r12	;
    895c:	0d 45       	mov	r5,	r13	;
    895e:	0e 46       	mov	r6,	r14	;
    8960:	0f 47       	mov	r7,	r15	;
    8962:	88 12       	call	r8		;
    8964:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    8968:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    896c:	00 00 
    896e:	0c 49       	mov	r9,	r12	;
    8970:	0d 45       	mov	r5,	r13	;
    8972:	0e 46       	mov	r6,	r14	;
    8974:	0f 47       	mov	r7,	r15	;
    8976:	88 12       	call	r8		;
    8978:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    897c:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8980:	21 53       	incd	r1		;
    8982:	30 40 6a d1 	br	#0xd16a		;

00008986 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    8986:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    898a:	04 00 
    y[1] = x[1];
    898c:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8990:	02 00 
    y[0] = x[0];
    8992:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    8996:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    899a:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    899e:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    89a2:	30 41       	ret			

000089a4 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    89a4:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    89a8:	04 00 
    y[1] = x[1];
    89aa:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    89ae:	02 00 
    y[0] = x[0];
    89b0:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    89b4:	30 41       	ret			

000089b6 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    89b6:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    89ba:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    89be:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    89c2:	30 41       	ret			

000089c4 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    89c4:	0f 43       	clr	r15		;
    89c6:	0f 4e       	mov	r14,	r15	;
    89c8:	0f 5f       	rla	r15		;
    89ca:	0f 7f       	subc	r15,	r15	;
    89cc:	3f e3       	inv	r15		;
    89ce:	8c 5d 00 00 	add	r13,	0(r12)	;
    89d2:	8c 6e 02 00 	addc	r14,	2(r12)	;
    89d6:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    89da:	30 41       	ret			

000089dc <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    89dc:	0c 93       	cmp	#0,	r12	;r3 As==00
    89de:	04 24       	jz	$+10     	;abs 0x89e8
    {
        n--;
    89e0:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    89e2:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    89e4:	0c 93       	cmp	#0,	r12	;r3 As==00
    89e6:	fc 23       	jnz	$-6      	;abs 0x89e0
    {
        n--;
        __no_operation();
    }
}
    89e8:	30 41       	ret			

000089ea <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    89ea:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    89ee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    89f2:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    89f6:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    89fa:	30 41       	ret			

000089fc <dds_lookup>:
     32728, 32737, 32745, 32752, 32757, 32761, 32765, 32766,
     32767
};

int16_t dds_lookup(uint32_t phase)
{
    89fc:	0a 12       	push	r10		;
    89fe:	09 12       	push	r9		;
    8a00:	08 12       	push	r8		;
    int16_t amp;
    uint32_t step;

    phase >>= DDS_SHIFT;
    8a02:	3e 40 16 00 	mov	#22,	r14	;#0x0016
    8a06:	b0 12 0e d3 	call	#54030		;#0xd30e
    8a0a:	0d 4c       	mov	r12,	r13	;
    step = phase & (DDS_STEPS - 1);
    8a0c:	0e 4c       	mov	r12,	r14	;
    8a0e:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    8a12:	0f 43       	clr	r15		;
    if ((phase & DDS_STEPS))
    8a14:	3c b0 00 01 	bit	#256,	r12	;#0x0100
    8a18:	08 24       	jz	$+18     	;abs 0x8a2a
        step = DDS_STEPS - step;
    8a1a:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    8a1e:	0b 43       	clr	r11		;
    8a20:	08 4a       	mov	r10,	r8	;
    8a22:	09 4b       	mov	r11,	r9	;
    8a24:	08 8e       	sub	r14,	r8	;
    8a26:	09 7f       	subc	r15,	r9	;
    8a28:	0e 48       	mov	r8,	r14	;
    amp = sine_table[step];
    8a2a:	0e 5e       	rla	r14		;
    8a2c:	1c 4e 00 80 	mov	-32768(r14),r12	;0xffff8000
    if ((phase & (2*DDS_STEPS)))
    8a30:	3d b0 00 02 	bit	#512,	r13	;#0x0200
    8a34:	03 24       	jz	$+8      	;abs 0x8a3c
    	amp = -amp;
    8a36:	09 43       	clr	r9		;
    8a38:	09 8c       	sub	r12,	r9	;
    8a3a:	0c 49       	mov	r9,	r12	;
    return amp;
}
    8a3c:	30 40 70 d1 	br	#0xd170		;

00008a40 <dds_interpolated_lookup>:

int16_t dds_interpolated_lookup(uint32_t phase)
{
    8a40:	0a 12       	push	r10		;
    8a42:	09 12       	push	r9		;
    8a44:	08 12       	push	r8		;
    8a46:	07 12       	push	r7		;
    8a48:	06 12       	push	r6		;
    8a4a:	06 4c       	mov	r12,	r6	;
    8a4c:	07 4d       	mov	r13,	r7	;
    uint16_t step;
    uint16_t stepx;
    uint16_t frac;

    /* An interpolated 4 quadrant lookup of the sine of the 32 bit phase angle supplied */
    frac = (phase >> (DDS_SHIFT - 8)) & 0xFF;
    8a4e:	b0 12 b0 d2 	call	#53936		;#0xd2b0
    8a52:	49 4c       	mov.b	r12,	r9	;
    phase >>= DDS_SHIFT;
    8a54:	0c 46       	mov	r6,	r12	;
    8a56:	0d 47       	mov	r7,	r13	;
    8a58:	3e 40 16 00 	mov	#22,	r14	;#0x0016
    8a5c:	b0 12 0e d3 	call	#54030		;#0xd30e
    8a60:	0a 4c       	mov	r12,	r10	;
    step = phase & (DDS_STEPS - 1);
    8a62:	0e 4c       	mov	r12,	r14	;
    8a64:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    if ((phase & DDS_STEPS))
    8a68:	3c b0 00 01 	bit	#256,	r12	;#0x0100
    8a6c:	09 24       	jz	$+20     	;abs 0x8a80
    {
        step = DDS_STEPS - step;
        stepx = step - 1;
    8a6e:	3f 40 ff 00 	mov	#255,	r15	;#0x00ff
    8a72:	0f 8e       	sub	r14,	r15	;
    frac = (phase >> (DDS_SHIFT - 8)) & 0xFF;
    phase >>= DDS_SHIFT;
    step = phase & (DDS_STEPS - 1);
    if ((phase & DDS_STEPS))
    {
        step = DDS_STEPS - step;
    8a74:	3c 40 00 01 	mov	#256,	r12	;#0x0100
    8a78:	0c 8e       	sub	r14,	r12	;
    8a7a:	0e 4c       	mov	r12,	r14	;
    8a7c:	30 40 84 8a 	br	#0x8a84		;
        stepx = step - 1;
    }
    else
    {
        stepx = step + 1;
    8a80:	0f 4e       	mov	r14,	r15	;
    8a82:	1f 53       	inc	r15		;
    }
    amp = sine_table[step];
    8a84:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    8a88:	0e 5e       	rla	r14		;
    8a8a:	0e 5c       	add	r12,	r14	;
    8a8c:	28 4e       	mov	@r14,	r8	;
    amp += (((sine_table[stepx] - amp)*frac) >> 8);
    8a8e:	0f 5f       	rla	r15		;
    8a90:	0f 5c       	add	r12,	r15	;
    8a92:	2c 4f       	mov	@r15,	r12	;
    8a94:	0c 88       	sub	r8,	r12	;
    8a96:	0d 49       	mov	r9,	r13	;
    8a98:	b0 12 14 d3 	call	#54036		;#0xd314
    8a9c:	b0 12 7c d2 	call	#53884		;#0xd27c
    8aa0:	0c 58       	add	r8,	r12	;
    if ((phase & (2*DDS_STEPS)))
    8aa2:	3a b0 00 02 	bit	#512,	r10	;#0x0200
    8aa6:	03 24       	jz	$+8      	;abs 0x8aae
    	amp = -amp;
    8aa8:	0d 43       	clr	r13		;
    8aaa:	0d 8c       	sub	r12,	r13	;
    8aac:	0c 4d       	mov	r13,	r12	;
    return amp;
}
    8aae:	30 40 6c d1 	br	#0xd16c		;

00008ab2 <dds>:

int16_t dds(uint32_t *phase_acc, int32_t phase_rate)
{
    8ab2:	0a 12       	push	r10		;
    8ab4:	09 12       	push	r9		;
    8ab6:	08 12       	push	r8		;
    8ab8:	07 12       	push	r7		;
    8aba:	06 12       	push	r6		;
    8abc:	0a 4c       	mov	r12,	r10	;
    8abe:	07 4d       	mov	r13,	r7	;
    8ac0:	06 4e       	mov	r14,	r6	;
    int16_t amp;

    amp = dds_lookup(*phase_acc);
    8ac2:	29 4c       	mov	@r12,	r9	;
    8ac4:	18 4c 02 00 	mov	2(r12),	r8	;
    8ac8:	0c 49       	mov	r9,	r12	;
    8aca:	0d 48       	mov	r8,	r13	;
    8acc:	b0 12 fc 89 	call	#35324		;#0x89fc
    *phase_acc += phase_rate;
    8ad0:	09 57       	add	r7,	r9	;
    8ad2:	8a 49 00 00 	mov	r9,	0(r10)	;
    8ad6:	08 66       	addc	r6,	r8	;
    8ad8:	8a 48 02 00 	mov	r8,	2(r10)	;
    return amp;
}
    8adc:	30 40 6c d1 	br	#0xd16c		;

00008ae0 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    8ae0:	0a 12       	push	r10		;
    8ae2:	09 12       	push	r9		;
    8ae4:	08 12       	push	r8		;
    8ae6:	21 83       	decd	r1		;
    8ae8:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8aea:	18 4c 04 00 	mov	4(r12),	r8	;
    8aee:	0c 48       	mov	r8,	r12	;
    8af0:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8af4:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8af6:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8afa:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8afe:	00 00 
    8b00:	0c 48       	mov	r8,	r12	;
    8b02:	0d 4f       	mov	r15,	r13	;
    8b04:	0e 4f       	mov	r15,	r14	;
    8b06:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8b08:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8b0c:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    8b0e:	2c da       	bis	@r10,	r12	;
    8b10:	21 53       	incd	r1		;
    8b12:	30 40 70 d1 	br	#0xd170		;

00008b16 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8b16:	0a 12       	push	r10		;
    8b18:	09 12       	push	r9		;
    8b1a:	08 12       	push	r8		;
    8b1c:	07 12       	push	r7		;
    8b1e:	06 12       	push	r6		;
    8b20:	05 12       	push	r5		;
    8b22:	21 83       	decd	r1		;
    8b24:	0a 4c       	mov	r12,	r10	;
    8b26:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8b2a:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    8b2e:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    8b32:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8b36:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8b3a:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8b3e:	00 00 
    8b40:	0c 49       	mov	r9,	r12	;
    8b42:	0d 45       	mov	r5,	r13	;
    8b44:	0e 46       	mov	r6,	r14	;
    8b46:	0f 47       	mov	r7,	r15	;
    8b48:	88 12       	call	r8		;
    8b4a:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    8b4e:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8b52:	00 00 
    8b54:	0c 49       	mov	r9,	r12	;
    8b56:	0d 45       	mov	r5,	r13	;
    8b58:	0e 46       	mov	r6,	r14	;
    8b5a:	0f 47       	mov	r7,	r15	;
    8b5c:	88 12       	call	r8		;
    8b5e:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    8b62:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8b66:	21 53       	incd	r1		;
    8b68:	30 40 6a d1 	br	#0xd16a		;

00008b6c <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    8b6c:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8b70:	04 00 
    y[1] = x[1];
    8b72:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8b76:	02 00 
    y[0] = x[0];
    8b78:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    8b7c:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    8b80:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    8b84:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    8b88:	30 41       	ret			

00008b8a <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    8b8a:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8b8e:	04 00 
    y[1] = x[1];
    8b90:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8b94:	02 00 
    y[0] = x[0];
    8b96:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    8b9a:	30 41       	ret			

00008b9c <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    8b9c:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    8ba0:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    8ba4:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    8ba8:	30 41       	ret			

00008baa <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    8baa:	0f 43       	clr	r15		;
    8bac:	0f 4e       	mov	r14,	r15	;
    8bae:	0f 5f       	rla	r15		;
    8bb0:	0f 7f       	subc	r15,	r15	;
    8bb2:	3f e3       	inv	r15		;
    8bb4:	8c 5d 00 00 	add	r13,	0(r12)	;
    8bb8:	8c 6e 02 00 	addc	r14,	2(r12)	;
    8bbc:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    8bc0:	30 41       	ret			

00008bc2 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8bc2:	0c 93       	cmp	#0,	r12	;r3 As==00
    8bc4:	04 24       	jz	$+10     	;abs 0x8bce
    {
        n--;
    8bc6:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8bc8:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8bca:	0c 93       	cmp	#0,	r12	;r3 As==00
    8bcc:	fc 23       	jnz	$-6      	;abs 0x8bc6
    {
        n--;
        __no_operation();
    }
}
    8bce:	30 41       	ret			

00008bd0 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    8bd0:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8bd4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8bd8:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    8bdc:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    8be0:	30 41       	ret			

00008be2 <div48>:
#include <msp430.h>
#endif
#include "emeter-toolkit.h"

int32_t div48(int16_t x[3], int16_t y)
{
    8be2:	0a 12       	push	r10		;
    8be4:	09 12       	push	r9		;
    8be6:	08 12       	push	r8		;
    8be8:	07 12       	push	r7		;
    8bea:	06 12       	push	r6		;
    8bec:	05 12       	push	r5		;
    8bee:	04 12       	push	r4		;
    8bf0:	21 83       	decd	r1		;
       handling dot products. */
    int32_t x1;
    int32_t z;

    /* Avoid any divide by zero trouble */
    if (y == 0)
    8bf2:	0d 93       	cmp	#0,	r13	;r3 As==00
    8bf4:	39 24       	jz	$+116    	;abs 0x8c68
    8bf6:	08 4d       	mov	r13,	r8	;
    8bf8:	0a 4c       	mov	r12,	r10	;
        return 0;
    x1 = x[2]%y;
    8bfa:	1c 4c 04 00 	mov	4(r12),	r12	;
    8bfe:	b0 12 d6 ce 	call	#52950		;#0xced6
    x1 <<= 16;
    8c02:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    8c06:	0d 7d       	subc	r13,	r13	;
    8c08:	3d e3       	inv	r13		;
    8c0a:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8c0e:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    8c12:	04 4d       	mov	r13,	r4	;
    x1 |= (uint16_t) x[1];
    8c14:	07 4c       	mov	r12,	r7	;
    8c16:	17 da 02 00 	bis	2(r10),	r7	;
    z = x1/y;
    8c1a:	38 b0 00 80 	bit	#32768,	r8	;#0x8000
    8c1e:	09 79       	subc	r9,	r9	;
    8c20:	39 e3       	inv	r9		;
    x1 = x1%y;
    8c22:	0c 47       	mov	r7,	r12	;
    8c24:	0e 48       	mov	r8,	r14	;
    8c26:	0f 49       	mov	r9,	r15	;
    8c28:	b0 12 26 d0 	call	#53286		;#0xd026
    x1 <<= 16;
    8c2c:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8c30:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    8c34:	05 4c       	mov	r12,	r5	;
    8c36:	81 4d 00 00 	mov	r13,	0(r1)	;
    if (y == 0)
        return 0;
    x1 = x[2]%y;
    x1 <<= 16;
    x1 |= (uint16_t) x[1];
    z = x1/y;
    8c3a:	36 40 a2 cf 	mov	#53154,	r6	;#0xcfa2
    8c3e:	0c 47       	mov	r7,	r12	;
    8c40:	0d 44       	mov	r4,	r13	;
    8c42:	0e 48       	mov	r8,	r14	;
    8c44:	0f 49       	mov	r9,	r15	;
    8c46:	86 12       	call	r6		;
    x1 = x1%y;
    x1 <<= 16;
    x1 |= (uint16_t) x[0];
    z = (z << 16) + x1/y;
    8c48:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8c4c:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    8c50:	07 4c       	mov	r12,	r7	;
    8c52:	04 4d       	mov	r13,	r4	;
    8c54:	0c 45       	mov	r5,	r12	;
    8c56:	2c da       	bis	@r10,	r12	;
    8c58:	2d 41       	mov	@r1,	r13	;
    8c5a:	0e 48       	mov	r8,	r14	;
    8c5c:	0f 49       	mov	r9,	r15	;
    8c5e:	86 12       	call	r6		;
    8c60:	0c 57       	add	r7,	r12	;
    8c62:	0d 64       	addc	r4,	r13	;
    return z;
    8c64:	30 40 6c 8c 	br	#0x8c6c		;
    int32_t x1;
    int32_t z;

    /* Avoid any divide by zero trouble */
    if (y == 0)
        return 0;
    8c68:	0c 43       	clr	r12		;
    8c6a:	0d 4c       	mov	r12,	r13	;
    x1 = x1%y;
    x1 <<= 16;
    x1 |= (uint16_t) x[0];
    z = (z << 16) + x1/y;
    return z;
}
    8c6c:	21 53       	incd	r1		;
    8c6e:	30 40 68 d1 	br	#0xd168		;

00008c72 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    8c72:	0a 12       	push	r10		;
    8c74:	09 12       	push	r9		;
    8c76:	08 12       	push	r8		;
    8c78:	21 83       	decd	r1		;
    8c7a:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8c7c:	18 4c 04 00 	mov	4(r12),	r8	;
    8c80:	0c 48       	mov	r8,	r12	;
    8c82:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8c86:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8c88:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8c8c:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8c90:	00 00 
    8c92:	0c 48       	mov	r8,	r12	;
    8c94:	0d 4f       	mov	r15,	r13	;
    8c96:	0e 4f       	mov	r15,	r14	;
    8c98:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8c9a:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8c9e:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    8ca0:	2c da       	bis	@r10,	r12	;
    8ca2:	21 53       	incd	r1		;
    8ca4:	30 40 70 d1 	br	#0xd170		;

00008ca8 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8ca8:	0a 12       	push	r10		;
    8caa:	09 12       	push	r9		;
    8cac:	08 12       	push	r8		;
    8cae:	07 12       	push	r7		;
    8cb0:	06 12       	push	r6		;
    8cb2:	05 12       	push	r5		;
    8cb4:	21 83       	decd	r1		;
    8cb6:	0a 4c       	mov	r12,	r10	;
    8cb8:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8cbc:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    8cc0:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    8cc4:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8cc8:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8ccc:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8cd0:	00 00 
    8cd2:	0c 49       	mov	r9,	r12	;
    8cd4:	0d 45       	mov	r5,	r13	;
    8cd6:	0e 46       	mov	r6,	r14	;
    8cd8:	0f 47       	mov	r7,	r15	;
    8cda:	88 12       	call	r8		;
    8cdc:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    8ce0:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8ce4:	00 00 
    8ce6:	0c 49       	mov	r9,	r12	;
    8ce8:	0d 45       	mov	r5,	r13	;
    8cea:	0e 46       	mov	r6,	r14	;
    8cec:	0f 47       	mov	r7,	r15	;
    8cee:	88 12       	call	r8		;
    8cf0:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    8cf4:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8cf8:	21 53       	incd	r1		;
    8cfa:	30 40 6a d1 	br	#0xd16a		;

00008cfe <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    8cfe:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8d02:	04 00 
    y[1] = x[1];
    8d04:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8d08:	02 00 
    y[0] = x[0];
    8d0a:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    8d0e:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    8d12:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    8d16:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    8d1a:	30 41       	ret			

00008d1c <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    8d1c:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8d20:	04 00 
    y[1] = x[1];
    8d22:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8d26:	02 00 
    y[0] = x[0];
    8d28:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    8d2c:	30 41       	ret			

00008d2e <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    8d2e:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    8d32:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    8d36:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    8d3a:	30 41       	ret			

00008d3c <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    8d3c:	0f 43       	clr	r15		;
    8d3e:	0f 4e       	mov	r14,	r15	;
    8d40:	0f 5f       	rla	r15		;
    8d42:	0f 7f       	subc	r15,	r15	;
    8d44:	3f e3       	inv	r15		;
    8d46:	8c 5d 00 00 	add	r13,	0(r12)	;
    8d4a:	8c 6e 02 00 	addc	r14,	2(r12)	;
    8d4e:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    8d52:	30 41       	ret			

00008d54 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8d54:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d56:	04 24       	jz	$+10     	;abs 0x8d60
    {
        n--;
    8d58:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8d5a:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8d5c:	0c 93       	cmp	#0,	r12	;r3 As==00
    8d5e:	fc 23       	jnz	$-6      	;abs 0x8d58
    {
        n--;
        __no_operation();
    }
}
    8d60:	30 41       	ret			

00008d62 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    8d62:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8d66:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8d6a:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    8d6e:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    8d72:	30 41       	ret			

00008d74 <imul16>:
{
    int32_t z;

#if defined(__GNUC__)  &&  defined(__MSP430__)
#if (defined(__MSP430_HAS_MPY__)  ||  defined(__MSP430_HAS_MPY32__))  &&  !defined(__TOOLKIT_USE_SOFT_MPY__)
    __asm__ (
    8d74:	02 12       	push	r2		;
    8d76:	32 c2       	dint			
    8d78:	82 4c 32 01 	mov	r12,	&0x0132	;
    8d7c:	82 4d 38 01 	mov	r13,	&0x0138	;
    8d80:	1d 42 3c 01 	mov	&0x013c,r13	;0x013c
    8d84:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    8d88:	32 41       	pop	r2		;
#endif
#else
    z = (int32_t) x*(int32_t) y;
#endif
    return z;
}
    8d8a:	30 41       	ret			

00008d8c <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    8d8c:	0a 12       	push	r10		;
    8d8e:	09 12       	push	r9		;
    8d90:	08 12       	push	r8		;
    8d92:	21 83       	decd	r1		;
    8d94:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8d96:	18 4c 04 00 	mov	4(r12),	r8	;
    8d9a:	0c 48       	mov	r8,	r12	;
    8d9c:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8da0:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8da2:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8da6:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8daa:	00 00 
    8dac:	0c 48       	mov	r8,	r12	;
    8dae:	0d 4f       	mov	r15,	r13	;
    8db0:	0e 4f       	mov	r15,	r14	;
    8db2:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8db4:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8db8:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    8dba:	2c da       	bis	@r10,	r12	;
    8dbc:	21 53       	incd	r1		;
    8dbe:	30 40 70 d1 	br	#0xd170		;

00008dc2 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8dc2:	0a 12       	push	r10		;
    8dc4:	09 12       	push	r9		;
    8dc6:	08 12       	push	r8		;
    8dc8:	07 12       	push	r7		;
    8dca:	06 12       	push	r6		;
    8dcc:	05 12       	push	r5		;
    8dce:	21 83       	decd	r1		;
    8dd0:	0a 4c       	mov	r12,	r10	;
    8dd2:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8dd6:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    8dda:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    8dde:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8de2:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8de6:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8dea:	00 00 
    8dec:	0c 49       	mov	r9,	r12	;
    8dee:	0d 45       	mov	r5,	r13	;
    8df0:	0e 46       	mov	r6,	r14	;
    8df2:	0f 47       	mov	r7,	r15	;
    8df4:	88 12       	call	r8		;
    8df6:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    8dfa:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8dfe:	00 00 
    8e00:	0c 49       	mov	r9,	r12	;
    8e02:	0d 45       	mov	r5,	r13	;
    8e04:	0e 46       	mov	r6,	r14	;
    8e06:	0f 47       	mov	r7,	r15	;
    8e08:	88 12       	call	r8		;
    8e0a:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    8e0e:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8e12:	21 53       	incd	r1		;
    8e14:	30 40 6a d1 	br	#0xd16a		;

00008e18 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    8e18:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8e1c:	04 00 
    y[1] = x[1];
    8e1e:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8e22:	02 00 
    y[0] = x[0];
    8e24:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    8e28:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    8e2c:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    8e30:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    8e34:	30 41       	ret			

00008e36 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    8e36:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8e3a:	04 00 
    y[1] = x[1];
    8e3c:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8e40:	02 00 
    y[0] = x[0];
    8e42:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    8e46:	30 41       	ret			

00008e48 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    8e48:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    8e4c:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    8e50:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    8e54:	30 41       	ret			

00008e56 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    8e56:	0f 43       	clr	r15		;
    8e58:	0f 4e       	mov	r14,	r15	;
    8e5a:	0f 5f       	rla	r15		;
    8e5c:	0f 7f       	subc	r15,	r15	;
    8e5e:	3f e3       	inv	r15		;
    8e60:	8c 5d 00 00 	add	r13,	0(r12)	;
    8e64:	8c 6e 02 00 	addc	r14,	2(r12)	;
    8e68:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    8e6c:	30 41       	ret			

00008e6e <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8e6e:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e70:	04 24       	jz	$+10     	;abs 0x8e7a
    {
        n--;
    8e72:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8e74:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8e76:	0c 93       	cmp	#0,	r12	;r3 As==00
    8e78:	fc 23       	jnz	$-6      	;abs 0x8e72
    {
        n--;
        __no_operation();
    }
}
    8e7a:	30 41       	ret			

00008e7c <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    8e7c:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8e80:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8e84:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    8e88:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    8e8c:	30 41       	ret			

00008e8e <isqrt32>:

#include <inttypes.h>
#include "emeter-toolkit.h"

uint32_t isqrt32(uint32_t h)
{
    8e8e:	09 12       	push	r9		;
    8e90:	08 12       	push	r8		;
    8e92:	07 12       	push	r7		;
    8e94:	06 12       	push	r6		;
            y |= 1;
        h <<= 1;
    }
#endif
    return  x;
}
    8e96:	0e 43       	clr	r14		;
    8e98:	0f 43       	clr	r15		;
    8e9a:	08 43       	clr	r8		;
    8e9c:	39 40 00 80 	mov	#32768,	r9	;#0x8000
    8ea0:	3b 40 20 00 	mov	#32,	r11	;#0x0020
    8ea4:	06 48       	mov	r8,	r6	;
    8ea6:	07 49       	mov	r9,	r7	;
    8ea8:	12 d3       	setc			
    8eaa:	06 66       	rlc	r6		;
    8eac:	07 67       	rlc	r7		;
    8eae:	0e 86       	sub	r6,	r14	;
    8eb0:	0f 77       	subc	r7,	r15	;
    8eb2:	03 2c       	jc	$+8      	;abs 0x8eba
    8eb4:	0e 56       	add	r6,	r14	;
    8eb6:	0f 67       	addc	r7,	r15	;
    8eb8:	26 83       	decd	r6		;
    8eba:	16 53       	inc	r6		;
    8ebc:	0c 5c       	rla	r12		;
    8ebe:	0d 6d       	rlc	r13		;
    8ec0:	0e 6e       	rlc	r14		;
    8ec2:	0f 6f       	rlc	r15		;
    8ec4:	0c 5c       	rla	r12		;
    8ec6:	0d 6d       	rlc	r13		;
    8ec8:	0e 6e       	rlc	r14		;
    8eca:	0f 6f       	rlc	r15		;
    8ecc:	1b 83       	dec	r11		;
    8ece:	ec 23       	jnz	$-38     	;abs 0x8ea8
    8ed0:	0c 46       	mov	r6,	r12	;
    8ed2:	0d 47       	mov	r7,	r13	;
    8ed4:	36 41       	pop	r6		;
    8ed6:	37 41       	pop	r7		;
    8ed8:	38 41       	pop	r8		;
    8eda:	39 41       	pop	r9		;
    8edc:	30 41       	ret			

00008ede <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    8ede:	0a 12       	push	r10		;
    8ee0:	09 12       	push	r9		;
    8ee2:	08 12       	push	r8		;
    8ee4:	21 83       	decd	r1		;
    8ee6:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    8ee8:	18 4c 04 00 	mov	4(r12),	r8	;
    8eec:	0c 48       	mov	r8,	r12	;
    8eee:	b0 12 ec d1 	call	#53740		;#0xd1ec
    8ef2:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    8ef4:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    8ef8:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8efc:	00 00 
    8efe:	0c 48       	mov	r8,	r12	;
    8f00:	0d 4f       	mov	r15,	r13	;
    8f02:	0e 4f       	mov	r15,	r14	;
    8f04:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    8f06:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    8f0a:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    8f0c:	2c da       	bis	@r10,	r12	;
    8f0e:	21 53       	incd	r1		;
    8f10:	30 40 70 d1 	br	#0xd170		;

00008f14 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    8f14:	0a 12       	push	r10		;
    8f16:	09 12       	push	r9		;
    8f18:	08 12       	push	r8		;
    8f1a:	07 12       	push	r7		;
    8f1c:	06 12       	push	r6		;
    8f1e:	05 12       	push	r5		;
    8f20:	21 83       	decd	r1		;
    8f22:	0a 4c       	mov	r12,	r10	;
    8f24:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    8f28:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    8f2c:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    8f30:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    8f34:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    8f38:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    8f3c:	00 00 
    8f3e:	0c 49       	mov	r9,	r12	;
    8f40:	0d 45       	mov	r5,	r13	;
    8f42:	0e 46       	mov	r6,	r14	;
    8f44:	0f 47       	mov	r7,	r15	;
    8f46:	88 12       	call	r8		;
    8f48:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    8f4c:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    8f50:	00 00 
    8f52:	0c 49       	mov	r9,	r12	;
    8f54:	0d 45       	mov	r5,	r13	;
    8f56:	0e 46       	mov	r6,	r14	;
    8f58:	0f 47       	mov	r7,	r15	;
    8f5a:	88 12       	call	r8		;
    8f5c:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    8f60:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    8f64:	21 53       	incd	r1		;
    8f66:	30 40 6a d1 	br	#0xd16a		;

00008f6a <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    8f6a:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8f6e:	04 00 
    y[1] = x[1];
    8f70:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8f74:	02 00 
    y[0] = x[0];
    8f76:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    8f7a:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    8f7e:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    8f82:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    8f86:	30 41       	ret			

00008f88 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    8f88:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    8f8c:	04 00 
    y[1] = x[1];
    8f8e:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    8f92:	02 00 
    y[0] = x[0];
    8f94:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    8f98:	30 41       	ret			

00008f9a <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    8f9a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    8f9e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    8fa2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    8fa6:	30 41       	ret			

00008fa8 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    8fa8:	0f 43       	clr	r15		;
    8faa:	0f 4e       	mov	r14,	r15	;
    8fac:	0f 5f       	rla	r15		;
    8fae:	0f 7f       	subc	r15,	r15	;
    8fb0:	3f e3       	inv	r15		;
    8fb2:	8c 5d 00 00 	add	r13,	0(r12)	;
    8fb6:	8c 6e 02 00 	addc	r14,	2(r12)	;
    8fba:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    8fbe:	30 41       	ret			

00008fc0 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8fc0:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fc2:	04 24       	jz	$+10     	;abs 0x8fcc
    {
        n--;
    8fc4:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    8fc6:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    8fc8:	0c 93       	cmp	#0,	r12	;r3 As==00
    8fca:	fc 23       	jnz	$-6      	;abs 0x8fc4
    {
        n--;
        __no_operation();
    }
}
    8fcc:	30 41       	ret			

00008fce <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    8fce:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    8fd2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    8fd6:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    8fda:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    8fde:	30 41       	ret			

00008fe0 <isqrt32i>:

#include <inttypes.h>
#include "emeter-toolkit.h"

uint16_t isqrt32i(uint32_t h)
{
    8fe0:	0a 12       	push	r10		;
    uint32_t res32;
    uint16_t res16;

    res32 = isqrt32(h);
    8fe2:	b0 12 8e 8e 	call	#36494		;#0x8e8e
    8fe6:	0a 4c       	mov	r12,	r10	;
    res16 = res32 >> 16;
    8fe8:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    8fec:	b0 12 0e d3 	call	#54030		;#0xd30e
    if (res32 & 0x8000LLU)
    8ff0:	0a 93       	cmp	#0,	r10	;r3 As==00
    8ff2:	06 34       	jge	$+14     	;abs 0x9000
    {
        if (res16 != 0xFFFFLU)
    8ff4:	3c 93       	cmp	#-1,	r12	;r3 As==11
    8ff6:	03 24       	jz	$+8      	;abs 0x8ffe
            return res16 + 1;
    8ff8:	1c 53       	inc	r12		;
    8ffa:	30 40 00 90 	br	#0x9000		;
    }
    return res16;
    8ffe:	3c 43       	mov	#-1,	r12	;r3 As==11
}
    9000:	3a 41       	pop	r10		;
    9002:	30 41       	ret			

00009004 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9004:	0a 12       	push	r10		;
    9006:	09 12       	push	r9		;
    9008:	08 12       	push	r8		;
    900a:	21 83       	decd	r1		;
    900c:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    900e:	18 4c 04 00 	mov	4(r12),	r8	;
    9012:	0c 48       	mov	r8,	r12	;
    9014:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9018:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    901a:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    901e:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9022:	00 00 
    9024:	0c 48       	mov	r8,	r12	;
    9026:	0d 4f       	mov	r15,	r13	;
    9028:	0e 4f       	mov	r15,	r14	;
    902a:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    902c:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    9030:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    9032:	2c da       	bis	@r10,	r12	;
    9034:	21 53       	incd	r1		;
    9036:	30 40 70 d1 	br	#0xd170		;

0000903a <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    903a:	0a 12       	push	r10		;
    903c:	09 12       	push	r9		;
    903e:	08 12       	push	r8		;
    9040:	07 12       	push	r7		;
    9042:	06 12       	push	r6		;
    9044:	05 12       	push	r5		;
    9046:	21 83       	decd	r1		;
    9048:	0a 4c       	mov	r12,	r10	;
    904a:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    904e:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    9052:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9056:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    905a:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    905e:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9062:	00 00 
    9064:	0c 49       	mov	r9,	r12	;
    9066:	0d 45       	mov	r5,	r13	;
    9068:	0e 46       	mov	r6,	r14	;
    906a:	0f 47       	mov	r7,	r15	;
    906c:	88 12       	call	r8		;
    906e:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    9072:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9076:	00 00 
    9078:	0c 49       	mov	r9,	r12	;
    907a:	0d 45       	mov	r5,	r13	;
    907c:	0e 46       	mov	r6,	r14	;
    907e:	0f 47       	mov	r7,	r15	;
    9080:	88 12       	call	r8		;
    9082:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    9086:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    908a:	21 53       	incd	r1		;
    908c:	30 40 6a d1 	br	#0xd16a		;

00009090 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    9090:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9094:	04 00 
    y[1] = x[1];
    9096:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    909a:	02 00 
    y[0] = x[0];
    909c:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    90a0:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    90a4:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    90a8:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    90ac:	30 41       	ret			

000090ae <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    90ae:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    90b2:	04 00 
    y[1] = x[1];
    90b4:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    90b8:	02 00 
    y[0] = x[0];
    90ba:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    90be:	30 41       	ret			

000090c0 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    90c0:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    90c4:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    90c8:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    90cc:	30 41       	ret			

000090ce <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    90ce:	0f 43       	clr	r15		;
    90d0:	0f 4e       	mov	r14,	r15	;
    90d2:	0f 5f       	rla	r15		;
    90d4:	0f 7f       	subc	r15,	r15	;
    90d6:	3f e3       	inv	r15		;
    90d8:	8c 5d 00 00 	add	r13,	0(r12)	;
    90dc:	8c 6e 02 00 	addc	r14,	2(r12)	;
    90e0:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    90e4:	30 41       	ret			

000090e6 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    90e6:	0c 93       	cmp	#0,	r12	;r3 As==00
    90e8:	04 24       	jz	$+10     	;abs 0x90f2
    {
        n--;
    90ea:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    90ec:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    90ee:	0c 93       	cmp	#0,	r12	;r3 As==00
    90f0:	fc 23       	jnz	$-6      	;abs 0x90ea
    {
        n--;
        __no_operation();
    }
}
    90f2:	30 41       	ret			

000090f4 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    90f4:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    90f8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    90fc:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9100:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9104:	30 41       	ret			

00009106 <isqrt64>:
#include <inttypes.h>
#include "emeter-toolkit.h"

#if defined(EMETER_TOOLKIT_SUPPORT_64BIT)
uint64_t isqrt64(uint64_t h)
{
    9106:	0a 12       	push	r10		;
    9108:	09 12       	push	r9		;
    910a:	08 12       	push	r8		;
    910c:	07 12       	push	r7		;
    910e:	06 12       	push	r6		;
    9110:	05 12       	push	r5		;
    9112:	04 12       	push	r4		;
    9114:	31 80 16 00 	sub	#22,	r1	;#0x0016
    9118:	0b 4c       	mov	r12,	r11	;
    911a:	81 4d 00 00 	mov	r13,	0(r1)	;
    911e:	81 4e 06 00 	mov	r14,	6(r1)	;
    9122:	81 4f 08 00 	mov	r15,	8(r1)	;
    9126:	b1 40 40 00 	mov	#64,	20(r1)	;#0x0040, 0x0014
    912a:	14 00 
//        " jne   1b \n"
//        : [x] "+r"(x), [y] "+r"(y)
//        : [h] "r"(h), [i] "r"(i));
//#else
    x =
    y = 0;
    912c:	07 43       	clr	r7		;
    912e:	81 47 04 00 	mov	r7,	4(r1)	;
//        " dec   %[i] \n"
//        " jne   1b \n"
//        : [x] "+r"(x), [y] "+r"(y)
//        : [h] "r"(h), [i] "r"(i));
//#else
    x =
    9132:	81 47 0c 00 	mov	r7,	12(r1)	; 0x000c
    9136:	81 47 0e 00 	mov	r7,	14(r1)	; 0x000e
    913a:	81 47 10 00 	mov	r7,	16(r1)	; 0x0010
    913e:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    y = 0;
    for (i = 0;  i < 64;  i++)
    {
        x = (x << 1) | 1;
    9142:	15 43       	mov	#1,	r5	;r3 As==01
    9144:	06 47       	mov	r7,	r6	;
        if (y < x)
            x -= 2;
    9146:	81 47 02 00 	mov	r7,	2(r1)	;
    914a:	81 4b 0a 00 	mov	r11,	10(r1)	; 0x000a
    914e:	0b 47       	mov	r7,	r11	;
//#else
    x =
    y = 0;
    for (i = 0;  i < 64;  i++)
    {
        x = (x << 1) | 1;
    9150:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    9154:	0d 5d       	rla	r13		;
    9156:	0c 45       	mov	r5,	r12	;
    9158:	1d 91 0c 00 	cmp	12(r1),	r13	;0x0000c
    915c:	01 28       	jnc	$+4      	;abs 0x9160
    915e:	0c 46       	mov	r6,	r12	;
    9160:	1e 41 0e 00 	mov	14(r1),	r14	;0x0000e
    9164:	0e 5e       	rla	r14		;
    9166:	09 45       	mov	r5,	r9	;
    9168:	1e 91 0e 00 	cmp	14(r1),	r14	;0x0000e
    916c:	01 28       	jnc	$+4      	;abs 0x9170
    916e:	09 46       	mov	r6,	r9	;
    9170:	0c 5e       	add	r14,	r12	;
    9172:	0f 45       	mov	r5,	r15	;
    9174:	0c 9e       	cmp	r14,	r12	;
    9176:	01 28       	jnc	$+4      	;abs 0x917a
    9178:	0f 46       	mov	r6,	r15	;
    917a:	09 df       	bis	r15,	r9	;
    917c:	1e 41 10 00 	mov	16(r1),	r14	;0x00010
    9180:	0e 5e       	rla	r14		;
    9182:	0a 45       	mov	r5,	r10	;
    9184:	1e 91 10 00 	cmp	16(r1),	r14	;0x00010
    9188:	01 28       	jnc	$+4      	;abs 0x918c
    918a:	0a 46       	mov	r6,	r10	;
    918c:	09 5e       	add	r14,	r9	;
    918e:	0f 45       	mov	r5,	r15	;
    9190:	09 9e       	cmp	r14,	r9	;
    9192:	01 28       	jnc	$+4      	;abs 0x9196
    9194:	0f 46       	mov	r6,	r15	;
    9196:	0a df       	bis	r15,	r10	;
    9198:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    919c:	0f 5f       	rla	r15		;
    919e:	0f 5a       	add	r10,	r15	;
    91a0:	1d d3       	bis	#1,	r13	;r3 As==01
    91a2:	0a 49       	mov	r9,	r10	;
    91a4:	0e 4f       	mov	r15,	r14	;
        if (y < x)
    91a6:	81 9f 04 00 	cmp	r15,	4(r1)	;
    91aa:	0f 28       	jnc	$+32     	;abs 0x91ca
    91ac:	1f 91 04 00 	cmp	4(r1),	r15	;
    91b0:	32 20       	jnz	$+102    	;abs 0x9216
    91b2:	81 99 02 00 	cmp	r9,	2(r1)	;
    91b6:	09 28       	jnc	$+20     	;abs 0x91ca
    91b8:	19 91 02 00 	cmp	2(r1),	r9	;
    91bc:	2c 20       	jnz	$+90     	;abs 0x9216
    91be:	0b 9c       	cmp	r12,	r11	;
    91c0:	04 28       	jnc	$+10     	;abs 0x91ca
    91c2:	0c 9b       	cmp	r11,	r12	;
    91c4:	28 20       	jnz	$+82     	;abs 0x9216
    91c6:	07 9d       	cmp	r13,	r7	;
    91c8:	26 2c       	jc	$+78     	;abs 0x9216
            x -= 2;
    91ca:	08 4d       	mov	r13,	r8	;
    91cc:	38 50 fe ff 	add	#65534,	r8	;#0xfffe
    91d0:	0e 45       	mov	r5,	r14	;
    91d2:	08 9d       	cmp	r13,	r8	;
    91d4:	01 28       	jnc	$+4      	;abs 0x91d8
    91d6:	0e 46       	mov	r6,	r14	;
    91d8:	04 4c       	mov	r12,	r4	;
    91da:	34 53       	add	#-1,	r4	;r3 As==11
    91dc:	0d 45       	mov	r5,	r13	;
    91de:	04 9c       	cmp	r12,	r4	;
    91e0:	01 28       	jnc	$+4      	;abs 0x91e4
    91e2:	0d 46       	mov	r6,	r13	;
    91e4:	0c 4e       	mov	r14,	r12	;
    91e6:	0c 54       	add	r4,	r12	;
    91e8:	0e 45       	mov	r5,	r14	;
    91ea:	0c 94       	cmp	r4,	r12	;
    91ec:	01 28       	jnc	$+4      	;abs 0x91f0
    91ee:	0e 46       	mov	r6,	r14	;
    91f0:	0d de       	bis	r14,	r13	;
    91f2:	39 53       	add	#-1,	r9	;r3 As==11
    91f4:	04 45       	mov	r5,	r4	;
    91f6:	09 9a       	cmp	r10,	r9	;
    91f8:	01 28       	jnc	$+4      	;abs 0x91fc
    91fa:	04 46       	mov	r6,	r4	;
    91fc:	0a 4d       	mov	r13,	r10	;
    91fe:	0a 59       	add	r9,	r10	;
    9200:	0d 45       	mov	r5,	r13	;
    9202:	0a 99       	cmp	r9,	r10	;
    9204:	01 28       	jnc	$+4      	;abs 0x9208
    9206:	0d 46       	mov	r6,	r13	;
    9208:	04 dd       	bis	r13,	r4	;
    920a:	0e 4f       	mov	r15,	r14	;
    920c:	3e 53       	add	#-1,	r14	;r3 As==11
    920e:	0d 48       	mov	r8,	r13	;
    9210:	0e 54       	add	r4,	r14	;
    9212:	30 40 72 92 	br	#0x9272		;
        else
            y -= x;
    9216:	08 47       	mov	r7,	r8	;
    9218:	08 8d       	sub	r13,	r8	;
    921a:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c
    921e:	04 45       	mov	r5,	r4	;
    9220:	07 98       	cmp	r8,	r7	;
    9222:	01 28       	jnc	$+4      	;abs 0x9226
    9224:	04 46       	mov	r6,	r4	;
    9226:	07 4b       	mov	r11,	r7	;
    9228:	07 8c       	sub	r12,	r7	;
    922a:	08 45       	mov	r5,	r8	;
    922c:	0b 97       	cmp	r7,	r11	;
    922e:	01 28       	jnc	$+4      	;abs 0x9232
    9230:	08 46       	mov	r6,	r8	;
    9232:	0b 47       	mov	r7,	r11	;
    9234:	0b 84       	sub	r4,	r11	;
    9236:	04 45       	mov	r5,	r4	;
    9238:	07 9b       	cmp	r11,	r7	;
    923a:	01 28       	jnc	$+4      	;abs 0x923e
    923c:	04 46       	mov	r6,	r4	;
    923e:	08 d4       	bis	r4,	r8	;
    9240:	17 41 02 00 	mov	2(r1),	r7	;
    9244:	07 89       	sub	r9,	r7	;
    9246:	09 45       	mov	r5,	r9	;
    9248:	81 97 02 00 	cmp	r7,	2(r1)	;
    924c:	01 28       	jnc	$+4      	;abs 0x9250
    924e:	09 46       	mov	r6,	r9	;
    9250:	04 47       	mov	r7,	r4	;
    9252:	04 88       	sub	r8,	r4	;
    9254:	08 45       	mov	r5,	r8	;
    9256:	07 94       	cmp	r4,	r7	;
    9258:	01 28       	jnc	$+4      	;abs 0x925c
    925a:	08 46       	mov	r6,	r8	;
    925c:	09 d8       	bis	r8,	r9	;
    925e:	18 41 04 00 	mov	4(r1),	r8	;
    9262:	08 8f       	sub	r15,	r8	;
    9264:	17 41 0c 00 	mov	12(r1),	r7	;0x0000c
    9268:	81 44 02 00 	mov	r4,	2(r1)	;
    926c:	08 89       	sub	r9,	r8	;
    926e:	81 48 04 00 	mov	r8,	4(r1)	;
        x++;
    9272:	09 4d       	mov	r13,	r9	;
    9274:	09 55       	add	r5,	r9	;
    9276:	0f 45       	mov	r5,	r15	;
    9278:	09 9d       	cmp	r13,	r9	;
    927a:	01 28       	jnc	$+4      	;abs 0x927e
    927c:	0f 46       	mov	r6,	r15	;
    927e:	08 4c       	mov	r12,	r8	;
    9280:	0d 45       	mov	r5,	r13	;
    9282:	0c 9c       	cmp	r12,	r12	;
    9284:	01 28       	jnc	$+4      	;abs 0x9288
    9286:	0d 46       	mov	r6,	r13	;
    9288:	0f 58       	add	r8,	r15	;
    928a:	0c 45       	mov	r5,	r12	;
    928c:	0f 98       	cmp	r8,	r15	;
    928e:	01 28       	jnc	$+4      	;abs 0x9292
    9290:	0c 46       	mov	r6,	r12	;
    9292:	0d dc       	bis	r12,	r13	;
    9294:	08 4a       	mov	r10,	r8	;
    9296:	0c 45       	mov	r5,	r12	;
    9298:	0a 9a       	cmp	r10,	r10	;
    929a:	01 28       	jnc	$+4      	;abs 0x929e
    929c:	0c 46       	mov	r6,	r12	;
    929e:	0d 58       	add	r8,	r13	;
    92a0:	0a 45       	mov	r5,	r10	;
    92a2:	0d 98       	cmp	r8,	r13	;
    92a4:	01 28       	jnc	$+4      	;abs 0x92a8
    92a6:	0a 46       	mov	r6,	r10	;
    92a8:	0c da       	bis	r10,	r12	;
    92aa:	81 49 0c 00 	mov	r9,	12(r1)	; 0x000c
    92ae:	81 4f 0e 00 	mov	r15,	14(r1)	; 0x000e
    92b2:	81 4d 10 00 	mov	r13,	16(r1)	; 0x0010
    92b6:	0c 5e       	add	r14,	r12	;
    92b8:	81 4c 12 00 	mov	r12,	18(r1)	; 0x0012
        y <<= 1;
    92bc:	0c 47       	mov	r7,	r12	;
    92be:	0c 57       	add	r7,	r12	;
    92c0:	0d 45       	mov	r5,	r13	;
    92c2:	0c 97       	cmp	r7,	r12	;
    92c4:	01 28       	jnc	$+4      	;abs 0x92c8
    92c6:	0d 46       	mov	r6,	r13	;
    92c8:	0e 4b       	mov	r11,	r14	;
    92ca:	0e 5b       	add	r11,	r14	;
    92cc:	0a 45       	mov	r5,	r10	;
    92ce:	0e 9b       	cmp	r11,	r14	;
    92d0:	01 28       	jnc	$+4      	;abs 0x92d4
    92d2:	0a 46       	mov	r6,	r10	;
    92d4:	0d 5e       	add	r14,	r13	;
    92d6:	0f 45       	mov	r5,	r15	;
    92d8:	0d 9e       	cmp	r14,	r13	;
    92da:	01 28       	jnc	$+4      	;abs 0x92de
    92dc:	0f 46       	mov	r6,	r15	;
    92de:	0a df       	bis	r15,	r10	;
    92e0:	1f 41 02 00 	mov	2(r1),	r15	;
    92e4:	0f 5f       	rla	r15		;
    92e6:	0e 45       	mov	r5,	r14	;
    92e8:	1f 91 02 00 	cmp	2(r1),	r15	;
    92ec:	01 28       	jnc	$+4      	;abs 0x92f0
    92ee:	0e 46       	mov	r6,	r14	;
    92f0:	0a 5f       	add	r15,	r10	;
    92f2:	09 45       	mov	r5,	r9	;
    92f4:	0a 9f       	cmp	r15,	r10	;
    92f6:	01 28       	jnc	$+4      	;abs 0x92fa
    92f8:	09 46       	mov	r6,	r9	;
    92fa:	0e d9       	bis	r9,	r14	;
    92fc:	18 41 04 00 	mov	4(r1),	r8	;
    9300:	08 58       	rla	r8		;
    9302:	09 4e       	mov	r14,	r9	;
    9304:	09 58       	add	r8,	r9	;
    9306:	0f 4c       	mov	r12,	r15	;
    9308:	08 4d       	mov	r13,	r8	;
    930a:	0b 4a       	mov	r10,	r11	;
    930c:	0e 49       	mov	r9,	r14	;
        if ((h & 0x8000000000000000ULL))
    930e:	81 93 08 00 	cmp	#0,	8(r1)	;r3 As==00
    9312:	01 34       	jge	$+4      	;abs 0x9316
            y |= 1;
    9314:	1f d3       	bis	#1,	r15	;r3 As==01
        h <<= 1;
    9316:	1a 41 0a 00 	mov	10(r1),	r10	;0x0000a
    931a:	0a 5a       	rla	r10		;
    931c:	0d 45       	mov	r5,	r13	;
    931e:	1a 91 0a 00 	cmp	10(r1),	r10	;0x0000a
    9322:	01 28       	jnc	$+4      	;abs 0x9326
    9324:	0d 46       	mov	r6,	r13	;
    9326:	29 41       	mov	@r1,	r9	;
    9328:	09 59       	rla	r9		;
    932a:	0c 45       	mov	r5,	r12	;
    932c:	29 91       	cmp	@r1,	r9	;
    932e:	01 28       	jnc	$+4      	;abs 0x9332
    9330:	0c 46       	mov	r6,	r12	;
    9332:	0d 59       	add	r9,	r13	;
    9334:	07 45       	mov	r5,	r7	;
    9336:	0d 99       	cmp	r9,	r13	;
    9338:	01 28       	jnc	$+4      	;abs 0x933c
    933a:	07 46       	mov	r6,	r7	;
    933c:	0c d7       	bis	r7,	r12	;
    933e:	17 41 06 00 	mov	6(r1),	r7	;
    9342:	07 57       	rla	r7		;
    9344:	09 45       	mov	r5,	r9	;
    9346:	17 91 06 00 	cmp	6(r1),	r7	;
    934a:	01 28       	jnc	$+4      	;abs 0x934e
    934c:	09 46       	mov	r6,	r9	;
    934e:	0c 57       	add	r7,	r12	;
    9350:	04 45       	mov	r5,	r4	;
    9352:	0c 97       	cmp	r7,	r12	;
    9354:	01 28       	jnc	$+4      	;abs 0x9358
    9356:	04 46       	mov	r6,	r4	;
    9358:	09 d4       	bis	r4,	r9	;
    935a:	17 41 08 00 	mov	8(r1),	r7	;
    935e:	07 57       	rla	r7		;
    9360:	04 49       	mov	r9,	r4	;
    9362:	04 57       	add	r7,	r4	;
    9364:	81 4a 06 00 	mov	r10,	6(r1)	;
    9368:	81 4c 08 00 	mov	r12,	8(r1)	;
    936c:	81 44 0a 00 	mov	r4,	10(r1)	; 0x000a
        y <<= 1;
    9370:	09 4f       	mov	r15,	r9	;
    9372:	09 5f       	add	r15,	r9	;
    9374:	81 49 00 00 	mov	r9,	0(r1)	;
    9378:	09 45       	mov	r5,	r9	;
    937a:	81 9f 00 00 	cmp	r15,	0(r1)	;
    937e:	01 28       	jnc	$+4      	;abs 0x9382
    9380:	09 46       	mov	r6,	r9	;
    9382:	07 48       	mov	r8,	r7	;
    9384:	07 58       	add	r8,	r7	;
    9386:	0f 45       	mov	r5,	r15	;
    9388:	07 98       	cmp	r8,	r7	;
    938a:	01 28       	jnc	$+4      	;abs 0x938e
    938c:	0f 46       	mov	r6,	r15	;
    938e:	09 57       	add	r7,	r9	;
    9390:	08 45       	mov	r5,	r8	;
    9392:	09 97       	cmp	r7,	r9	;
    9394:	01 28       	jnc	$+4      	;abs 0x9398
    9396:	08 46       	mov	r6,	r8	;
    9398:	0f d8       	bis	r8,	r15	;
    939a:	07 4b       	mov	r11,	r7	;
    939c:	07 5b       	add	r11,	r7	;
    939e:	08 45       	mov	r5,	r8	;
    93a0:	07 9b       	cmp	r11,	r7	;
    93a2:	01 28       	jnc	$+4      	;abs 0x93a6
    93a4:	08 46       	mov	r6,	r8	;
    93a6:	0f 57       	add	r7,	r15	;
    93a8:	0b 45       	mov	r5,	r11	;
    93aa:	0f 97       	cmp	r7,	r15	;
    93ac:	01 28       	jnc	$+4      	;abs 0x93b0
    93ae:	0b 46       	mov	r6,	r11	;
    93b0:	08 db       	bis	r11,	r8	;
    93b2:	0e 5e       	rla	r14		;
    93b4:	0e 58       	add	r8,	r14	;
    93b6:	27 41       	mov	@r1,	r7	;
    93b8:	0b 49       	mov	r9,	r11	;
    93ba:	81 4f 02 00 	mov	r15,	2(r1)	;
    93be:	81 4e 04 00 	mov	r14,	4(r1)	;
        if ((h & 0x8000000000000000ULL))
    93c2:	81 93 0a 00 	cmp	#0,	10(r1)	;r3 As==00, 0x000a
    93c6:	01 34       	jge	$+4      	;abs 0x93ca
            y |= 1;
    93c8:	17 d3       	bis	#1,	r7	;r3 As==01
        h <<= 1;
    93ca:	0a 5a       	rla	r10		;
    93cc:	0f 45       	mov	r5,	r15	;
    93ce:	1a 91 06 00 	cmp	6(r1),	r10	;
    93d2:	01 28       	jnc	$+4      	;abs 0x93d6
    93d4:	0f 46       	mov	r6,	r15	;
    93d6:	09 4d       	mov	r13,	r9	;
    93d8:	09 5d       	add	r13,	r9	;
    93da:	0e 45       	mov	r5,	r14	;
    93dc:	09 9d       	cmp	r13,	r9	;
    93de:	01 28       	jnc	$+4      	;abs 0x93e2
    93e0:	0e 46       	mov	r6,	r14	;
    93e2:	0f 59       	add	r9,	r15	;
    93e4:	0d 45       	mov	r5,	r13	;
    93e6:	0f 99       	cmp	r9,	r15	;
    93e8:	01 28       	jnc	$+4      	;abs 0x93ec
    93ea:	0d 46       	mov	r6,	r13	;
    93ec:	0e dd       	bis	r13,	r14	;
    93ee:	0c 5c       	rla	r12		;
    93f0:	0d 45       	mov	r5,	r13	;
    93f2:	1c 91 08 00 	cmp	8(r1),	r12	;
    93f6:	01 28       	jnc	$+4      	;abs 0x93fa
    93f8:	0d 46       	mov	r6,	r13	;
    93fa:	0e 5c       	add	r12,	r14	;
    93fc:	09 45       	mov	r5,	r9	;
    93fe:	0e 9c       	cmp	r12,	r14	;
    9400:	01 28       	jnc	$+4      	;abs 0x9404
    9402:	09 46       	mov	r6,	r9	;
    9404:	0d d9       	bis	r9,	r13	;
    9406:	0c 44       	mov	r4,	r12	;
    9408:	0c 54       	add	r4,	r12	;
    940a:	81 4a 0a 00 	mov	r10,	10(r1)	; 0x000a
    940e:	81 4f 00 00 	mov	r15,	0(r1)	;
    9412:	81 4e 06 00 	mov	r14,	6(r1)	;
    9416:	0d 5c       	add	r12,	r13	;
    9418:	81 4d 08 00 	mov	r13,	8(r1)	;
    941c:	b1 53 14 00 	add	#-1,	20(r1)	;r3 As==11, 0x0014
//        : [x] "+r"(x), [y] "+r"(y)
//        : [h] "r"(h), [i] "r"(i));
//#else
    x =
    y = 0;
    for (i = 0;  i < 64;  i++)
    9420:	81 93 14 00 	cmp	#0,	20(r1)	;r3 As==00, 0x0014
    9424:	95 22       	jnz	$-724    	;abs 0x9150
            y |= 1;
        h <<= 1;
    }
//#endif
    return  x;
}
    9426:	1c 41 0c 00 	mov	12(r1),	r12	;0x0000c
    942a:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    942e:	1e 41 10 00 	mov	16(r1),	r14	;0x00010
    9432:	1f 41 12 00 	mov	18(r1),	r15	;0x00012
    9436:	31 50 16 00 	add	#22,	r1	;#0x0016
    943a:	30 40 68 d1 	br	#0xd168		;

0000943e <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    943e:	0a 12       	push	r10		;
    9440:	09 12       	push	r9		;
    9442:	08 12       	push	r8		;
    9444:	21 83       	decd	r1		;
    9446:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9448:	18 4c 04 00 	mov	4(r12),	r8	;
    944c:	0c 48       	mov	r8,	r12	;
    944e:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9452:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9454:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9458:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    945c:	00 00 
    945e:	0c 48       	mov	r8,	r12	;
    9460:	0d 4f       	mov	r15,	r13	;
    9462:	0e 4f       	mov	r15,	r14	;
    9464:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    9466:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    946a:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    946c:	2c da       	bis	@r10,	r12	;
    946e:	21 53       	incd	r1		;
    9470:	30 40 70 d1 	br	#0xd170		;

00009474 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    9474:	0a 12       	push	r10		;
    9476:	09 12       	push	r9		;
    9478:	08 12       	push	r8		;
    947a:	07 12       	push	r7		;
    947c:	06 12       	push	r6		;
    947e:	05 12       	push	r5		;
    9480:	21 83       	decd	r1		;
    9482:	0a 4c       	mov	r12,	r10	;
    9484:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    9488:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    948c:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9490:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    9494:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    9498:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    949c:	00 00 
    949e:	0c 49       	mov	r9,	r12	;
    94a0:	0d 45       	mov	r5,	r13	;
    94a2:	0e 46       	mov	r6,	r14	;
    94a4:	0f 47       	mov	r7,	r15	;
    94a6:	88 12       	call	r8		;
    94a8:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    94ac:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    94b0:	00 00 
    94b2:	0c 49       	mov	r9,	r12	;
    94b4:	0d 45       	mov	r5,	r13	;
    94b6:	0e 46       	mov	r6,	r14	;
    94b8:	0f 47       	mov	r7,	r15	;
    94ba:	88 12       	call	r8		;
    94bc:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    94c0:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    94c4:	21 53       	incd	r1		;
    94c6:	30 40 6a d1 	br	#0xd16a		;

000094ca <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    94ca:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    94ce:	04 00 
    y[1] = x[1];
    94d0:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    94d4:	02 00 
    y[0] = x[0];
    94d6:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    94da:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    94de:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    94e2:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    94e6:	30 41       	ret			

000094e8 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    94e8:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    94ec:	04 00 
    y[1] = x[1];
    94ee:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    94f2:	02 00 
    y[0] = x[0];
    94f4:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    94f8:	30 41       	ret			

000094fa <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    94fa:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    94fe:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9502:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9506:	30 41       	ret			

00009508 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9508:	0f 43       	clr	r15		;
    950a:	0f 4e       	mov	r14,	r15	;
    950c:	0f 5f       	rla	r15		;
    950e:	0f 7f       	subc	r15,	r15	;
    9510:	3f e3       	inv	r15		;
    9512:	8c 5d 00 00 	add	r13,	0(r12)	;
    9516:	8c 6e 02 00 	addc	r14,	2(r12)	;
    951a:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    951e:	30 41       	ret			

00009520 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9520:	0c 93       	cmp	#0,	r12	;r3 As==00
    9522:	04 24       	jz	$+10     	;abs 0x952c
    {
        n--;
    9524:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9526:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9528:	0c 93       	cmp	#0,	r12	;r3 As==00
    952a:	fc 23       	jnz	$-6      	;abs 0x9524
    {
        n--;
        __no_operation();
    }
}
    952c:	30 41       	ret			

0000952e <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    952e:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9532:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9536:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    953a:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    953e:	30 41       	ret			

00009540 <isqrt64i>:
#include <inttypes.h>
#include "emeter-toolkit.h"

#if defined(EMETER_TOOLKIT_SUPPORT_64BIT)
uint32_t isqrt64i(uint64_t h)
{
    9540:	0a 12       	push	r10		;
    9542:	21 83       	decd	r1		;
    uint64_t res64;
    uint32_t res32;

    res64 = isqrt64(h);
    9544:	b0 12 06 91 	call	#37126		;#0x9106
    9548:	0a 4d       	mov	r13,	r10	;
    res32 = res64 >> 32;
    954a:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    954e:	00 00 
    9550:	b0 12 98 cc 	call	#52376		;#0xcc98
    9554:	0e 4c       	mov	r12,	r14	;
    9556:	0f 4d       	mov	r13,	r15	;
    if (res64 & 0x80000000LLU)
    9558:	0a 93       	cmp	#0,	r10	;r3 As==00
    955a:	09 34       	jge	$+20     	;abs 0x956e
    {
        if (res32 != 0xFFFFFFFFLU)
    955c:	3e 93       	cmp	#-1,	r14	;r3 As==11
    955e:	02 20       	jnz	$+6      	;abs 0x9564
    9560:	3d 93       	cmp	#-1,	r13	;r3 As==11
    9562:	08 24       	jz	$+18     	;abs 0x9574
            return res32 + 1;
    9564:	1c 53       	inc	r12		;
    9566:	0d 4f       	mov	r15,	r13	;
    9568:	0d 63       	adc	r13		;
    956a:	30 40 78 95 	br	#0x9578		;
    }
    return res32;
    956e:	0c 4e       	mov	r14,	r12	;
    9570:	30 40 78 95 	br	#0x9578		;
    9574:	3c 43       	mov	#-1,	r12	;r3 As==11
    9576:	0d 4c       	mov	r12,	r13	;
}
    9578:	21 53       	incd	r1		;
    957a:	3a 41       	pop	r10		;
    957c:	30 41       	ret			

0000957e <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    957e:	0a 12       	push	r10		;
    9580:	09 12       	push	r9		;
    9582:	08 12       	push	r8		;
    9584:	21 83       	decd	r1		;
    9586:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9588:	18 4c 04 00 	mov	4(r12),	r8	;
    958c:	0c 48       	mov	r8,	r12	;
    958e:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9592:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9594:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9598:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    959c:	00 00 
    959e:	0c 48       	mov	r8,	r12	;
    95a0:	0d 4f       	mov	r15,	r13	;
    95a2:	0e 4f       	mov	r15,	r14	;
    95a4:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    95a6:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    95aa:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    95ac:	2c da       	bis	@r10,	r12	;
    95ae:	21 53       	incd	r1		;
    95b0:	30 40 70 d1 	br	#0xd170		;

000095b4 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    95b4:	0a 12       	push	r10		;
    95b6:	09 12       	push	r9		;
    95b8:	08 12       	push	r8		;
    95ba:	07 12       	push	r7		;
    95bc:	06 12       	push	r6		;
    95be:	05 12       	push	r5		;
    95c0:	21 83       	decd	r1		;
    95c2:	0a 4c       	mov	r12,	r10	;
    95c4:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    95c8:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    95cc:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    95d0:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    95d4:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    95d8:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    95dc:	00 00 
    95de:	0c 49       	mov	r9,	r12	;
    95e0:	0d 45       	mov	r5,	r13	;
    95e2:	0e 46       	mov	r6,	r14	;
    95e4:	0f 47       	mov	r7,	r15	;
    95e6:	88 12       	call	r8		;
    95e8:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    95ec:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    95f0:	00 00 
    95f2:	0c 49       	mov	r9,	r12	;
    95f4:	0d 45       	mov	r5,	r13	;
    95f6:	0e 46       	mov	r6,	r14	;
    95f8:	0f 47       	mov	r7,	r15	;
    95fa:	88 12       	call	r8		;
    95fc:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    9600:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    9604:	21 53       	incd	r1		;
    9606:	30 40 6a d1 	br	#0xd16a		;

0000960a <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    960a:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    960e:	04 00 
    y[1] = x[1];
    9610:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9614:	02 00 
    y[0] = x[0];
    9616:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    961a:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    961e:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    9622:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9626:	30 41       	ret			

00009628 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9628:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    962c:	04 00 
    y[1] = x[1];
    962e:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9632:	02 00 
    y[0] = x[0];
    9634:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9638:	30 41       	ret			

0000963a <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    963a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    963e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9642:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9646:	30 41       	ret			

00009648 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9648:	0f 43       	clr	r15		;
    964a:	0f 4e       	mov	r14,	r15	;
    964c:	0f 5f       	rla	r15		;
    964e:	0f 7f       	subc	r15,	r15	;
    9650:	3f e3       	inv	r15		;
    9652:	8c 5d 00 00 	add	r13,	0(r12)	;
    9656:	8c 6e 02 00 	addc	r14,	2(r12)	;
    965a:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    965e:	30 41       	ret			

00009660 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9660:	0c 93       	cmp	#0,	r12	;r3 As==00
    9662:	04 24       	jz	$+10     	;abs 0x966c
    {
        n--;
    9664:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9666:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9668:	0c 93       	cmp	#0,	r12	;r3 As==00
    966a:	fc 23       	jnz	$-6      	;abs 0x9664
    {
        n--;
        __no_operation();
    }
}
    966c:	30 41       	ret			

0000966e <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    966e:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9672:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9676:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    967a:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    967e:	30 41       	ret			

00009680 <mac48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__GNUC__)  &&  defined(__MSP430__)
    int16_t y_ex = 0;

    __asm__ __volatile__ (
    9680:	0e 43       	clr	r14		;
    9682:	0e 4e       	mov	r14,	r14	;
    9684:	0e 5e       	rla	r14		;
    9686:	0e 7e       	subc	r14,	r14	;
    9688:	3e e3       	inv	r14		;
    968a:	8c 5d 00 00 	add	r13,	0(r12)	;
    968e:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9692:	8c 6e 04 00 	addc	r14,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9696:	30 41       	ret			

00009698 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9698:	0a 12       	push	r10		;
    969a:	09 12       	push	r9		;
    969c:	08 12       	push	r8		;
    969e:	21 83       	decd	r1		;
    96a0:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    96a2:	18 4c 04 00 	mov	4(r12),	r8	;
    96a6:	0c 48       	mov	r8,	r12	;
    96a8:	b0 12 ec d1 	call	#53740		;#0xd1ec
    96ac:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    96ae:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    96b2:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    96b6:	00 00 
    96b8:	0c 48       	mov	r8,	r12	;
    96ba:	0d 4f       	mov	r15,	r13	;
    96bc:	0e 4f       	mov	r15,	r14	;
    96be:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    96c0:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    96c4:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    96c6:	2c da       	bis	@r10,	r12	;
    96c8:	21 53       	incd	r1		;
    96ca:	30 40 70 d1 	br	#0xd170		;

000096ce <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    96ce:	0a 12       	push	r10		;
    96d0:	09 12       	push	r9		;
    96d2:	08 12       	push	r8		;
    96d4:	07 12       	push	r7		;
    96d6:	06 12       	push	r6		;
    96d8:	05 12       	push	r5		;
    96da:	21 83       	decd	r1		;
    96dc:	0a 4c       	mov	r12,	r10	;
    96de:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    96e2:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    96e6:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    96ea:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    96ee:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    96f2:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    96f6:	00 00 
    96f8:	0c 49       	mov	r9,	r12	;
    96fa:	0d 45       	mov	r5,	r13	;
    96fc:	0e 46       	mov	r6,	r14	;
    96fe:	0f 47       	mov	r7,	r15	;
    9700:	88 12       	call	r8		;
    9702:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    9706:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    970a:	00 00 
    970c:	0c 49       	mov	r9,	r12	;
    970e:	0d 45       	mov	r5,	r13	;
    9710:	0e 46       	mov	r6,	r14	;
    9712:	0f 47       	mov	r7,	r15	;
    9714:	88 12       	call	r8		;
    9716:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    971a:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    971e:	21 53       	incd	r1		;
    9720:	30 40 6a d1 	br	#0xd16a		;

00009724 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    9724:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9728:	04 00 
    y[1] = x[1];
    972a:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    972e:	02 00 
    y[0] = x[0];
    9730:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    9734:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    9738:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    973c:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9740:	30 41       	ret			

00009742 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9742:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9746:	04 00 
    y[1] = x[1];
    9748:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    974c:	02 00 
    y[0] = x[0];
    974e:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9752:	30 41       	ret			

00009754 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    9754:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    9758:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    975c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9760:	30 41       	ret			

00009762 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9762:	0f 43       	clr	r15		;
    9764:	0f 4e       	mov	r14,	r15	;
    9766:	0f 5f       	rla	r15		;
    9768:	0f 7f       	subc	r15,	r15	;
    976a:	3f e3       	inv	r15		;
    976c:	8c 5d 00 00 	add	r13,	0(r12)	;
    9770:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9774:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9778:	30 41       	ret			

0000977a <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    977a:	0c 93       	cmp	#0,	r12	;r3 As==00
    977c:	04 24       	jz	$+10     	;abs 0x9786
    {
        n--;
    977e:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9780:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9782:	0c 93       	cmp	#0,	r12	;r3 As==00
    9784:	fc 23       	jnz	$-6      	;abs 0x977e
    {
        n--;
        __no_operation();
    }
}
    9786:	30 41       	ret			

00009788 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    9788:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    978c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9790:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9794:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9798:	30 41       	ret			

0000979a <mac64_16_24>:

#include <inttypes.h>
#include "emeter-toolkit.h"

void mac64_16_24(int64_t *z, int16_t x, int32_t y)
{
    979a:	0a 12       	push	r10		;
    979c:	09 12       	push	r9		;
    979e:	08 12       	push	r8		;
    97a0:	07 12       	push	r7		;
    97a2:	06 12       	push	r6		;
    97a4:	05 12       	push	r5		;
    97a6:	04 12       	push	r4		;
    97a8:	07 4c       	mov	r12,	r7	;
    97aa:	08 4d       	mov	r13,	r8	;
    97ac:	0a 4e       	mov	r14,	r10	;
    97ae:	05 4f       	mov	r15,	r5	;
    *z += (int64_t) x*(int64_t) y;
    97b0:	0c 4d       	mov	r13,	r12	;
    97b2:	b0 12 ec d1 	call	#53740		;#0xd1ec
    97b6:	06 4c       	mov	r12,	r6	;
    97b8:	04 4a       	mov	r10,	r4	;
    97ba:	0c 45       	mov	r5,	r12	;
    97bc:	b0 12 ec d1 	call	#53740		;#0xd1ec
    97c0:	0f 4c       	mov	r12,	r15	;
    97c2:	09 46       	mov	r6,	r9	;
    97c4:	0a 46       	mov	r6,	r10	;
    97c6:	0b 46       	mov	r6,	r11	;
    97c8:	0c 44       	mov	r4,	r12	;
    97ca:	0d 45       	mov	r5,	r13	;
    97cc:	0e 4f       	mov	r15,	r14	;
    97ce:	b0 12 36 cb 	call	#52022		;#0xcb36
    97d2:	2b 47       	mov	@r7,	r11	;
    97d4:	16 47 02 00 	mov	2(r7),	r6	;
    97d8:	18 47 04 00 	mov	4(r7),	r8	;
    97dc:	19 47 06 00 	mov	6(r7),	r9	;
    97e0:	0c 5b       	add	r11,	r12	;
    97e2:	1a 43       	mov	#1,	r10	;r3 As==01
    97e4:	0c 9b       	cmp	r11,	r12	;
    97e6:	01 28       	jnc	$+4      	;abs 0x97ea
    97e8:	0a 43       	clr	r10		;
    97ea:	0d 56       	add	r6,	r13	;
    97ec:	1b 43       	mov	#1,	r11	;r3 As==01
    97ee:	0d 96       	cmp	r6,	r13	;
    97f0:	01 28       	jnc	$+4      	;abs 0x97f4
    97f2:	0b 43       	clr	r11		;
    97f4:	0a 5d       	add	r13,	r10	;
    97f6:	16 43       	mov	#1,	r6	;r3 As==01
    97f8:	0a 9d       	cmp	r13,	r10	;
    97fa:	01 28       	jnc	$+4      	;abs 0x97fe
    97fc:	06 43       	clr	r6		;
    97fe:	0b d6       	bis	r6,	r11	;
    9800:	0e 58       	add	r8,	r14	;
    9802:	1d 43       	mov	#1,	r13	;r3 As==01
    9804:	0e 98       	cmp	r8,	r14	;
    9806:	01 28       	jnc	$+4      	;abs 0x980a
    9808:	0d 43       	clr	r13		;
    980a:	0b 5e       	add	r14,	r11	;
    980c:	18 43       	mov	#1,	r8	;r3 As==01
    980e:	0b 9e       	cmp	r14,	r11	;
    9810:	01 28       	jnc	$+4      	;abs 0x9814
    9812:	08 43       	clr	r8		;
    9814:	0d d8       	bis	r8,	r13	;
    9816:	0f 59       	add	r9,	r15	;
    9818:	87 4c 00 00 	mov	r12,	0(r7)	;
    981c:	87 4a 02 00 	mov	r10,	2(r7)	;
    9820:	87 4b 04 00 	mov	r11,	4(r7)	;
    9824:	0d 5f       	add	r15,	r13	;
    9826:	87 4d 06 00 	mov	r13,	6(r7)	;
}
    982a:	30 40 68 d1 	br	#0xd168		;

0000982e <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    982e:	0a 12       	push	r10		;
    9830:	09 12       	push	r9		;
    9832:	08 12       	push	r8		;
    9834:	21 83       	decd	r1		;
    9836:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9838:	18 4c 04 00 	mov	4(r12),	r8	;
    983c:	0c 48       	mov	r8,	r12	;
    983e:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9842:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9844:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9848:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    984c:	00 00 
    984e:	0c 48       	mov	r8,	r12	;
    9850:	0d 4f       	mov	r15,	r13	;
    9852:	0e 4f       	mov	r15,	r14	;
    9854:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    9856:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    985a:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    985c:	2c da       	bis	@r10,	r12	;
    985e:	21 53       	incd	r1		;
    9860:	30 40 70 d1 	br	#0xd170		;

00009864 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    9864:	0a 12       	push	r10		;
    9866:	09 12       	push	r9		;
    9868:	08 12       	push	r8		;
    986a:	07 12       	push	r7		;
    986c:	06 12       	push	r6		;
    986e:	05 12       	push	r5		;
    9870:	21 83       	decd	r1		;
    9872:	0a 4c       	mov	r12,	r10	;
    9874:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    9878:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    987c:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9880:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    9884:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    9888:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    988c:	00 00 
    988e:	0c 49       	mov	r9,	r12	;
    9890:	0d 45       	mov	r5,	r13	;
    9892:	0e 46       	mov	r6,	r14	;
    9894:	0f 47       	mov	r7,	r15	;
    9896:	88 12       	call	r8		;
    9898:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    989c:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    98a0:	00 00 
    98a2:	0c 49       	mov	r9,	r12	;
    98a4:	0d 45       	mov	r5,	r13	;
    98a6:	0e 46       	mov	r6,	r14	;
    98a8:	0f 47       	mov	r7,	r15	;
    98aa:	88 12       	call	r8		;
    98ac:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    98b0:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    98b4:	21 53       	incd	r1		;
    98b6:	30 40 6a d1 	br	#0xd16a		;

000098ba <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    98ba:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    98be:	04 00 
    y[1] = x[1];
    98c0:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    98c4:	02 00 
    y[0] = x[0];
    98c6:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    98ca:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    98ce:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    98d2:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    98d6:	30 41       	ret			

000098d8 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    98d8:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    98dc:	04 00 
    y[1] = x[1];
    98de:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    98e2:	02 00 
    y[0] = x[0];
    98e4:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    98e8:	30 41       	ret			

000098ea <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    98ea:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    98ee:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    98f2:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    98f6:	30 41       	ret			

000098f8 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    98f8:	0f 43       	clr	r15		;
    98fa:	0f 4e       	mov	r14,	r15	;
    98fc:	0f 5f       	rla	r15		;
    98fe:	0f 7f       	subc	r15,	r15	;
    9900:	3f e3       	inv	r15		;
    9902:	8c 5d 00 00 	add	r13,	0(r12)	;
    9906:	8c 6e 02 00 	addc	r14,	2(r12)	;
    990a:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    990e:	30 41       	ret			

00009910 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9910:	0c 93       	cmp	#0,	r12	;r3 As==00
    9912:	04 24       	jz	$+10     	;abs 0x991c
    {
        n--;
    9914:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9916:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9918:	0c 93       	cmp	#0,	r12	;r3 As==00
    991a:	fc 23       	jnz	$-6      	;abs 0x9914
    {
        n--;
        __no_operation();
    }
}
    991c:	30 41       	ret			

0000991e <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    991e:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9922:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9926:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    992a:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    992e:	30 41       	ret			

00009930 <mul48_32_16>:

#include <inttypes.h>
#include "emeter-toolkit.h"

int32_t mul48_32_16(int32_t x, uint16_t y)
{
    9930:	0a 12       	push	r10		;
    9932:	09 12       	push	r9		;
    9934:	08 12       	push	r8		;
    9936:	07 12       	push	r7		;
    9938:	21 83       	decd	r1		;
    993a:	09 4d       	mov	r13,	r9	;
    993c:	07 4e       	mov	r14,	r7	;
    int64_t z;
    
    z = (int64_t) x*(int64_t) y;
    993e:	08 4c       	mov	r12,	r8	;
    9940:	0c 4d       	mov	r13,	r12	;
    9942:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9946:	0f 43       	clr	r15		;
    9948:	0a 4c       	mov	r12,	r10	;
    994a:	0b 4c       	mov	r12,	r11	;
    994c:	0c 47       	mov	r7,	r12	;
    994e:	0d 4f       	mov	r15,	r13	;
    9950:	0e 4f       	mov	r15,	r14	;
    9952:	b0 12 36 cb 	call	#52022		;#0xcb36
    return z >> 16;
    9956:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    995a:	00 00 
    995c:	b0 12 90 cd 	call	#52624		;#0xcd90
}
    9960:	21 53       	incd	r1		;
    9962:	30 40 6e d1 	br	#0xd16e		;

00009966 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9966:	0a 12       	push	r10		;
    9968:	09 12       	push	r9		;
    996a:	08 12       	push	r8		;
    996c:	21 83       	decd	r1		;
    996e:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9970:	18 4c 04 00 	mov	4(r12),	r8	;
    9974:	0c 48       	mov	r8,	r12	;
    9976:	b0 12 ec d1 	call	#53740		;#0xd1ec
    997a:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    997c:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9980:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9984:	00 00 
    9986:	0c 48       	mov	r8,	r12	;
    9988:	0d 4f       	mov	r15,	r13	;
    998a:	0e 4f       	mov	r15,	r14	;
    998c:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    998e:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    9992:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    9994:	2c da       	bis	@r10,	r12	;
    9996:	21 53       	incd	r1		;
    9998:	30 40 70 d1 	br	#0xd170		;

0000999c <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    999c:	0a 12       	push	r10		;
    999e:	09 12       	push	r9		;
    99a0:	08 12       	push	r8		;
    99a2:	07 12       	push	r7		;
    99a4:	06 12       	push	r6		;
    99a6:	05 12       	push	r5		;
    99a8:	21 83       	decd	r1		;
    99aa:	0a 4c       	mov	r12,	r10	;
    99ac:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    99b0:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    99b4:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    99b8:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    99bc:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    99c0:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    99c4:	00 00 
    99c6:	0c 49       	mov	r9,	r12	;
    99c8:	0d 45       	mov	r5,	r13	;
    99ca:	0e 46       	mov	r6,	r14	;
    99cc:	0f 47       	mov	r7,	r15	;
    99ce:	88 12       	call	r8		;
    99d0:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    99d4:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    99d8:	00 00 
    99da:	0c 49       	mov	r9,	r12	;
    99dc:	0d 45       	mov	r5,	r13	;
    99de:	0e 46       	mov	r6,	r14	;
    99e0:	0f 47       	mov	r7,	r15	;
    99e2:	88 12       	call	r8		;
    99e4:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    99e8:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    99ec:	21 53       	incd	r1		;
    99ee:	30 40 6a d1 	br	#0xd16a		;

000099f2 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    99f2:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    99f6:	04 00 
    y[1] = x[1];
    99f8:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    99fc:	02 00 
    y[0] = x[0];
    99fe:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    9a02:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    9a06:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    9a0a:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9a0e:	30 41       	ret			

00009a10 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9a10:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9a14:	04 00 
    y[1] = x[1];
    9a16:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9a1a:	02 00 
    y[0] = x[0];
    9a1c:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9a20:	30 41       	ret			

00009a22 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    9a22:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    9a26:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9a2a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9a2e:	30 41       	ret			

00009a30 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9a30:	0f 43       	clr	r15		;
    9a32:	0f 4e       	mov	r14,	r15	;
    9a34:	0f 5f       	rla	r15		;
    9a36:	0f 7f       	subc	r15,	r15	;
    9a38:	3f e3       	inv	r15		;
    9a3a:	8c 5d 00 00 	add	r13,	0(r12)	;
    9a3e:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9a42:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9a46:	30 41       	ret			

00009a48 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9a48:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a4a:	04 24       	jz	$+10     	;abs 0x9a54
    {
        n--;
    9a4c:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9a4e:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9a50:	0c 93       	cmp	#0,	r12	;r3 As==00
    9a52:	fc 23       	jnz	$-6      	;abs 0x9a4c
    {
        n--;
        __no_operation();
    }
}
    9a54:	30 41       	ret			

00009a56 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    9a56:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9a5a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9a5e:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9a62:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9a66:	30 41       	ret			

00009a68 <mul48u_32_16>:

#include <inttypes.h>
#include "emeter-toolkit.h"

uint32_t mul48u_32_16(uint32_t x, uint16_t y)
{
    9a68:	0a 12       	push	r10		;
    9a6a:	09 12       	push	r9		;
    9a6c:	08 12       	push	r8		;
    9a6e:	21 83       	decd	r1		;
    uint64_t z;
    
    z = (int64_t) x*(int64_t) y;
    9a70:	09 4d       	mov	r13,	r9	;
    9a72:	0f 43       	clr	r15		;
    9a74:	08 4c       	mov	r12,	r8	;
    9a76:	0a 4f       	mov	r15,	r10	;
    9a78:	0b 4f       	mov	r15,	r11	;
    9a7a:	0c 4e       	mov	r14,	r12	;
    9a7c:	0d 4f       	mov	r15,	r13	;
    9a7e:	0e 4f       	mov	r15,	r14	;
    9a80:	b0 12 36 cb 	call	#52022		;#0xcb36
    return z >> 16;
    9a84:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9a88:	00 00 
    9a8a:	b0 12 98 cc 	call	#52376		;#0xcc98
}
    9a8e:	21 53       	incd	r1		;
    9a90:	30 40 70 d1 	br	#0xd170		;

00009a94 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9a94:	0a 12       	push	r10		;
    9a96:	09 12       	push	r9		;
    9a98:	08 12       	push	r8		;
    9a9a:	21 83       	decd	r1		;
    9a9c:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9a9e:	18 4c 04 00 	mov	4(r12),	r8	;
    9aa2:	0c 48       	mov	r8,	r12	;
    9aa4:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9aa8:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9aaa:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9aae:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9ab2:	00 00 
    9ab4:	0c 48       	mov	r8,	r12	;
    9ab6:	0d 4f       	mov	r15,	r13	;
    9ab8:	0e 4f       	mov	r15,	r14	;
    9aba:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    9abc:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    9ac0:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    9ac2:	2c da       	bis	@r10,	r12	;
    9ac4:	21 53       	incd	r1		;
    9ac6:	30 40 70 d1 	br	#0xd170		;

00009aca <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    9aca:	0a 12       	push	r10		;
    9acc:	09 12       	push	r9		;
    9ace:	08 12       	push	r8		;
    9ad0:	07 12       	push	r7		;
    9ad2:	06 12       	push	r6		;
    9ad4:	05 12       	push	r5		;
    9ad6:	21 83       	decd	r1		;
    9ad8:	0a 4c       	mov	r12,	r10	;
    9ada:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    9ade:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    9ae2:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9ae6:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    9aea:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    9aee:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9af2:	00 00 
    9af4:	0c 49       	mov	r9,	r12	;
    9af6:	0d 45       	mov	r5,	r13	;
    9af8:	0e 46       	mov	r6,	r14	;
    9afa:	0f 47       	mov	r7,	r15	;
    9afc:	88 12       	call	r8		;
    9afe:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    9b02:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9b06:	00 00 
    9b08:	0c 49       	mov	r9,	r12	;
    9b0a:	0d 45       	mov	r5,	r13	;
    9b0c:	0e 46       	mov	r6,	r14	;
    9b0e:	0f 47       	mov	r7,	r15	;
    9b10:	88 12       	call	r8		;
    9b12:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    9b16:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    9b1a:	21 53       	incd	r1		;
    9b1c:	30 40 6a d1 	br	#0xd16a		;

00009b20 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    9b20:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9b24:	04 00 
    y[1] = x[1];
    9b26:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9b2a:	02 00 
    y[0] = x[0];
    9b2c:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    9b30:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    9b34:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    9b38:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9b3c:	30 41       	ret			

00009b3e <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9b3e:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9b42:	04 00 
    y[1] = x[1];
    9b44:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9b48:	02 00 
    y[0] = x[0];
    9b4a:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9b4e:	30 41       	ret			

00009b50 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    9b50:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    9b54:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9b58:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9b5c:	30 41       	ret			

00009b5e <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9b5e:	0f 43       	clr	r15		;
    9b60:	0f 4e       	mov	r14,	r15	;
    9b62:	0f 5f       	rla	r15		;
    9b64:	0f 7f       	subc	r15,	r15	;
    9b66:	3f e3       	inv	r15		;
    9b68:	8c 5d 00 00 	add	r13,	0(r12)	;
    9b6c:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9b70:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9b74:	30 41       	ret			

00009b76 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9b76:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b78:	04 24       	jz	$+10     	;abs 0x9b82
    {
        n--;
    9b7a:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9b7c:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9b7e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9b80:	fc 23       	jnz	$-6      	;abs 0x9b7a
    {
        n--;
        __no_operation();
    }
}
    9b82:	30 41       	ret			

00009b84 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    9b84:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9b88:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9b8c:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9b90:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9b94:	30 41       	ret			

00009b96 <q1_15_mul>:
#else
    z = (int32_t) x*y;
    x1 = (z >> 15);
#endif
    return x1;
}
    9b96:	02 12       	push	r2		;
    9b98:	32 c2       	dint			
    9b9a:	82 4c 32 01 	mov	r12,	&0x0132	;
    9b9e:	82 4d 38 01 	mov	r13,	&0x0138	;
    9ba2:	1f 42 3c 01 	mov	&0x013c,r15	;0x013c
    9ba6:	1e 42 3a 01 	mov	&0x013a,r14	;0x013a
    9baa:	32 41       	pop	r2		;
    9bac:	0e 5e       	rla	r14		;
    9bae:	0f 6f       	rlc	r15		;
    9bb0:	0c 4f       	mov	r15,	r12	;
    9bb2:	30 41       	ret			

00009bb4 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9bb4:	0a 12       	push	r10		;
    9bb6:	09 12       	push	r9		;
    9bb8:	08 12       	push	r8		;
    9bba:	21 83       	decd	r1		;
    9bbc:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9bbe:	18 4c 04 00 	mov	4(r12),	r8	;
    9bc2:	0c 48       	mov	r8,	r12	;
    9bc4:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9bc8:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9bca:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9bce:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9bd2:	00 00 
    9bd4:	0c 48       	mov	r8,	r12	;
    9bd6:	0d 4f       	mov	r15,	r13	;
    9bd8:	0e 4f       	mov	r15,	r14	;
    9bda:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    9bdc:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    9be0:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    9be2:	2c da       	bis	@r10,	r12	;
    9be4:	21 53       	incd	r1		;
    9be6:	30 40 70 d1 	br	#0xd170		;

00009bea <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    9bea:	0a 12       	push	r10		;
    9bec:	09 12       	push	r9		;
    9bee:	08 12       	push	r8		;
    9bf0:	07 12       	push	r7		;
    9bf2:	06 12       	push	r6		;
    9bf4:	05 12       	push	r5		;
    9bf6:	21 83       	decd	r1		;
    9bf8:	0a 4c       	mov	r12,	r10	;
    9bfa:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    9bfe:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    9c02:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9c06:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    9c0a:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    9c0e:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9c12:	00 00 
    9c14:	0c 49       	mov	r9,	r12	;
    9c16:	0d 45       	mov	r5,	r13	;
    9c18:	0e 46       	mov	r6,	r14	;
    9c1a:	0f 47       	mov	r7,	r15	;
    9c1c:	88 12       	call	r8		;
    9c1e:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    9c22:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9c26:	00 00 
    9c28:	0c 49       	mov	r9,	r12	;
    9c2a:	0d 45       	mov	r5,	r13	;
    9c2c:	0e 46       	mov	r6,	r14	;
    9c2e:	0f 47       	mov	r7,	r15	;
    9c30:	88 12       	call	r8		;
    9c32:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    9c36:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    9c3a:	21 53       	incd	r1		;
    9c3c:	30 40 6a d1 	br	#0xd16a		;

00009c40 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    9c40:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9c44:	04 00 
    y[1] = x[1];
    9c46:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9c4a:	02 00 
    y[0] = x[0];
    9c4c:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    9c50:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    9c54:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    9c58:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9c5c:	30 41       	ret			

00009c5e <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9c5e:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9c62:	04 00 
    y[1] = x[1];
    9c64:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9c68:	02 00 
    y[0] = x[0];
    9c6a:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9c6e:	30 41       	ret			

00009c70 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    9c70:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    9c74:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9c78:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9c7c:	30 41       	ret			

00009c7e <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9c7e:	0f 43       	clr	r15		;
    9c80:	0f 4e       	mov	r14,	r15	;
    9c82:	0f 5f       	rla	r15		;
    9c84:	0f 7f       	subc	r15,	r15	;
    9c86:	3f e3       	inv	r15		;
    9c88:	8c 5d 00 00 	add	r13,	0(r12)	;
    9c8c:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9c90:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9c94:	30 41       	ret			

00009c96 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9c96:	0c 93       	cmp	#0,	r12	;r3 As==00
    9c98:	04 24       	jz	$+10     	;abs 0x9ca2
    {
        n--;
    9c9a:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9c9c:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9c9e:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ca0:	fc 23       	jnz	$-6      	;abs 0x9c9a
    {
        n--;
        __no_operation();
    }
}
    9ca2:	30 41       	ret			

00009ca4 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    9ca4:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9ca8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9cac:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9cb0:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9cb4:	30 41       	ret			

00009cb6 <sqac48_16>:

#include <inttypes.h>
#include "emeter-toolkit.h"

void sqac48_16(register int16_t z[3], register int16_t x)
{
    9cb6:	0a 12       	push	r10		;
    9cb8:	09 12       	push	r9		;
    9cba:	08 12       	push	r8		;
    9cbc:	07 12       	push	r7		;
    9cbe:	06 12       	push	r6		;
    9cc0:	05 12       	push	r5		;
    9cc2:	04 12       	push	r4		;
    9cc4:	21 82       	sub	#4,	r1	;r2 As==10
    9cc6:	0a 4c       	mov	r12,	r10	;
    9cc8:	09 4d       	mov	r13,	r9	;
    int64_t tmp;

    tmp = z[2];
    9cca:	17 4c 04 00 	mov	4(r12),	r7	;
    9cce:	0c 47       	mov	r7,	r12	;
    9cd0:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9cd4:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    9cd6:	38 40 14 cd 	mov	#52500,	r8	;#0xcd14
    9cda:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9cde:	00 00 
    9ce0:	0c 47       	mov	r7,	r12	;
    9ce2:	0d 4f       	mov	r15,	r13	;
    9ce4:	0e 4f       	mov	r15,	r14	;
    9ce6:	88 12       	call	r8		;
    9ce8:	04 4c       	mov	r12,	r4	;
    9cea:	05 4d       	mov	r13,	r5	;
    9cec:	06 4e       	mov	r14,	r6	;
    9cee:	81 4f 02 00 	mov	r15,	2(r1)	;
    tmp |= z[1];
    9cf2:	17 4a 02 00 	mov	2(r10),	r7	;
    9cf6:	0c 47       	mov	r7,	r12	;
    9cf8:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9cfc:	0f 4c       	mov	r12,	r15	;
    tmp = tmp << 16;
    9cfe:	0c 44       	mov	r4,	r12	;
    9d00:	0c d7       	bis	r7,	r12	;
    9d02:	0d 45       	mov	r5,	r13	;
    9d04:	0d df       	bis	r15,	r13	;
    9d06:	0e 46       	mov	r6,	r14	;
    9d08:	0e df       	bis	r15,	r14	;
    9d0a:	1f d1 02 00 	bis	2(r1),	r15	;
    9d0e:	88 12       	call	r8		;
    9d10:	04 4c       	mov	r12,	r4	;
    9d12:	06 4d       	mov	r13,	r6	;
    9d14:	07 4e       	mov	r14,	r7	;
    9d16:	05 4f       	mov	r15,	r5	;
    tmp |= z[0];
    9d18:	28 4a       	mov	@r10,	r8	;
    9d1a:	0c 48       	mov	r8,	r12	;
    9d1c:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9d20:	08 d4       	bis	r4,	r8	;
    9d22:	06 dc       	bis	r12,	r6	;
    9d24:	07 dc       	bis	r12,	r7	;
    9d26:	05 dc       	bis	r12,	r5	;
    9d28:	81 45 02 00 	mov	r5,	2(r1)	;
    tmp += (int32_t) x*(int32_t) x;
    9d2c:	0e 49       	mov	r9,	r14	;
    9d2e:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    9d32:	0f 7f       	subc	r15,	r15	;
    9d34:	3f e3       	inv	r15		;
    9d36:	0c 4e       	mov	r14,	r12	;
    9d38:	0d 4f       	mov	r15,	r13	;
    9d3a:	b0 12 58 d3 	call	#54104		;#0xd358
    9d3e:	05 4d       	mov	r13,	r5	;
    9d40:	09 4c       	mov	r12,	r9	;
    9d42:	04 4d       	mov	r13,	r4	;
    9d44:	0c 4d       	mov	r13,	r12	;
    9d46:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9d4a:	08 59       	add	r9,	r8	;
    9d4c:	1d 43       	mov	#1,	r13	;r3 As==01
    9d4e:	08 99       	cmp	r9,	r8	;
    9d50:	01 28       	jnc	$+4      	;abs 0x9d54
    9d52:	0d 43       	clr	r13		;
    9d54:	06 55       	add	r5,	r6	;
    9d56:	19 43       	mov	#1,	r9	;r3 As==01
    9d58:	06 94       	cmp	r4,	r6	;
    9d5a:	01 28       	jnc	$+4      	;abs 0x9d5e
    9d5c:	09 43       	clr	r9		;
    9d5e:	04 4d       	mov	r13,	r4	;
    9d60:	04 56       	add	r6,	r4	;
    9d62:	1d 43       	mov	#1,	r13	;r3 As==01
    9d64:	04 96       	cmp	r6,	r4	;
    9d66:	01 28       	jnc	$+4      	;abs 0x9d6a
    9d68:	0d 43       	clr	r13		;
    9d6a:	09 dd       	bis	r13,	r9	;
    9d6c:	0d 4c       	mov	r12,	r13	;
    9d6e:	0d 57       	add	r7,	r13	;
    9d70:	1e 43       	mov	#1,	r14	;r3 As==01
    9d72:	0d 9c       	cmp	r12,	r13	;
    9d74:	01 28       	jnc	$+4      	;abs 0x9d78
    9d76:	0e 43       	clr	r14		;
    9d78:	09 5d       	add	r13,	r9	;
    9d7a:	1f 43       	mov	#1,	r15	;r3 As==01
    9d7c:	09 9d       	cmp	r13,	r9	;
    9d7e:	01 28       	jnc	$+4      	;abs 0x9d82
    9d80:	0f 43       	clr	r15		;
    9d82:	0e df       	bis	r15,	r14	;
    9d84:	1c 51 02 00 	add	2(r1),	r12	;
    9d88:	07 4e       	mov	r14,	r7	;
    9d8a:	07 5c       	add	r12,	r7	;
    z[2] = (tmp >> 32) & 0xFFFF;
    9d8c:	36 40 90 cd 	mov	#52624,	r6	;#0xcd90
    9d90:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9d94:	00 00 
    9d96:	0c 48       	mov	r8,	r12	;
    9d98:	0d 44       	mov	r4,	r13	;
    9d9a:	0e 49       	mov	r9,	r14	;
    9d9c:	0f 47       	mov	r7,	r15	;
    9d9e:	86 12       	call	r6		;
    9da0:	8a 4c 04 00 	mov	r12,	4(r10)	;
    z[1] = (tmp >> 16) & 0xFFFF;
    9da4:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9da8:	00 00 
    9daa:	0c 48       	mov	r8,	r12	;
    9dac:	0d 44       	mov	r4,	r13	;
    9dae:	0e 49       	mov	r9,	r14	;
    9db0:	0f 47       	mov	r7,	r15	;
    9db2:	86 12       	call	r6		;
    9db4:	8a 4c 02 00 	mov	r12,	2(r10)	;
    z[0] = tmp & 0xFFFF;
    9db8:	8a 48 00 00 	mov	r8,	0(r10)	;
}
    9dbc:	21 52       	add	#4,	r1	;r2 As==10
    9dbe:	30 40 68 d1 	br	#0xd168		;

00009dc2 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    9dc2:	0a 12       	push	r10		;
    9dc4:	09 12       	push	r9		;
    9dc6:	08 12       	push	r8		;
    9dc8:	21 83       	decd	r1		;
    9dca:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    9dcc:	18 4c 04 00 	mov	4(r12),	r8	;
    9dd0:	0c 48       	mov	r8,	r12	;
    9dd2:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9dd6:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    9dd8:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    9ddc:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9de0:	00 00 
    9de2:	0c 48       	mov	r8,	r12	;
    9de4:	0d 4f       	mov	r15,	r13	;
    9de6:	0e 4f       	mov	r15,	r14	;
    9de8:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    9dea:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    9dee:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    9df0:	2c da       	bis	@r10,	r12	;
    9df2:	21 53       	incd	r1		;
    9df4:	30 40 70 d1 	br	#0xd170		;

00009df8 <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    9df8:	0a 12       	push	r10		;
    9dfa:	09 12       	push	r9		;
    9dfc:	08 12       	push	r8		;
    9dfe:	07 12       	push	r7		;
    9e00:	06 12       	push	r6		;
    9e02:	05 12       	push	r5		;
    9e04:	21 83       	decd	r1		;
    9e06:	0a 4c       	mov	r12,	r10	;
    9e08:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    9e0c:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    9e10:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    9e14:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    9e18:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    9e1c:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    9e20:	00 00 
    9e22:	0c 49       	mov	r9,	r12	;
    9e24:	0d 45       	mov	r5,	r13	;
    9e26:	0e 46       	mov	r6,	r14	;
    9e28:	0f 47       	mov	r7,	r15	;
    9e2a:	88 12       	call	r8		;
    9e2c:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    9e30:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    9e34:	00 00 
    9e36:	0c 49       	mov	r9,	r12	;
    9e38:	0d 45       	mov	r5,	r13	;
    9e3a:	0e 46       	mov	r6,	r14	;
    9e3c:	0f 47       	mov	r7,	r15	;
    9e3e:	88 12       	call	r8		;
    9e40:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    9e44:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    9e48:	21 53       	incd	r1		;
    9e4a:	30 40 6a d1 	br	#0xd16a		;

00009e4e <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    9e4e:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9e52:	04 00 
    y[1] = x[1];
    9e54:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9e58:	02 00 
    y[0] = x[0];
    9e5a:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    9e5e:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    9e62:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    9e66:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    9e6a:	30 41       	ret			

00009e6c <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    9e6c:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    9e70:	04 00 
    y[1] = x[1];
    9e72:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    9e76:	02 00 
    y[0] = x[0];
    9e78:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    9e7c:	30 41       	ret			

00009e7e <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    9e7e:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    9e82:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    9e86:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    9e8a:	30 41       	ret			

00009e8c <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    9e8c:	0f 43       	clr	r15		;
    9e8e:	0f 4e       	mov	r14,	r15	;
    9e90:	0f 5f       	rla	r15		;
    9e92:	0f 7f       	subc	r15,	r15	;
    9e94:	3f e3       	inv	r15		;
    9e96:	8c 5d 00 00 	add	r13,	0(r12)	;
    9e9a:	8c 6e 02 00 	addc	r14,	2(r12)	;
    9e9e:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    9ea2:	30 41       	ret			

00009ea4 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9ea4:	0c 93       	cmp	#0,	r12	;r3 As==00
    9ea6:	04 24       	jz	$+10     	;abs 0x9eb0
    {
        n--;
    9ea8:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    9eaa:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    9eac:	0c 93       	cmp	#0,	r12	;r3 As==00
    9eae:	fc 23       	jnz	$-6      	;abs 0x9ea8
    {
        n--;
        __no_operation();
    }
}
    9eb0:	30 41       	ret			

00009eb2 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    9eb2:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    9eb6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9eba:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    9ebe:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    9ec2:	30 41       	ret			

00009ec4 <sqac64_24>:

#include <inttypes.h>
#include "emeter-toolkit.h"

void sqac64_24(int64_t *z, int32_t x)
{
    9ec4:	0a 12       	push	r10		;
    9ec6:	09 12       	push	r9		;
    9ec8:	08 12       	push	r8		;
    9eca:	07 12       	push	r7		;
    9ecc:	06 12       	push	r6		;
    9ece:	05 12       	push	r5		;
    9ed0:	07 4c       	mov	r12,	r7	;
    9ed2:	06 4e       	mov	r14,	r6	;
    *z += (int64_t) x*(int64_t) x;
    9ed4:	05 4d       	mov	r13,	r5	;
    9ed6:	0c 4e       	mov	r14,	r12	;
    9ed8:	b0 12 ec d1 	call	#53740		;#0xd1ec
    9edc:	0f 4c       	mov	r12,	r15	;
    9ede:	08 45       	mov	r5,	r8	;
    9ee0:	09 46       	mov	r6,	r9	;
    9ee2:	0a 4c       	mov	r12,	r10	;
    9ee4:	0b 4c       	mov	r12,	r11	;
    9ee6:	0c 45       	mov	r5,	r12	;
    9ee8:	0d 46       	mov	r6,	r13	;
    9eea:	0e 4f       	mov	r15,	r14	;
    9eec:	b0 12 36 cb 	call	#52022		;#0xcb36
    9ef0:	25 47       	mov	@r7,	r5	;
    9ef2:	16 47 02 00 	mov	2(r7),	r6	;
    9ef6:	18 47 04 00 	mov	4(r7),	r8	;
    9efa:	19 47 06 00 	mov	6(r7),	r9	;
    9efe:	0c 55       	add	r5,	r12	;
    9f00:	1a 43       	mov	#1,	r10	;r3 As==01
    9f02:	0c 95       	cmp	r5,	r12	;
    9f04:	01 28       	jnc	$+4      	;abs 0x9f08
    9f06:	0a 43       	clr	r10		;
    9f08:	0d 56       	add	r6,	r13	;
    9f0a:	1b 43       	mov	#1,	r11	;r3 As==01
    9f0c:	0d 96       	cmp	r6,	r13	;
    9f0e:	01 28       	jnc	$+4      	;abs 0x9f12
    9f10:	0b 43       	clr	r11		;
    9f12:	0a 5d       	add	r13,	r10	;
    9f14:	16 43       	mov	#1,	r6	;r3 As==01
    9f16:	0a 9d       	cmp	r13,	r10	;
    9f18:	01 28       	jnc	$+4      	;abs 0x9f1c
    9f1a:	06 43       	clr	r6		;
    9f1c:	0b d6       	bis	r6,	r11	;
    9f1e:	0e 58       	add	r8,	r14	;
    9f20:	1d 43       	mov	#1,	r13	;r3 As==01
    9f22:	0e 98       	cmp	r8,	r14	;
    9f24:	01 28       	jnc	$+4      	;abs 0x9f28
    9f26:	0d 43       	clr	r13		;
    9f28:	0b 5e       	add	r14,	r11	;
    9f2a:	18 43       	mov	#1,	r8	;r3 As==01
    9f2c:	0b 9e       	cmp	r14,	r11	;
    9f2e:	01 28       	jnc	$+4      	;abs 0x9f32
    9f30:	08 43       	clr	r8		;
    9f32:	0d d8       	bis	r8,	r13	;
    9f34:	0f 59       	add	r9,	r15	;
    9f36:	87 4c 00 00 	mov	r12,	0(r7)	;
    9f3a:	87 4a 02 00 	mov	r10,	2(r7)	;
    9f3e:	87 4b 04 00 	mov	r11,	4(r7)	;
    9f42:	0d 5f       	add	r15,	r13	;
    9f44:	87 4d 06 00 	mov	r13,	6(r7)	;
}
    9f48:	30 40 6a d1 	br	#0xd16a		;

00009f4c <CS_setupDCO>:
// DCO Frequency used for clock signal frequency calculations
//
//*****************************************************************************
#define CS_DCO_FREQ                                                    16384000

void CS_setupDCO(uint8_t mode) {
    9f4c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    CSCTL0 &= ~(DCOR | DCOBYP);
    9f50:	f2 f0 fc ff 	and.b	#65532,	&0x0050	;#0xfffc
    9f54:	50 00 
    CSCTL0 |= mode;
    9f56:	c2 dc 50 00 	bis.b	r12,	&0x0050	;

    // Set DCO calibration using TLV
    if(mode == CS_INTERNAL_RESISTOR)
    9f5a:	0c 93       	cmp	#0,	r12	;r3 As==00
    9f5c:	08 20       	jnz	$+18     	;abs 0x9f6e
    {
        CSIRFCAL = HWREG8(TLV_START + TLV_CAL_CSIRFCAL);
    9f5e:	d2 42 d4 13 	mov.b	&0x13d4,&0x0052	;0x13d4
    9f62:	52 00 
        CSIRTCAL = HWREG8(TLV_START + TLV_CAL_CSIRTCAL);
    9f64:	d2 42 d5 13 	mov.b	&0x13d5,&0x0053	;0x13d5
    9f68:	53 00 
    9f6a:	30 40 7e 9f 	br	#0x9f7e		;
    }
    else if(mode == CS_EXTERNAL_RESISTOR)
    9f6e:	1c 93       	cmp	#1,	r12	;r3 As==01
    9f70:	06 20       	jnz	$+14     	;abs 0x9f7e
    {
        CSERFCAL = HWREG8(TLV_START + TLV_CAL_CSERFCAL);
    9f72:	d2 42 d6 13 	mov.b	&0x13d6,&0x0054	;0x13d6
    9f76:	54 00 
        CSERTCAL = HWREG8(TLV_START + TLV_CAL_CSERTCAL);
    9f78:	d2 42 d7 13 	mov.b	&0x13d7,&0x0055	;0x13d7
    9f7c:	55 00 
    }
}
    9f7e:	30 41       	ret			

00009f80 <CS_initClockSignal>:

void CS_initClockSignal(uint8_t clockSource,
                        uint8_t clockSourceDivider) {
    9f80:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint8_t clearBits = DIVM_7;

    if(clockSource == CS_SMCLK)
    9f84:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    9f86:	0a 20       	jnz	$+22     	;abs 0x9f9c
    {
        clockSourceDivider = clockSourceDivider << 4;
    9f88:	4d 5d       	rla.b	r13		;
    9f8a:	4d 5d       	rla.b	r13		;
    9f8c:	4d 5d       	rla.b	r13		;
    9f8e:	4d 5d       	rla.b	r13		;
    9f90:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
        clearBits = clearBits << 4;
    9f94:	3c 40 70 00 	mov	#112,	r12	;#0x0070
    9f98:	30 40 a0 9f 	br	#0x9fa0		;
    }
}

void CS_initClockSignal(uint8_t clockSource,
                        uint8_t clockSourceDivider) {
    uint8_t clearBits = DIVM_7;
    9f9c:	3c 40 07 00 	mov	#7,	r12	;
    {
        clockSourceDivider = clockSourceDivider << 4;
        clearBits = clearBits << 4;
    }

    CSCTL1 = (CSCTL1 & ~(clearBits)) | clockSourceDivider;
    9fa0:	5e 42 51 00 	mov.b	&0x0051,r14	;0x0051
    9fa4:	4e cc       	bic.b	r12,	r14	;
    9fa6:	4c 4e       	mov.b	r14,	r12	;
    9fa8:	4c dd       	bis.b	r13,	r12	;
    9faa:	c2 4c 51 00 	mov.b	r12,	&0x0051	;
}
    9fae:	30 41       	ret			

00009fb0 <CS_getACLK>:

uint32_t CS_getACLK(void) {
    return(32000);
}
    9fb0:	3c 40 00 7d 	mov	#32000,	r12	;#0x7d00
    9fb4:	0d 43       	clr	r13		;
    9fb6:	30 41       	ret			

00009fb8 <CS_getSMCLK>:

uint32_t CS_getSMCLK(void) {
    uint8_t divider = (CSCTL1 & 0x70) >> 4;
    9fb8:	5c 42 51 00 	mov.b	&0x0051,r12	;0x0051
    9fbc:	7c f0 70 00 	and.b	#112,	r12	;#0x0070
    9fc0:	3c f0 70 00 	and	#112,	r12	;#0x0070
    9fc4:	b0 12 02 d2 	call	#53762		;#0xd202
    return(CS_DCO_FREQ >> divider);
    9fc8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    9fcc:	0e 4c       	mov	r12,	r14	;
    9fce:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    9fd2:	0f 7f       	subc	r15,	r15	;
    9fd4:	3f e3       	inv	r15		;
    9fd6:	0c 43       	clr	r12		;
    9fd8:	3d 40 fa 00 	mov	#250,	r13	;#0x00fa
    9fdc:	b0 12 5a d2 	call	#53850		;#0xd25a
}
    9fe0:	30 41       	ret			

00009fe2 <CS_getMCLK>:

uint32_t CS_getMCLK(void) {
    uint8_t divider = (CSCTL1 & 0x07);
    9fe2:	5e 42 51 00 	mov.b	&0x0051,r14	;0x0051
    9fe6:	7e f0 07 00 	and.b	#7,	r14	;
    return(CS_DCO_FREQ >> divider);
    9fea:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    9fee:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    9ff2:	0f 7f       	subc	r15,	r15	;
    9ff4:	3f e3       	inv	r15		;
    9ff6:	0c 43       	clr	r12		;
    9ff8:	3d 40 fa 00 	mov	#250,	r13	;#0x00fa
    9ffc:	b0 12 5a d2 	call	#53850		;#0xd25a
}
    a000:	30 41       	ret			

0000a002 <CS_getFaultFlagStatus>:

uint8_t CS_getFaultFlagStatus(uint8_t mask) {
    return (CSCTL0 & mask);
}
    a002:	5c f2 50 00 	and.b	&0x0050,r12	;0x0050
    a006:	30 41       	ret			

0000a008 <EUSCI_A_SPI_initMaster>:

#include <assert.h>

void EUSCI_A_SPI_initMaster(uint16_t baseAddress,
                            EUSCI_A_SPI_initMasterParam *param)
{
    a008:	0a 12       	push	r10		;
    a00a:	09 12       	push	r9		;
    a00c:	08 12       	push	r8		;
    a00e:	0a 4c       	mov	r12,	r10	;
    a010:	09 4d       	mov	r13,	r9	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a012:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Reset OFS_UCAxCTLW0 values
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCCKPH + UCCKPL + UC7BIT + UCMSB +
    a016:	bc f0 ff 00 	and	#255,	0(r12)	;#0x00ff
    a01a:	00 00 
                                              UCMST + UCMODE_3 + UCSYNC);

    //Reset OFS_UCAxCTLW0 values
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSSEL_3);
    a01c:	bc f0 3f ff 	and	#65343,	0(r12)	;#0xff3f
    a020:	00 00 

    //Select Clock
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->selectClockSource;
    a022:	6c 4d       	mov.b	@r13,	r12	;
    a024:	8a dc 00 00 	bis	r12,	0(r10)	;

    HWREG16(baseAddress + OFS_UCAxBRW) =
    a028:	08 4a       	mov	r10,	r8	;
    a02a:	38 50 06 00 	add	#6,	r8	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);
    a02e:	1c 4d 02 00 	mov	2(r13),	r12	;
    a032:	1d 4d 04 00 	mov	4(r13),	r13	;
    a036:	1e 49 06 00 	mov	6(r9),	r14	;
    a03a:	1f 49 08 00 	mov	8(r9),	r15	;
    a03e:	b0 12 86 d0 	call	#53382		;#0xd086
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSSEL_3);

    //Select Clock
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->selectClockSource;

    HWREG16(baseAddress + OFS_UCAxBRW) =
    a042:	88 4c 00 00 	mov	r12,	0(r8)	;
     * UCMST = Master mode
     * UCSYNC = Synchronous mode
     * UCMODE_0 = 3-pin SPI
     */
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (
        param->msbFirst +
    a046:	1c 49 0a 00 	mov	10(r9),	r12	;0x0000a
    a04a:	1c 59 0c 00 	add	12(r9),	r12	;0x0000c
    a04e:	3c 50 00 09 	add	#2304,	r12	;#0x0900
    a052:	1c 59 0e 00 	add	14(r9),	r12	;0x0000e
        param->clockPhase +
        param->clockPolarity +
        UCMST +
        UCSYNC +
    a056:	1c 59 10 00 	add	16(r9),	r12	;0x00010
     * Clock phase select, polarity, msb
     * UCMST = Master mode
     * UCSYNC = Synchronous mode
     * UCMODE_0 = 3-pin SPI
     */
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (
    a05a:	8a dc 00 00 	bis	r12,	0(r10)	;
        UCMST +
        UCSYNC +
        param->spiMode
        );
    //No modulation
    HWREG16(baseAddress + OFS_UCAxMCTLW) = 0;
    a05e:	8a 43 08 00 	mov	#0,	8(r10)	;r3 As==00
}
    a062:	30 40 70 d1 	br	#0xd170		;

0000a066 <EUSCI_A_SPI_select4PinFunctionality>:

void EUSCI_A_SPI_select4PinFunctionality(uint16_t baseAddress,
                                         uint8_t select4PinFunctionality)
{
    a066:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCSTEM;
    a06a:	ac c3 00 00 	bic	#2,	0(r12)	;r3 As==10
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= select4PinFunctionality;
    a06e:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    a072:	30 41       	ret			

0000a074 <EUSCI_A_SPI_changeMasterClock>:

void EUSCI_A_SPI_changeMasterClock(uint16_t baseAddress,
                                   EUSCI_A_SPI_changeMasterClockParam *param)
{
    a074:	0a 12       	push	r10		;
    a076:	09 12       	push	r9		;
    a078:	0a 4c       	mov	r12,	r10	;
    a07a:	0e 4d       	mov	r13,	r14	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a07c:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    HWREG16(baseAddress + OFS_UCAxBRW) =
    a080:	09 4c       	mov	r12,	r9	;
    a082:	39 50 06 00 	add	#6,	r9	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);
    a086:	2c 4d       	mov	@r13,	r12	;
    a088:	1d 4d 02 00 	mov	2(r13),	r13	;
    a08c:	1f 4e 06 00 	mov	6(r14),	r15	;
    a090:	1e 4e 04 00 	mov	4(r14),	r14	;
    a094:	b0 12 86 d0 	call	#53382		;#0xd086
                                   EUSCI_A_SPI_changeMasterClockParam *param)
{
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;

    HWREG16(baseAddress + OFS_UCAxBRW) =
    a098:	89 4c 00 00 	mov	r12,	0(r9)	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);

    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSWRST);
    a09c:	9a c3 00 00 	bic	#1,	0(r10)	;r3 As==01
}
    a0a0:	30 40 72 d1 	br	#0xd172		;

0000a0a4 <EUSCI_A_SPI_initSlave>:

void EUSCI_A_SPI_initSlave(uint16_t baseAddress,
                           EUSCI_A_SPI_initSlaveParam *param)
{
    //Disable USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a0a4:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Reset OFS_UCAxCTLW0 register
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCMSB +
    a0a8:	bc f0 ff 01 	and	#511,	0(r12)	;#0x01ff
    a0ac:	00 00 
                                              UCCKPH +
                                              UCMODE_3
                                              );

    //Clock polarity, phase select, msbFirst, SYNC, Mode0
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (param->clockPhase +
    a0ae:	1e 4d 02 00 	mov	2(r13),	r14	;
    a0b2:	1e 5d 04 00 	add	4(r13),	r14	;
    a0b6:	3e 50 00 01 	add	#256,	r14	;#0x0100
    a0ba:	2e 5d       	add	@r13,	r14	;
                                             param->clockPolarity +
                                             param->msbFirst +
                                             UCSYNC +
    a0bc:	1e 5d 06 00 	add	6(r13),	r14	;
                                              UCCKPH +
                                              UCMODE_3
                                              );

    //Clock polarity, phase select, msbFirst, SYNC, Mode0
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (param->clockPhase +
    a0c0:	8c de 00 00 	bis	r14,	0(r12)	;
                                             param->clockPolarity +
                                             param->msbFirst +
                                             UCSYNC +
                                             param->spiMode
                                             );
}
    a0c4:	30 41       	ret			

0000a0c6 <EUSCI_A_SPI_changeClockPhasePolarity>:
void EUSCI_A_SPI_changeClockPhasePolarity(uint16_t baseAddress,
                                          uint16_t clockPhase,
                                          uint16_t clockPolarity)
{
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a0c6:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCCKPH + UCCKPL);
    a0ca:	bc f0 ff 3f 	and	#16383,	0(r12)	;#0x3fff
    a0ce:	00 00 

    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (
        clockPhase +
    a0d0:	0d 5e       	add	r14,	r13	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;

    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCCKPH + UCCKPL);

    HWREG16(baseAddress + OFS_UCAxCTLW0) |= (
    a0d2:	8c dd 00 00 	bis	r13,	0(r12)	;
        clockPhase +
        clockPolarity
        );

    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSWRST);
    a0d6:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a0da:	30 41       	ret			

0000a0dc <EUSCI_A_SPI_transmitData>:

void EUSCI_A_SPI_transmitData(uint16_t baseAddress,
                              uint8_t transmitData)
{
    HWREG16(baseAddress + OFS_UCAxTXBUF) = transmitData;
    a0dc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a0e0:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a0e4:	30 41       	ret			

0000a0e6 <EUSCI_A_SPI_receiveData>:

uint8_t EUSCI_A_SPI_receiveData(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_UCAxRXBUF));
    a0e6:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a0ea:	30 41       	ret			

0000a0ec <EUSCI_A_SPI_enableInterrupt>:

void EUSCI_A_SPI_enableInterrupt(uint16_t baseAddress,
                                 uint8_t mask)
{
    a0ec:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCAxIE) |= mask;
    a0f0:	8c dd 1a 00 	bis	r13,	26(r12)	; 0x001a
}
    a0f4:	30 41       	ret			

0000a0f6 <EUSCI_A_SPI_disableInterrupt>:

void EUSCI_A_SPI_disableInterrupt(uint16_t baseAddress,
                                  uint8_t mask)
{
    a0f6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCAxIE) &= ~mask;
    a0fa:	8c cd 1a 00 	bic	r13,	26(r12)	; 0x001a
}
    a0fe:	30 41       	ret			

0000a100 <EUSCI_A_SPI_getInterruptStatus>:

uint8_t EUSCI_A_SPI_getInterruptStatus(uint16_t baseAddress,
                                       uint8_t mask)
{
    return (HWREG16(baseAddress + OFS_UCAxIFG) & mask);
    a100:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
}
    a104:	4c fd       	and.b	r13,	r12	;
    a106:	30 41       	ret			

0000a108 <EUSCI_A_SPI_clearInterrupt>:

void EUSCI_A_SPI_clearInterrupt(uint16_t baseAddress,
                                uint8_t mask)
{
    a108:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCAxIFG) &= ~mask;
    a10c:	8c cd 1c 00 	bic	r13,	28(r12)	; 0x001c
}
    a110:	30 41       	ret			

0000a112 <EUSCI_A_SPI_enable>:

void EUSCI_A_SPI_enable(uint16_t baseAddress)
{
    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSWRST);
    a112:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a116:	30 41       	ret			

0000a118 <EUSCI_A_SPI_disable>:

void EUSCI_A_SPI_disable(uint16_t baseAddress)
{
    //Set the UCSWRST bit to disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a118:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
}
    a11c:	30 41       	ret			

0000a11e <EUSCI_A_SPI_getReceiveBufferAddress>:

uint32_t EUSCI_A_SPI_getReceiveBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCAxRXBUF);
}
    a11e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    a122:	0d 43       	clr	r13		;
    a124:	30 41       	ret			

0000a126 <EUSCI_A_SPI_getTransmitBufferAddress>:

uint32_t EUSCI_A_SPI_getTransmitBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCAxTXBUF);
}
    a126:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a12a:	0d 43       	clr	r13		;
    a12c:	30 41       	ret			

0000a12e <EUSCI_A_SPI_isBusy>:

uint16_t EUSCI_A_SPI_isBusy(uint16_t baseAddress)
{
    //Return the bus busy status.
    return (HWREG16(baseAddress + OFS_UCAxSTATW) & UCBUSY);
}
    a12e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    a132:	1c f3       	and	#1,	r12	;r3 As==01
    a134:	30 41       	ret			

0000a136 <EUSCI_A_UART_init>:
                       EUSCI_A_UART_initParam *param)
{
    bool retVal = STATUS_SUCCESS;

    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a136:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Clock source select
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCSSEL_3;
    a13a:	bc f0 3f ff 	and	#65343,	0(r12)	;#0xff3f
    a13e:	00 00 
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->selectClockSource;
    a140:	6e 4d       	mov.b	@r13,	r14	;
    a142:	8c de 00 00 	bis	r14,	0(r12)	;

    //MSB, LSB select
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCMSB;
    a146:	bc f0 ff df 	and	#57343,	0(r12)	;#0xdfff
    a14a:	00 00 
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->msborLsbFirst;
    a14c:	9c dd 08 00 	bis	8(r13),	0(r12)	;
    a150:	00 00 

    //UCSPB = 0(1 stop bit) OR 1(2 stop bits)
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCSPB;
    a152:	bc f0 ff f7 	and	#63487,	0(r12)	;#0xf7ff
    a156:	00 00 
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->numberofStopBits;
    a158:	9c dd 0a 00 	bis	10(r13),0(r12)	;0x0000a
    a15c:	00 00 

    //Parity
    switch(param->parity)
    a15e:	5e 4d 06 00 	mov.b	6(r13),	r14	;
    a162:	5e 93       	cmp.b	#1,	r14	;r3 As==01
    a164:	0b 24       	jz	$+24     	;abs 0xa17c
    a166:	4e 93       	cmp.b	#0,	r14	;r3 As==00
    a168:	04 24       	jz	$+10     	;abs 0xa172
    a16a:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    a16c:	0f 24       	jz	$+32     	;abs 0xa18c
    a16e:	30 40 98 a1 	br	#0xa198		;
    {
    case EUSCI_A_UART_NO_PARITY:
        //No Parity
        HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCPEN;
    a172:	bc f0 ff 7f 	and	#32767,	0(r12)	;#0x7fff
    a176:	00 00 
        break;
    a178:	30 40 98 a1 	br	#0xa198		;
    case EUSCI_A_UART_ODD_PARITY:
        //Odd Parity
        HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCPEN;
    a17c:	bc d0 00 80 	bis	#32768,	0(r12)	;#0x8000
    a180:	00 00 
        HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCPAR;
    a182:	bc f0 ff bf 	and	#49151,	0(r12)	;#0xbfff
    a186:	00 00 
        break;
    a188:	30 40 98 a1 	br	#0xa198		;
    case EUSCI_A_UART_EVEN_PARITY:
        //Even Parity
        HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCPEN;
    a18c:	bc d0 00 80 	bis	#32768,	0(r12)	;#0x8000
    a190:	00 00 
        HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCPAR;
    a192:	bc d0 00 40 	bis	#16384,	0(r12)	;#0x4000
    a196:	00 00 
        break;
    }

    //BaudRate Control Register
    HWREG16(baseAddress + OFS_UCAxBRW) = param->clockPrescalar;
    a198:	9c 4d 02 00 	mov	2(r13),	6(r12)	;
    a19c:	06 00 
    //Modulation Control Register
    HWREG16(baseAddress + OFS_UCAxMCTLW) = ((param->secondModReg << 8)
    a19e:	5e 4d 05 00 	mov.b	5(r13),	r14	;
    a1a2:	0e 5e       	rla	r14		;
    a1a4:	0e 5e       	rla	r14		;
    a1a6:	0e 5e       	rla	r14		;
    a1a8:	0e 5e       	rla	r14		;
                                            + (param->firstModReg <<
    a1aa:	5f 4d 04 00 	mov.b	4(r13),	r15	;
    a1ae:	0e 5f       	add	r15,	r14	;
    a1b0:	0e 5e       	rla	r14		;
    a1b2:	0e 5e       	rla	r14		;
    a1b4:	0e 5e       	rla	r14		;
    a1b6:	0e 5e       	rla	r14		;
    4) + param->overSampling);
    a1b8:	5f 4d 0e 00 	mov.b	14(r13),r15	;0x0000e
    }

    //BaudRate Control Register
    HWREG16(baseAddress + OFS_UCAxBRW) = param->clockPrescalar;
    //Modulation Control Register
    HWREG16(baseAddress + OFS_UCAxMCTLW) = ((param->secondModReg << 8)
    a1bc:	0e 5f       	add	r15,	r14	;
    a1be:	8c 4e 08 00 	mov	r14,	8(r12)	;
                                            + (param->firstModReg <<
    4) + param->overSampling);

    //Asynchronous mode & 8 bit character select & clear mode
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSYNC +
    a1c2:	bc f0 ff e8 	and	#59647,	0(r12)	;#0xe8ff
    a1c6:	00 00 
                                              UC7BIT +
                                              UCMODE_3
                                              );

    //Configure  UART mode.
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= param->uartMode;
    a1c8:	9c dd 0c 00 	bis	12(r13),0(r12)	;0x0000c
    a1cc:	00 00 

    //Reset UCRXIE, UCBRKIE, UCDORM, UCTXADDR, UCTXBRK
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCRXEIE + UCBRKIE + UCDORM +
    a1ce:	bc f0 c1 ff 	and	#65473,	0(r12)	;#0xffc1
    a1d2:	00 00 
                                              UCTXADDR + UCTXBRK
                                              );
    return (retVal);
}
    a1d4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    a1d6:	30 41       	ret			

0000a1d8 <EUSCI_A_UART_transmitData>:

void EUSCI_A_UART_transmitData(uint16_t baseAddress,
                               uint8_t transmitData)
{
    a1d8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCAxIE) & UCTXIE))
    a1dc:	ac b3 1a 00 	bit	#2,	26(r12)	;r3 As==10, 0x001a
    a1e0:	06 20       	jnz	$+14     	;abs 0xa1ee
    {
        //Poll for transmit interrupt flag
        while(!(HWREG16(baseAddress + OFS_UCAxIFG) & UCTXIFG))
    a1e2:	0e 4c       	mov	r12,	r14	;
    a1e4:	3e 50 1c 00 	add	#28,	r14	;#0x001c
    a1e8:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a1ec:	fd 27       	jz	$-4      	;abs 0xa1e8
        {
            ;
        }
    }

    HWREG16(baseAddress + OFS_UCAxTXBUF) = transmitData;
    a1ee:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a1f2:	30 41       	ret			

0000a1f4 <EUSCI_A_UART_receiveData>:

uint8_t EUSCI_A_UART_receiveData(uint16_t baseAddress)
{
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCAxIE) & UCRXIE))
    a1f4:	9c b3 1a 00 	bit	#1,	26(r12)	;r3 As==01, 0x001a
    a1f8:	06 20       	jnz	$+14     	;abs 0xa206
    {
        //Poll for receive interrupt flag
        while(!(HWREG16(baseAddress + OFS_UCAxIFG) & UCRXIFG))
    a1fa:	0d 4c       	mov	r12,	r13	;
    a1fc:	3d 50 1c 00 	add	#28,	r13	;#0x001c
    a200:	9d b3 00 00 	bit	#1,	0(r13)	;r3 As==01
    a204:	fd 27       	jz	$-4      	;abs 0xa200
        {
            ;
        }
    }

    return (HWREG16(baseAddress + OFS_UCAxRXBUF));
    a206:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a20a:	30 41       	ret			

0000a20c <EUSCI_A_UART_enableInterrupt>:

void EUSCI_A_UART_enableInterrupt(uint16_t baseAddress,
                                  uint8_t mask)
{
    a20c:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    locMask = (mask & (EUSCI_A_UART_RECEIVE_INTERRUPT
                       | EUSCI_A_UART_TRANSMIT_INTERRUPT
                       | EUSCI_A_UART_STARTBIT_INTERRUPT
                       | EUSCI_A_UART_TRANSMIT_COMPLETE_INTERRUPT));

    HWREG16(baseAddress + OFS_UCAxIE) |= locMask;
    a210:	0e 4d       	mov	r13,	r14	;
    a212:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    a216:	8c de 1a 00 	bis	r14,	26(r12)	; 0x001a

    locMask = (mask & (EUSCI_A_UART_RECEIVE_ERRONEOUSCHAR_INTERRUPT
                       | EUSCI_A_UART_BREAKCHAR_INTERRUPT));
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= locMask;
    a21a:	3d f0 30 00 	and	#48,	r13	;#0x0030
    a21e:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    a222:	30 41       	ret			

0000a224 <EUSCI_A_UART_disableInterrupt>:

void EUSCI_A_UART_disableInterrupt(uint16_t baseAddress,
                                   uint8_t mask)
{
    a224:	3d f0 ff 00 	and	#255,	r13	;#0x00ff

    locMask = (mask & (EUSCI_A_UART_RECEIVE_INTERRUPT
                       | EUSCI_A_UART_TRANSMIT_INTERRUPT
                       | EUSCI_A_UART_STARTBIT_INTERRUPT
                       | EUSCI_A_UART_TRANSMIT_COMPLETE_INTERRUPT));
    HWREG16(baseAddress + OFS_UCAxIE) &= ~locMask;
    a228:	0e 4d       	mov	r13,	r14	;
    a22a:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    a22e:	8c ce 1a 00 	bic	r14,	26(r12)	; 0x001a

    locMask = (mask & (EUSCI_A_UART_RECEIVE_ERRONEOUSCHAR_INTERRUPT
                       | EUSCI_A_UART_BREAKCHAR_INTERRUPT));
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~locMask;
    a232:	3d f0 30 00 	and	#48,	r13	;#0x0030
    a236:	8c cd 00 00 	bic	r13,	0(r12)	;
}
    a23a:	30 41       	ret			

0000a23c <EUSCI_A_UART_getInterruptStatus>:

uint8_t EUSCI_A_UART_getInterruptStatus(uint16_t baseAddress,
                                        uint8_t mask)
{
    return (HWREG16(baseAddress + OFS_UCAxIFG) & mask);
    a23c:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
}
    a240:	4c fd       	and.b	r13,	r12	;
    a242:	30 41       	ret			

0000a244 <EUSCI_A_UART_clearInterrupt>:

void EUSCI_A_UART_clearInterrupt(uint16_t baseAddress,
                                 uint8_t mask)
{
    a244:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //Clear the UART interrupt source.
    HWREG16(baseAddress + OFS_UCAxIFG) &= ~(mask);
    a248:	8c cd 1c 00 	bic	r13,	28(r12)	; 0x001c
}
    a24c:	30 41       	ret			

0000a24e <EUSCI_A_UART_enable>:

void EUSCI_A_UART_enable(uint16_t baseAddress)
{
    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~(UCSWRST);
    a24e:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a252:	30 41       	ret			

0000a254 <EUSCI_A_UART_disable>:

void EUSCI_A_UART_disable(uint16_t baseAddress)
{
    //Set the UCSWRST bit to disable the USCI Module
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCSWRST;
    a254:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
}
    a258:	30 41       	ret			

0000a25a <EUSCI_A_UART_queryStatusFlags>:

uint8_t EUSCI_A_UART_queryStatusFlags(uint16_t baseAddress,
                                      uint8_t mask)
{
    return (HWREG16(baseAddress + OFS_UCAxSTATW) & mask);
    a25a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
}
    a25e:	4c fd       	and.b	r13,	r12	;
    a260:	30 41       	ret			

0000a262 <EUSCI_A_UART_setDormant>:

void EUSCI_A_UART_setDormant(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCDORM;
    a262:	bc d2 00 00 	bis	#8,	0(r12)	;r2 As==11
}
    a266:	30 41       	ret			

0000a268 <EUSCI_A_UART_resetDormant>:

void EUSCI_A_UART_resetDormant(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_UCAxCTLW0) &= ~UCDORM;
    a268:	bc c2 00 00 	bic	#8,	0(r12)	;r2 As==11
}
    a26c:	30 41       	ret			

0000a26e <EUSCI_A_UART_transmitAddress>:

void EUSCI_A_UART_transmitAddress(uint16_t baseAddress,
                                  uint8_t transmitAddress)
{
    //Set UCTXADDR bit
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCTXADDR;
    a26e:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    //Place next byte to be sent into the transmit buffer
    HWREG16(baseAddress + OFS_UCAxTXBUF) = transmitAddress;
    a272:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a276:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a27a:	30 41       	ret			

0000a27c <EUSCI_A_UART_transmitBreak>:

void EUSCI_A_UART_transmitBreak(uint16_t baseAddress)
{
    //Set UCTXADDR bit
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCTXBRK;
    a27c:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10

    //If current mode is automatic baud-rate detection
    if(EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE ==
       (HWREG16(baseAddress + OFS_UCAxCTLW0) &
    a280:	2d 4c       	mov	@r12,	r13	;
    a282:	3d f0 00 06 	and	#1536,	r13	;#0x0600
{
    //Set UCTXADDR bit
    HWREG16(baseAddress + OFS_UCAxCTLW0) |= UCTXBRK;

    //If current mode is automatic baud-rate detection
    if(EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE ==
    a286:	3d 90 00 06 	cmp	#1536,	r13	;#0x0600
    a28a:	05 20       	jnz	$+12     	;abs 0xa296
       (HWREG16(baseAddress + OFS_UCAxCTLW0) &
        EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE))
    {
        HWREG16(baseAddress +
                OFS_UCAxTXBUF) = EUSCI_A_UART_AUTOMATICBAUDRATE_SYNC;
    a28c:	bc 40 55 00 	mov	#85,	14(r12)	;#0x0055, 0x000e
    a290:	0e 00 
    a292:	30 40 9a a2 	br	#0xa29a		;
    }
    else
    {
        HWREG16(baseAddress + OFS_UCAxTXBUF) = DEFAULT_SYNC;
    a296:	8c 43 0e 00 	mov	#0,	14(r12)	;r3 As==00, 0x000e
    }

    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCAxIE) & UCTXIE))
    a29a:	ac b3 1a 00 	bit	#2,	26(r12)	;r3 As==10, 0x001a
    a29e:	05 20       	jnz	$+12     	;abs 0xa2aa
    {
        //Poll for transmit interrupt flag
        while(!(HWREG16(baseAddress + OFS_UCAxIFG) & UCTXIFG))
    a2a0:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    a2a4:	ac b3 00 00 	bit	#2,	0(r12)	;r3 As==10
    a2a8:	fd 27       	jz	$-4      	;abs 0xa2a4
        {
            ;
        }
    }
}
    a2aa:	30 41       	ret			

0000a2ac <EUSCI_A_UART_getReceiveBufferAddress>:

uint32_t EUSCI_A_UART_getReceiveBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCAxRXBUF);
}
    a2ac:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    a2b0:	0d 43       	clr	r13		;
    a2b2:	30 41       	ret			

0000a2b4 <EUSCI_A_UART_getTransmitBufferAddress>:

uint32_t EUSCI_A_UART_getTransmitBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCAxTXBUF);
}
    a2b4:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a2b8:	0d 43       	clr	r13		;
    a2ba:	30 41       	ret			

0000a2bc <EUSCI_A_UART_selectDeglitchTime>:

void EUSCI_A_UART_selectDeglitchTime(uint16_t baseAddress,
                                     uint16_t deglitchTime)
{
    HWREG16(baseAddress + OFS_UCAxCTLW1) &= ~(UCGLIT1 + UCGLIT0);
    a2bc:	2c 53       	incd	r12		;
    a2be:	bc f0 fc ff 	and	#65532,	0(r12)	;#0xfffc
    a2c2:	00 00 

    HWREG16(baseAddress + OFS_UCAxCTLW1) |= deglitchTime;
    a2c4:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    a2c8:	30 41       	ret			

0000a2ca <EUSCI_B_I2C_initMaster>:

#include <assert.h>

void EUSCI_B_I2C_initMaster(uint16_t baseAddress,
                            EUSCI_B_I2C_initMasterParam *param)
{
    a2ca:	0a 12       	push	r10		;
    a2cc:	0a 4c       	mov	r12,	r10	;
    a2ce:	0e 4d       	mov	r13,	r14	;
    uint16_t preScalarValue;

    //Disable the USCI module and clears the other bits of control register
    HWREG16(baseAddress + OFS_UCBxCTLW0) = UCSWRST;
    a2d0:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

    //Configure Automatic STOP condition generation
    HWREG16(baseAddress + OFS_UCBxCTLW1) &= ~UCASTP_3;
    a2d4:	2c 53       	incd	r12		;
    a2d6:	bc f0 f3 ff 	and	#65523,	0(r12)	;#0xfff3
    a2da:	00 00 
    HWREG16(baseAddress + OFS_UCBxCTLW1) |= param->autoSTOPGeneration;
    a2dc:	5d 4d 0b 00 	mov.b	11(r13),r13	;0x0000b
    a2e0:	8c dd 00 00 	bis	r13,	0(r12)	;

    //Byte Count Threshold
    HWREG16(baseAddress + OFS_UCBxTBCNT) = param->byteCounterThreshold;
    a2e4:	5c 4e 0a 00 	mov.b	10(r14),r12	;0x0000a
    a2e8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    a2ec:	8a 4c 0a 00 	mov	r12,	10(r10)	; 0x000a
     * Configure as I2C master mode.
     * UCMST = Master mode
     * UCMODE_3 = I2C mode
     * UCSYNC = Synchronous mode
     */
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCMST + UCMODE_3 + UCSYNC;
    a2f0:	ba d0 00 0f 	bis	#3840,	0(r10)	;#0x0f00
    a2f4:	00 00 

    //Configure I2C clock source
    HWREG16(baseAddress +
            OFS_UCBxCTLW0) |= (param->selectClockSource + UCSWRST);
    a2f6:	6c 4e       	mov.b	@r14,	r12	;
    a2f8:	1c 53       	inc	r12		;
    a2fa:	8a dc 00 00 	bis	r12,	0(r10)	;
     * Compute the clock divider that achieves the fastest speed less than or
     * equal to the desired speed.  The numerator is biased to favor a larger
     * clock divider so that the resulting clock is always less than or equal
     * to the desired clock, never greater.
     */
    preScalarValue = (uint16_t)(param->i2cClk / param->dataRate);
    a2fe:	1c 4e 02 00 	mov	2(r14),	r12	;
    a302:	1d 4e 04 00 	mov	4(r14),	r13	;
    a306:	1f 4e 08 00 	mov	8(r14),	r15	;
    a30a:	1e 4e 06 00 	mov	6(r14),	r14	;
    a30e:	b0 12 86 d0 	call	#53382		;#0xd086
    HWREG16(baseAddress + OFS_UCBxBRW) = preScalarValue;
    a312:	8a 4c 06 00 	mov	r12,	6(r10)	;
}
    a316:	3a 41       	pop	r10		;
    a318:	30 41       	ret			

0000a31a <EUSCI_B_I2C_initSlave>:

void EUSCI_B_I2C_initSlave(uint16_t baseAddress,
                           EUSCI_B_I2C_initSlaveParam *param)
{
    //Disable the USCI module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a31a:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Clear USCI master mode
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~UCMST;
    a31e:	bc f0 ff f7 	and	#63487,	0(r12)	;#0xf7ff
    a322:	00 00 

    //Configure I2C as Slave and Synchronous mode
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCMODE_3 + UCSYNC;
    a324:	bc d0 00 07 	bis	#1792,	0(r12)	;#0x0700
    a328:	00 00 

    //Set up the slave address.
    HWREG16(baseAddress + OFS_UCBxI2COA0 + param->slaveAddressOffset)
    a32a:	5e 4d 01 00 	mov.b	1(r13),	r14	;
    a32e:	0c 5e       	add	r14,	r12	;
        = param->slaveAddress + param->slaveOwnAddressEnable;
    a330:	6e 4d       	mov.b	@r13,	r14	;
    a332:	1e 5d 02 00 	add	2(r13),	r14	;
    a336:	8c 4e 14 00 	mov	r14,	20(r12)	; 0x0014
}
    a33a:	30 41       	ret			

0000a33c <EUSCI_B_I2C_enable>:

void EUSCI_B_I2C_enable(uint16_t baseAddress)
{
    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSWRST);
    a33c:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a340:	30 41       	ret			

0000a342 <EUSCI_B_I2C_disable>:

void EUSCI_B_I2C_disable(uint16_t baseAddress)
{
    //Set the UCSWRST bit to disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a342:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
}
    a346:	30 41       	ret			

0000a348 <EUSCI_B_I2C_setSlaveAddress>:

void EUSCI_B_I2C_setSlaveAddress(uint16_t baseAddress,
                                 uint8_t slaveAddress)
{
    //Set the address of the slave with which the master will communicate.
    HWREG16(baseAddress + OFS_UCBxI2CSA) = (slaveAddress);
    a348:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a34c:	8c 4d 20 00 	mov	r13,	32(r12)	; 0x0020
}
    a350:	30 41       	ret			

0000a352 <EUSCI_B_I2C_setMode>:

void EUSCI_B_I2C_setMode(uint16_t baseAddress,
                         uint8_t mode)
{
    a352:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~EUSCI_B_I2C_TRANSMIT_MODE;
    a356:	bc f0 ef ff 	and	#65519,	0(r12)	;#0xffef
    a35a:	00 00 
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= mode;
    a35c:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    a360:	30 41       	ret			

0000a362 <EUSCI_B_I2C_getMode>:

uint8_t EUSCI_B_I2C_getMode(uint16_t baseAddress)
{
    //Read the I2C mode.
    return ((HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTR));
    a362:	2c 4c       	mov	@r12,	r12	;
}
    a364:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    a368:	30 41       	ret			

0000a36a <EUSCI_B_I2C_slavePutData>:

void EUSCI_B_I2C_slavePutData(uint16_t baseAddress,
                              uint8_t transmitData)
{
    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = transmitData;
    a36a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a36e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a372:	30 41       	ret			

0000a374 <EUSCI_B_I2C_slaveGetData>:

uint8_t EUSCI_B_I2C_slaveGetData(uint16_t baseAddress)
{
    //Read a byte.
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a374:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a378:	30 41       	ret			

0000a37a <EUSCI_B_I2C_isBusBusy>:

uint16_t EUSCI_B_I2C_isBusBusy(uint16_t baseAddress)
{
    //Return the bus busy status.
    return (HWREG16(baseAddress + OFS_UCBxSTATW) & UCBBUSY);
}
    a37a:	1c 4c 08 00 	mov	8(r12),	r12	;
    a37e:	3c f0 10 00 	and	#16,	r12	;#0x0010
    a382:	30 41       	ret			

0000a384 <EUSCI_B_I2C_masterIsStopSent>:

uint16_t EUSCI_B_I2C_masterIsStopSent(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTP);
}
    a384:	2c 4c       	mov	@r12,	r12	;
    a386:	2c f2       	and	#4,	r12	;r2 As==10
    a388:	30 41       	ret			

0000a38a <EUSCI_B_I2C_masterIsStartSent>:

uint16_t EUSCI_B_I2C_masterIsStartSent(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTT);
}
    a38a:	2c 4c       	mov	@r12,	r12	;
    a38c:	2c f3       	and	#2,	r12	;r3 As==10
    a38e:	30 41       	ret			

0000a390 <EUSCI_B_I2C_enableInterrupt>:

void EUSCI_B_I2C_enableInterrupt(uint16_t baseAddress,
                                 uint16_t mask)
{
    //Enable the interrupt masked bit
    HWREG16(baseAddress + OFS_UCBxIE) |= mask;
    a390:	8c dd 2a 00 	bis	r13,	42(r12)	; 0x002a
}
    a394:	30 41       	ret			

0000a396 <EUSCI_B_I2C_disableInterrupt>:

void EUSCI_B_I2C_disableInterrupt(uint16_t baseAddress,
                                  uint16_t mask)
{
    //Disable the interrupt masked bit
    HWREG16(baseAddress + OFS_UCBxIE) &= ~(mask);
    a396:	8c cd 2a 00 	bic	r13,	42(r12)	; 0x002a
}
    a39a:	30 41       	ret			

0000a39c <EUSCI_B_I2C_clearInterrupt>:

void EUSCI_B_I2C_clearInterrupt(uint16_t baseAddress,
                                uint16_t mask)
{
    //Clear the I2C interrupt source.
    HWREG16(baseAddress + OFS_UCBxIFG) &= ~(mask);
    a39c:	8c cd 2c 00 	bic	r13,	44(r12)	; 0x002c
}
    a3a0:	30 41       	ret			

0000a3a2 <EUSCI_B_I2C_getInterruptStatus>:
uint16_t EUSCI_B_I2C_getInterruptStatus(uint16_t baseAddress,
                                        uint16_t mask)
{
    //Return the interrupt status of the request masked bit.
    return (HWREG16(baseAddress + OFS_UCBxIFG) & mask);
}
    a3a2:	1c 4c 2c 00 	mov	44(r12),r12	;0x0002c
    a3a6:	0c fd       	and	r13,	r12	;
    a3a8:	30 41       	ret			

0000a3aa <EUSCI_B_I2C_masterSendSingleByte>:

void EUSCI_B_I2C_masterSendSingleByte(uint16_t baseAddress,
                                      uint8_t txData)
{
    a3aa:	0a 12       	push	r10		;
    a3ac:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //Store current TXIE status
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a3b0:	0b 4c       	mov	r12,	r11	;
    a3b2:	3b 50 2a 00 	add	#42,	r11	;#0x002a
    a3b6:	2a 4b       	mov	@r11,	r10	;
    a3b8:	2a f3       	and	#2,	r10	;r3 As==10

    //Disable transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) &= ~(UCTXIE);
    a3ba:	ab c3 00 00 	bic	#2,	0(r11)	;r3 As==10

    //Send start condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTR + UCTXSTT;
    a3be:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    a3c2:	00 00 

    //Poll for transmit interrupt flag.
    while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a3c4:	0f 4c       	mov	r12,	r15	;
    a3c6:	3f 50 2c 00 	add	#44,	r15	;#0x002c
    a3ca:	0e 4f       	mov	r15,	r14	;
    a3cc:	af b3 00 00 	bit	#2,	0(r15)	;r3 As==10
    a3d0:	fc 27       	jz	$-6      	;abs 0xa3ca
    {
        ;
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a3d2:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    //Poll for transmit interrupt flag.
    while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a3d6:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a3da:	fd 27       	jz	$-4      	;abs 0xa3d6
    {
        ;
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a3dc:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    //Clear transmit interrupt flag before enabling interrupt again
    HWREG16(baseAddress + OFS_UCBxIFG) &= ~(UCTXIFG);
    a3e0:	ae c3 00 00 	bic	#2,	0(r14)	;r3 As==10

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;
    a3e4:	8b da 00 00 	bis	r10,	0(r11)	;
}
    a3e8:	3a 41       	pop	r10		;
    a3ea:	30 41       	ret			

0000a3ec <EUSCI_B_I2C_masterReceiveSingleByte>:

uint8_t EUSCI_B_I2C_masterReceiveSingleByte(uint16_t baseAddress)
{
    //Set USCI in Receive mode
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~UCTR;
    a3ec:	bc f0 ef ff 	and	#65519,	0(r12)	;#0xffef
    a3f0:	00 00 

    //Send start
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (UCTXSTT + UCTXSTP);
    a3f2:	bc d0 06 00 	bis	#6,	0(r12)	;
    a3f6:	00 00 

    //Poll for receive interrupt flag.
    while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCRXIFG))
    a3f8:	0d 4c       	mov	r12,	r13	;
    a3fa:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    a3fe:	9d b3 00 00 	bit	#1,	0(r13)	;r3 As==01
    a402:	fd 27       	jz	$-4      	;abs 0xa3fe
    {
        ;
    }

    //Send single byte data.
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a404:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a408:	30 41       	ret			

0000a40a <EUSCI_B_I2C_masterSendSingleByteWithTimeout>:

bool EUSCI_B_I2C_masterSendSingleByteWithTimeout(uint16_t baseAddress,
                                                 uint8_t txData,
                                                 uint32_t timeout)
{
    a40a:	0a 12       	push	r10		;
    a40c:	09 12       	push	r9		;
    a40e:	08 12       	push	r8		;
    a410:	07 12       	push	r7		;
    a412:	06 12       	push	r6		;
    a414:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a418:	08 4e       	mov	r14,	r8	;
    a41a:	09 4f       	mov	r15,	r9	;
    // Creating variable for second timeout scenario
    uint32_t timeout2 = timeout;

    //Store current TXIE status
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a41c:	07 4c       	mov	r12,	r7	;
    a41e:	37 50 2a 00 	add	#42,	r7	;#0x002a
    a422:	26 47       	mov	@r7,	r6	;

    //Disable transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) &= ~(UCTXIE);
    a424:	a7 c3 00 00 	bic	#2,	0(r7)	;r3 As==10

    //Send start condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTR + UCTXSTT;
    a428:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    a42c:	00 00 

    //Poll for transmit interrupt flag.
    while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout)
    a42e:	0a 4e       	mov	r14,	r10	;
    a430:	0b 4f       	mov	r15,	r11	;
    a432:	0e 4c       	mov	r12,	r14	;
    a434:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    a438:	0f 4e       	mov	r14,	r15	;
    a43a:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a43e:	09 20       	jnz	$+20     	;abs 0xa452
    a440:	3a 53       	add	#-1,	r10	;r3 As==11
    a442:	3b 63       	addc	#-1,	r11	;r3 As==11
    a444:	0f 4a       	mov	r10,	r15	;
    a446:	0f db       	bis	r11,	r15	;
    a448:	0f 93       	cmp	#0,	r15	;r3 As==00
    a44a:	f6 23       	jnz	$-18     	;abs 0xa438
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a44c:	0c 43       	clr	r12		;
    a44e:	30 40 9a a4 	br	#0xa49a		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout == 0)
    a452:	0e 4a       	mov	r10,	r14	;
    a454:	0e db       	bis	r11,	r14	;
    a456:	0e 93       	cmp	#0,	r14	;r3 As==00
    a458:	1c 24       	jz	$+58     	;abs 0xa492
    {
        return (STATUS_FAIL);
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a45a:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    //Poll for transmit interrupt flag.
    while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout2)
    a45e:	af b3 00 00 	bit	#2,	0(r15)	;r3 As==10
    a462:	09 20       	jnz	$+20     	;abs 0xa476
    a464:	38 53       	add	#-1,	r8	;r3 As==11
    a466:	39 63       	addc	#-1,	r9	;r3 As==11
    a468:	0d 48       	mov	r8,	r13	;
    a46a:	0d d9       	bis	r9,	r13	;
    a46c:	0d 93       	cmp	#0,	r13	;r3 As==00
    a46e:	f7 23       	jnz	$-16     	;abs 0xa45e
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a470:	0c 43       	clr	r12		;
    a472:	30 40 9a a4 	br	#0xa49a		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    a476:	0d 48       	mov	r8,	r13	;
    a478:	0d d9       	bis	r9,	r13	;
    a47a:	0d 93       	cmp	#0,	r13	;r3 As==00
    a47c:	0d 24       	jz	$+28     	;abs 0xa498
    {
        return (STATUS_FAIL);
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a47e:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    //Clear transmit interrupt flag before enabling interrupt again
    HWREG16(baseAddress + OFS_UCBxIFG) &= ~(UCTXIFG);
    a482:	af c3 00 00 	bic	#2,	0(r15)	;r3 As==10
{
    // Creating variable for second timeout scenario
    uint32_t timeout2 = timeout;

    //Store current TXIE status
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a486:	26 f3       	and	#2,	r6	;r3 As==10

    //Clear transmit interrupt flag before enabling interrupt again
    HWREG16(baseAddress + OFS_UCBxIFG) &= ~(UCTXIFG);

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;
    a488:	87 d6 00 00 	bis	r6,	0(r7)	;

    return (STATUS_SUCCESS);
    a48c:	1c 43       	mov	#1,	r12	;r3 As==01
    a48e:	30 40 9a a4 	br	#0xa49a		;
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a492:	0c 43       	clr	r12		;
    a494:	30 40 9a a4 	br	#0xa49a		;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a498:	0c 43       	clr	r12		;

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;

    return (STATUS_SUCCESS);
}
    a49a:	30 40 6c d1 	br	#0xd16c		;

0000a49e <EUSCI_B_I2C_masterSendMultiByteStart>:

void EUSCI_B_I2C_masterSendMultiByteStart(uint16_t baseAddress,
                                          uint8_t txData)
{
    a49e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //Store current transmit interrupt enable
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a4a2:	0f 4c       	mov	r12,	r15	;
    a4a4:	3f 50 2a 00 	add	#42,	r15	;#0x002a
    a4a8:	2b 4f       	mov	@r15,	r11	;
    a4aa:	2b f3       	and	#2,	r11	;r3 As==10

    //Disable transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) &= ~(UCTXIE);
    a4ac:	af c3 00 00 	bic	#2,	0(r15)	;r3 As==10

    //Send start condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTR + UCTXSTT;
    a4b0:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    a4b4:	00 00 

    //Poll for transmit interrupt flag.
    while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a4b6:	0e 4c       	mov	r12,	r14	;
    a4b8:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    a4bc:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a4c0:	fd 27       	jz	$-4      	;abs 0xa4bc
    {
        ;
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a4c2:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;
    a4c6:	8f db 00 00 	bis	r11,	0(r15)	;
}
    a4ca:	30 41       	ret			

0000a4cc <EUSCI_B_I2C_masterSendMultiByteStartWithTimeout>:

bool EUSCI_B_I2C_masterSendMultiByteStartWithTimeout(uint16_t baseAddress,
                                                     uint8_t txData,
                                                     uint32_t timeout)
{
    a4cc:	0a 12       	push	r10		;
    a4ce:	09 12       	push	r9		;
    a4d0:	08 12       	push	r8		;
    a4d2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //Store current transmit interrupt enable
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a4d6:	09 4c       	mov	r12,	r9	;
    a4d8:	39 50 2a 00 	add	#42,	r9	;#0x002a
    a4dc:	28 49       	mov	@r9,	r8	;

    //Disable transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) &= ~(UCTXIE);
    a4de:	a9 c3 00 00 	bic	#2,	0(r9)	;r3 As==10

    //Send start condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTR + UCTXSTT;
    a4e2:	bc d0 12 00 	bis	#18,	0(r12)	;#0x0012
    a4e6:	00 00 

    //Poll for transmit interrupt flag.
    while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout)
    a4e8:	0a 4c       	mov	r12,	r10	;
    a4ea:	3a 50 2c 00 	add	#44,	r10	;#0x002c
    a4ee:	aa b3 00 00 	bit	#2,	0(r10)	;r3 As==10
    a4f2:	09 20       	jnz	$+20     	;abs 0xa506
    a4f4:	3e 53       	add	#-1,	r14	;r3 As==11
    a4f6:	3f 63       	addc	#-1,	r15	;r3 As==11
    a4f8:	0b 4e       	mov	r14,	r11	;
    a4fa:	0b df       	bis	r15,	r11	;
    a4fc:	0b 93       	cmp	#0,	r11	;r3 As==00
    a4fe:	f7 23       	jnz	$-16     	;abs 0xa4ee
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a500:	0c 43       	clr	r12		;
    a502:	30 40 1e a5 	br	#0xa51e		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout == 0)
    a506:	0e df       	bis	r15,	r14	;
    a508:	0e 93       	cmp	#0,	r14	;r3 As==00
    a50a:	08 24       	jz	$+18     	;abs 0xa51c
    {
        return (STATUS_FAIL);
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a50c:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
bool EUSCI_B_I2C_masterSendMultiByteStartWithTimeout(uint16_t baseAddress,
                                                     uint8_t txData,
                                                     uint32_t timeout)
{
    //Store current transmit interrupt enable
    uint16_t txieStatus = HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE;
    a510:	28 f3       	and	#2,	r8	;r3 As==10

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;
    a512:	89 d8 00 00 	bis	r8,	0(r9)	;

    return(STATUS_SUCCESS);
    a516:	1c 43       	mov	#1,	r12	;r3 As==01
    a518:	30 40 1e a5 	br	#0xa51e		;
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a51c:	0c 43       	clr	r12		;

    //Reinstate transmit interrupt enable
    HWREG16(baseAddress + OFS_UCBxIE) |= txieStatus;

    return(STATUS_SUCCESS);
}
    a51e:	30 40 70 d1 	br	#0xd170		;

0000a522 <EUSCI_B_I2C_masterSendMultiByteNext>:

void EUSCI_B_I2C_masterSendMultiByteNext(uint16_t baseAddress,
                                         uint8_t txData)
{
    a522:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a526:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a52a:	06 20       	jnz	$+14     	;abs 0xa538
    {
        //Poll for transmit interrupt flag.
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a52c:	0e 4c       	mov	r12,	r14	;
    a52e:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    a532:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a536:	fd 27       	jz	$-4      	;abs 0xa532
            ;
        }
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a538:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a53c:	30 41       	ret			

0000a53e <EUSCI_B_I2C_masterSendMultiByteNextWithTimeout>:

bool EUSCI_B_I2C_masterSendMultiByteNextWithTimeout(uint16_t baseAddress,
                                                    uint8_t txData,
                                                    uint32_t timeout)
{
    a53e:	0a 12       	push	r10		;
    a540:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a544:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a548:	12 20       	jnz	$+38     	;abs 0xa56e
    {
        //Poll for transmit interrupt flag.
        while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout)
    a54a:	0a 4c       	mov	r12,	r10	;
    a54c:	3a 50 2c 00 	add	#44,	r10	;#0x002c
    a550:	aa b3 00 00 	bit	#2,	0(r10)	;r3 As==10
    a554:	09 20       	jnz	$+20     	;abs 0xa568
    a556:	3e 53       	add	#-1,	r14	;r3 As==11
    a558:	3f 63       	addc	#-1,	r15	;r3 As==11
    a55a:	0b 4e       	mov	r14,	r11	;
    a55c:	0b df       	bis	r15,	r11	;
    a55e:	0b 93       	cmp	#0,	r11	;r3 As==00
    a560:	f7 23       	jnz	$-16     	;abs 0xa550
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a562:	0c 43       	clr	r12		;
    a564:	30 40 7a a5 	br	#0xa57a		;
        {
            ;
        }

        //Check if transfer timed out
        if(timeout == 0)
    a568:	0e df       	bis	r15,	r14	;
    a56a:	0e 93       	cmp	#0,	r14	;r3 As==00
    a56c:	05 24       	jz	$+12     	;abs 0xa578
            return (STATUS_FAIL);
        }
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a56e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    return(STATUS_SUCCESS);
    a572:	1c 43       	mov	#1,	r12	;r3 As==01
    a574:	30 40 7a a5 	br	#0xa57a		;
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a578:	0c 43       	clr	r12		;

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;

    return(STATUS_SUCCESS);
}
    a57a:	3a 41       	pop	r10		;
    a57c:	30 41       	ret			

0000a57e <EUSCI_B_I2C_masterSendMultiByteFinish>:

void EUSCI_B_I2C_masterSendMultiByteFinish(uint16_t baseAddress,
                                           uint8_t txData)
{
    a57e:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a582:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a586:	06 20       	jnz	$+14     	;abs 0xa594
    {
        //Poll for transmit interrupt flag.
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a588:	0e 4c       	mov	r12,	r14	;
    a58a:	3e 50 2c 00 	add	#44,	r14	;#0x002c
    a58e:	ae b3 00 00 	bit	#2,	0(r14)	;r3 As==10
    a592:	fd 27       	jz	$-4      	;abs 0xa58e
            ;
        }
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a594:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    //Poll for transmit interrupt flag.
    while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a598:	0d 4c       	mov	r12,	r13	;
    a59a:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    a59e:	ad b3 00 00 	bit	#2,	0(r13)	;r3 As==10
    a5a2:	fd 27       	jz	$-4      	;abs 0xa59e
    {
        ;
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a5a4:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10
}
    a5a8:	30 41       	ret			

0000a5aa <EUSCI_B_I2C_masterSendMultiByteFinishWithTimeout>:

bool EUSCI_B_I2C_masterSendMultiByteFinishWithTimeout(uint16_t baseAddress,
                                                      uint8_t txData,
                                                      uint32_t timeout)
{
    a5aa:	0a 12       	push	r10		;
    a5ac:	09 12       	push	r9		;
    a5ae:	08 12       	push	r8		;
    a5b0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint32_t timeout2 = timeout;

    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a5b4:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a5b8:	14 20       	jnz	$+42     	;abs 0xa5e2
    a5ba:	0a 4e       	mov	r14,	r10	;
    a5bc:	0b 4f       	mov	r15,	r11	;
    {
        //Poll for transmit interrupt flag.
        while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout)
    a5be:	08 4c       	mov	r12,	r8	;
    a5c0:	38 50 2c 00 	add	#44,	r8	;#0x002c
    a5c4:	a8 b3 00 00 	bit	#2,	0(r8)	;r3 As==10
    a5c8:	09 20       	jnz	$+20     	;abs 0xa5dc
    a5ca:	3a 53       	add	#-1,	r10	;r3 As==11
    a5cc:	3b 63       	addc	#-1,	r11	;r3 As==11
    a5ce:	09 4a       	mov	r10,	r9	;
    a5d0:	09 db       	bis	r11,	r9	;
    a5d2:	09 93       	cmp	#0,	r9	;r3 As==00
    a5d4:	f7 23       	jnz	$-16     	;abs 0xa5c4
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a5d6:	0c 43       	clr	r12		;
    a5d8:	30 40 1e a6 	br	#0xa61e		;
        {
            ;
        }

        //Check if transfer timed out
        if(timeout == 0)
    a5dc:	0a db       	bis	r11,	r10	;
    a5de:	0a 93       	cmp	#0,	r10	;r3 As==00
    a5e0:	1a 24       	jz	$+54     	;abs 0xa616
            return (STATUS_FAIL);
        }
    }

    //Send single byte data.
    HWREG16(baseAddress + OFS_UCBxTXBUF) = txData;
    a5e2:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

    //Poll for transmit interrupt flag.
    while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout2)
    a5e6:	0a 4c       	mov	r12,	r10	;
    a5e8:	3a 50 2c 00 	add	#44,	r10	;#0x002c
    a5ec:	aa b3 00 00 	bit	#2,	0(r10)	;r3 As==10
    a5f0:	09 20       	jnz	$+20     	;abs 0xa604
    a5f2:	3e 53       	add	#-1,	r14	;r3 As==11
    a5f4:	3f 63       	addc	#-1,	r15	;r3 As==11
    a5f6:	0d 4e       	mov	r14,	r13	;
    a5f8:	0d df       	bis	r15,	r13	;
    a5fa:	0d 93       	cmp	#0,	r13	;r3 As==00
    a5fc:	f7 23       	jnz	$-16     	;abs 0xa5ec
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a5fe:	0c 43       	clr	r12		;
    a600:	30 40 1e a6 	br	#0xa61e		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    a604:	0d 4e       	mov	r14,	r13	;
    a606:	0d df       	bis	r15,	r13	;
    a608:	0d 93       	cmp	#0,	r13	;r3 As==00
    a60a:	08 24       	jz	$+18     	;abs 0xa61c
    {
        return (STATUS_FAIL);
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a60c:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    return(STATUS_SUCCESS);
    a610:	1c 43       	mov	#1,	r12	;r3 As==01
    a612:	30 40 1e a6 	br	#0xa61e		;
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a616:	0c 43       	clr	r12		;
    a618:	30 40 1e a6 	br	#0xa61e		;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a61c:	0c 43       	clr	r12		;

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;

    return(STATUS_SUCCESS);
}
    a61e:	30 40 70 d1 	br	#0xd170		;

0000a622 <EUSCI_B_I2C_masterSendStart>:

void EUSCI_B_I2C_masterSendStart(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTT;
    a622:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10
}
    a626:	30 41       	ret			

0000a628 <EUSCI_B_I2C_masterSendMultiByteStop>:

void EUSCI_B_I2C_masterSendMultiByteStop(uint16_t baseAddress)
{
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a628:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a62c:	06 20       	jnz	$+14     	;abs 0xa63a
    {
        //Poll for transmit interrupt flag.
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG))
    a62e:	0d 4c       	mov	r12,	r13	;
    a630:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    a634:	ad b3 00 00 	bit	#2,	0(r13)	;r3 As==10
    a638:	fd 27       	jz	$-4      	;abs 0xa634
            ;
        }
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a63a:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10
}
    a63e:	30 41       	ret			

0000a640 <EUSCI_B_I2C_masterSendMultiByteStopWithTimeout>:

bool EUSCI_B_I2C_masterSendMultiByteStopWithTimeout(uint16_t baseAddress,
                                                    uint32_t timeout)
{
    a640:	0f 4e       	mov	r14,	r15	;
    a642:	0e 4d       	mov	r13,	r14	;
    //If interrupts are not used, poll for flags
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCTXIE))
    a644:	ac b3 2a 00 	bit	#2,	42(r12)	;r3 As==10, 0x002a
    a648:	13 20       	jnz	$+40     	;abs 0xa670
    {
        //Poll for transmit interrupt flag.
        while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCTXIFG)) && --timeout)
    a64a:	0b 4c       	mov	r12,	r11	;
    a64c:	3b 50 2c 00 	add	#44,	r11	;#0x002c
    a650:	ab b3 00 00 	bit	#2,	0(r11)	;r3 As==10
    a654:	09 20       	jnz	$+20     	;abs 0xa668
    a656:	3e 53       	add	#-1,	r14	;r3 As==11
    a658:	3f 63       	addc	#-1,	r15	;r3 As==11
    a65a:	0d 4e       	mov	r14,	r13	;
    a65c:	0d df       	bis	r15,	r13	;
    a65e:	0d 93       	cmp	#0,	r13	;r3 As==00
    a660:	f7 23       	jnz	$-16     	;abs 0xa650
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a662:	0c 43       	clr	r12		;
    a664:	30 40 7c a6 	br	#0xa67c		;
        {
            ;
        }

        //Check if transfer timed out
        if(timeout == 0)
    a668:	0d 4e       	mov	r14,	r13	;
    a66a:	0d df       	bis	r15,	r13	;
    a66c:	0d 93       	cmp	#0,	r13	;r3 As==00
    a66e:	05 24       	jz	$+12     	;abs 0xa67a
            return (STATUS_FAIL);
        }
    }

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a670:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    return (STATUS_SUCCESS);
    a674:	1c 43       	mov	#1,	r12	;r3 As==01
    a676:	30 40 7c a6 	br	#0xa67c		;
        }

        //Check if transfer timed out
        if(timeout == 0)
        {
            return (STATUS_FAIL);
    a67a:	0c 43       	clr	r12		;

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;

    return (STATUS_SUCCESS);
}
    a67c:	30 41       	ret			

0000a67e <EUSCI_B_I2C_masterReceiveStart>:

void EUSCI_B_I2C_masterReceiveStart(uint16_t baseAddress)
{
    //Set USCI in Receive mode
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~UCTR;
    a67e:	bc f0 ef ff 	and	#65519,	0(r12)	;#0xffef
    a682:	00 00 
    //Send start
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTT;
    a684:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10
}
    a688:	30 41       	ret			

0000a68a <EUSCI_B_I2C_masterReceiveMultiByteNext>:

uint8_t EUSCI_B_I2C_masterReceiveMultiByteNext(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a68a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a68e:	30 41       	ret			

0000a690 <EUSCI_B_I2C_masterReceiveMultiByteFinish>:

uint8_t EUSCI_B_I2C_masterReceiveMultiByteFinish(uint16_t baseAddress)
{
    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a690:	0e 4c       	mov	r12,	r14	;
    a692:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    //Wait for Stop to finish
    while(HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTP)
    {
        // Wait for RX buffer
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCRXIFG))
    a696:	0d 4c       	mov	r12,	r13	;
    a698:	3d 50 2c 00 	add	#44,	r13	;#0x002c
{
    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;

    //Wait for Stop to finish
    while(HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTP)
    a69c:	30 40 a6 a6 	br	#0xa6a6		;
    {
        // Wait for RX buffer
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCRXIFG))
    a6a0:	9d b3 00 00 	bit	#1,	0(r13)	;r3 As==01
    a6a4:	fd 27       	jz	$-4      	;abs 0xa6a0
{
    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;

    //Wait for Stop to finish
    while(HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTP)
    a6a6:	ae b2 00 00 	bit	#4,	0(r14)	;r2 As==10
    a6aa:	fa 23       	jnz	$-10     	;abs 0xa6a0
        }
    }

    //Capture data from receive buffer after setting stop bit due to
    //MSP430 I2C critical timing.
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a6ac:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a6b0:	30 41       	ret			

0000a6b2 <EUSCI_B_I2C_masterReceiveMultiByteFinishWithTimeout>:

bool EUSCI_B_I2C_masterReceiveMultiByteFinishWithTimeout(uint16_t baseAddress,
                                                         uint8_t *txData,
                                                         uint32_t timeout)
{
    a6b2:	0a 12       	push	r10		;
    a6b4:	09 12       	push	r9		;
    a6b6:	08 12       	push	r8		;
    a6b8:	08 4e       	mov	r14,	r8	;
    a6ba:	09 4f       	mov	r15,	r9	;
    uint32_t timeout2 = timeout;

    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a6bc:	0e 4c       	mov	r12,	r14	;
    a6be:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10

    //Wait for Stop to finish
    while((HWREG16(baseAddress + OFS_UCBxCTLW0) & UCTXSTP) && --timeout)
    a6c2:	0a 48       	mov	r8,	r10	;
    a6c4:	0b 4f       	mov	r15,	r11	;
    a6c6:	ae b2 00 00 	bit	#4,	0(r14)	;r2 As==10
    a6ca:	09 24       	jz	$+20     	;abs 0xa6de
    a6cc:	3a 53       	add	#-1,	r10	;r3 As==11
    a6ce:	3b 63       	addc	#-1,	r11	;r3 As==11
    a6d0:	0f 4a       	mov	r10,	r15	;
    a6d2:	0f db       	bis	r11,	r15	;
    a6d4:	0f 93       	cmp	#0,	r15	;r3 As==00
    a6d6:	f7 23       	jnz	$-16     	;abs 0xa6c6
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a6d8:	0c 43       	clr	r12		;
    a6da:	30 40 20 a7 	br	#0xa720		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout == 0)
    a6de:	0e 4a       	mov	r10,	r14	;
    a6e0:	0e db       	bis	r11,	r14	;
    a6e2:	0e 93       	cmp	#0,	r14	;r3 As==00
    a6e4:	19 24       	jz	$+52     	;abs 0xa718
    {
        return (STATUS_FAIL);
    }

    // Wait for RX buffer
    while((!(HWREG16(baseAddress + OFS_UCBxIFG) & UCRXIFG)) && --timeout2)
    a6e6:	0f 4c       	mov	r12,	r15	;
    a6e8:	3f 50 2c 00 	add	#44,	r15	;#0x002c
    a6ec:	9f b3 00 00 	bit	#1,	0(r15)	;r3 As==01
    a6f0:	09 20       	jnz	$+20     	;abs 0xa704
    a6f2:	38 53       	add	#-1,	r8	;r3 As==11
    a6f4:	39 63       	addc	#-1,	r9	;r3 As==11
    a6f6:	0e 48       	mov	r8,	r14	;
    a6f8:	0e d9       	bis	r9,	r14	;
    a6fa:	0e 93       	cmp	#0,	r14	;r3 As==00
    a6fc:	f7 23       	jnz	$-16     	;abs 0xa6ec
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a6fe:	0c 43       	clr	r12		;
    a700:	30 40 20 a7 	br	#0xa720		;
    {
        ;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    a704:	0e 48       	mov	r8,	r14	;
    a706:	0e d9       	bis	r9,	r14	;
    a708:	0e 93       	cmp	#0,	r14	;r3 As==00
    a70a:	09 24       	jz	$+20     	;abs 0xa71e
        return (STATUS_FAIL);
    }

    //Capture data from receive buffer after setting stop bit due to
    //MSP430 I2C critical timing.
    *txData = (HWREG8(baseAddress + OFS_UCBxRXBUF));
    a70c:	dd 4c 0c 00 	mov.b	12(r12),0(r13)	;0x0000c
    a710:	00 00 

    return (STATUS_SUCCESS);
    a712:	1c 43       	mov	#1,	r12	;r3 As==01
    a714:	30 40 20 a7 	br	#0xa720		;
    }

    //Check if transfer timed out
    if(timeout == 0)
    {
        return (STATUS_FAIL);
    a718:	0c 43       	clr	r12		;
    a71a:	30 40 20 a7 	br	#0xa720		;
    }

    //Check if transfer timed out
    if(timeout2 == 0)
    {
        return (STATUS_FAIL);
    a71e:	0c 43       	clr	r12		;
    //Capture data from receive buffer after setting stop bit due to
    //MSP430 I2C critical timing.
    *txData = (HWREG8(baseAddress + OFS_UCBxRXBUF));

    return (STATUS_SUCCESS);
}
    a720:	30 40 70 d1 	br	#0xd170		;

0000a724 <EUSCI_B_I2C_masterReceiveMultiByteStop>:

void EUSCI_B_I2C_masterReceiveMultiByteStop(uint16_t baseAddress)
{
    //Send stop condition.
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCTXSTP;
    a724:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10
}
    a728:	30 41       	ret			

0000a72a <EUSCI_B_I2C_enableMultiMasterMode>:

void EUSCI_B_I2C_enableMultiMasterMode(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a72a:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCMM;
    a72e:	bc d0 00 20 	bis	#8192,	0(r12)	;#0x2000
    a732:	00 00 
}
    a734:	30 41       	ret			

0000a736 <EUSCI_B_I2C_disableMultiMasterMode>:

void EUSCI_B_I2C_disableMultiMasterMode(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a736:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~UCMM;
    a73a:	bc f0 ff df 	and	#57343,	0(r12)	;#0xdfff
    a73e:	00 00 
}
    a740:	30 41       	ret			

0000a742 <EUSCI_B_I2C_masterReceiveSingle>:

uint8_t EUSCI_B_I2C_masterReceiveSingle(uint16_t baseAddress)
{
    //Polling RXIFG0 if RXIE is not enabled
    if(!(HWREG16(baseAddress + OFS_UCBxIE) & UCRXIE0))
    a742:	9c b3 2a 00 	bit	#1,	42(r12)	;r3 As==01, 0x002a
    a746:	06 20       	jnz	$+14     	;abs 0xa754
    {
        while(!(HWREG16(baseAddress + OFS_UCBxIFG) & UCRXIFG0))
    a748:	0d 4c       	mov	r12,	r13	;
    a74a:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    a74e:	9d b3 00 00 	bit	#1,	0(r13)	;r3 As==01
    a752:	fd 27       	jz	$-4      	;abs 0xa74e
            ;
        }
    }

    //Read a byte.
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a754:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a758:	30 41       	ret			

0000a75a <EUSCI_B_I2C_getReceiveBufferAddress>:

uint32_t EUSCI_B_I2C_getReceiveBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCBxRXBUF);
}
    a75a:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    a75e:	0d 43       	clr	r13		;
    a760:	30 41       	ret			

0000a762 <EUSCI_B_I2C_getTransmitBufferAddress>:

uint32_t EUSCI_B_I2C_getTransmitBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCBxTXBUF);
}
    a762:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a766:	0d 43       	clr	r13		;
    a768:	30 41       	ret			

0000a76a <EUSCI_B_SPI_initMaster>:

#include <assert.h>

void EUSCI_B_SPI_initMaster(uint16_t baseAddress,
                            EUSCI_B_SPI_initMasterParam *param)
{
    a76a:	0a 12       	push	r10		;
    a76c:	09 12       	push	r9		;
    a76e:	08 12       	push	r8		;
    a770:	0a 4c       	mov	r12,	r10	;
    a772:	09 4d       	mov	r13,	r9	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a774:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Reset OFS_UCBxCTLW0 values
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCCKPH + UCCKPL + UC7BIT + UCMSB +
    a778:	bc f0 ff 00 	and	#255,	0(r12)	;#0x00ff
    a77c:	00 00 
                                              UCMST + UCMODE_3 + UCSYNC);

    //Reset OFS_UCBxCTLW0 values
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSSEL_3);
    a77e:	bc f0 3f ff 	and	#65343,	0(r12)	;#0xff3f
    a782:	00 00 

    //Select Clock
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= param->selectClockSource;
    a784:	6c 4d       	mov.b	@r13,	r12	;
    a786:	8a dc 00 00 	bis	r12,	0(r10)	;

    HWREG16(baseAddress + OFS_UCBxBRW) =
    a78a:	08 4a       	mov	r10,	r8	;
    a78c:	38 50 06 00 	add	#6,	r8	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);
    a790:	1c 4d 02 00 	mov	2(r13),	r12	;
    a794:	1d 4d 04 00 	mov	4(r13),	r13	;
    a798:	1e 49 06 00 	mov	6(r9),	r14	;
    a79c:	1f 49 08 00 	mov	8(r9),	r15	;
    a7a0:	b0 12 86 d0 	call	#53382		;#0xd086
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSSEL_3);

    //Select Clock
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= param->selectClockSource;

    HWREG16(baseAddress + OFS_UCBxBRW) =
    a7a4:	88 4c 00 00 	mov	r12,	0(r8)	;
     * UCMST = Master mode
     * UCSYNC = Synchronous mode
     * UCMODE_0 = 3-pin SPI
     */
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (
        param->msbFirst +
    a7a8:	1c 49 0a 00 	mov	10(r9),	r12	;0x0000a
    a7ac:	1c 59 0c 00 	add	12(r9),	r12	;0x0000c
    a7b0:	3c 50 00 09 	add	#2304,	r12	;#0x0900
    a7b4:	1c 59 0e 00 	add	14(r9),	r12	;0x0000e
        param->clockPhase +
        param->clockPolarity +
        UCMST +
        UCSYNC +
    a7b8:	1c 59 10 00 	add	16(r9),	r12	;0x00010
     * Clock phase select, polarity, msb
     * UCMST = Master mode
     * UCSYNC = Synchronous mode
     * UCMODE_0 = 3-pin SPI
     */
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (
    a7bc:	8a dc 00 00 	bis	r12,	0(r10)	;
        param->clockPolarity +
        UCMST +
        UCSYNC +
        param->spiMode
        );
}
    a7c0:	30 40 70 d1 	br	#0xd170		;

0000a7c4 <EUSCI_B_SPI_select4PinFunctionality>:

void EUSCI_B_SPI_select4PinFunctionality(uint16_t baseAddress,
                                         uint8_t select4PinFunctionality)
{
    a7c4:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~UCSTEM;
    a7c8:	ac c3 00 00 	bic	#2,	0(r12)	;r3 As==10
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= select4PinFunctionality;
    a7cc:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    a7d0:	30 41       	ret			

0000a7d2 <EUSCI_B_SPI_changeMasterClock>:

void EUSCI_B_SPI_changeMasterClock(uint16_t baseAddress,
                                   EUSCI_B_SPI_changeMasterClockParam *param)
{
    a7d2:	0a 12       	push	r10		;
    a7d4:	09 12       	push	r9		;
    a7d6:	0a 4c       	mov	r12,	r10	;
    a7d8:	0e 4d       	mov	r13,	r14	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a7da:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    HWREG16(baseAddress + OFS_UCBxBRW) =
    a7de:	09 4c       	mov	r12,	r9	;
    a7e0:	39 50 06 00 	add	#6,	r9	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);
    a7e4:	2c 4d       	mov	@r13,	r12	;
    a7e6:	1d 4d 02 00 	mov	2(r13),	r13	;
    a7ea:	1f 4e 06 00 	mov	6(r14),	r15	;
    a7ee:	1e 4e 04 00 	mov	4(r14),	r14	;
    a7f2:	b0 12 86 d0 	call	#53382		;#0xd086
                                   EUSCI_B_SPI_changeMasterClockParam *param)
{
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;

    HWREG16(baseAddress + OFS_UCBxBRW) =
    a7f6:	89 4c 00 00 	mov	r12,	0(r9)	;
        (uint16_t)(param->clockSourceFrequency / param->desiredSpiClock);

    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSWRST);
    a7fa:	9a c3 00 00 	bic	#1,	0(r10)	;r3 As==01
}
    a7fe:	30 40 72 d1 	br	#0xd172		;

0000a802 <EUSCI_B_SPI_initSlave>:

void EUSCI_B_SPI_initSlave(uint16_t baseAddress,
                           EUSCI_B_SPI_initSlaveParam *param)
{
    //Disable USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a802:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    //Reset OFS_UCBxCTLW0 register
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCMSB +
    a806:	bc f0 ff 01 	and	#511,	0(r12)	;#0x01ff
    a80a:	00 00 
                                              UCCKPH +
                                              UCMODE_3
                                              );

    //Clock polarity, phase select, msbFirst, SYNC, Mode0
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (param->clockPhase +
    a80c:	1e 4d 02 00 	mov	2(r13),	r14	;
    a810:	1e 5d 04 00 	add	4(r13),	r14	;
    a814:	3e 50 00 01 	add	#256,	r14	;#0x0100
    a818:	2e 5d       	add	@r13,	r14	;
                                             param->clockPolarity +
                                             param->msbFirst +
                                             UCSYNC +
    a81a:	1e 5d 06 00 	add	6(r13),	r14	;
                                              UCCKPH +
                                              UCMODE_3
                                              );

    //Clock polarity, phase select, msbFirst, SYNC, Mode0
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (param->clockPhase +
    a81e:	8c de 00 00 	bis	r14,	0(r12)	;
                                             param->clockPolarity +
                                             param->msbFirst +
                                             UCSYNC +
                                             param->spiMode
                                             );
}
    a822:	30 41       	ret			

0000a824 <EUSCI_B_SPI_changeClockPhasePolarity>:
void EUSCI_B_SPI_changeClockPhasePolarity(uint16_t baseAddress,
                                          uint16_t clockPhase,
                                          uint16_t clockPolarity)
{
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a824:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01

    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCCKPH + UCCKPL);
    a828:	bc f0 ff 3f 	and	#16383,	0(r12)	;#0x3fff
    a82c:	00 00 

    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (
        clockPhase +
    a82e:	0d 5e       	add	r14,	r13	;
    //Disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;

    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCCKPH + UCCKPL);

    HWREG16(baseAddress + OFS_UCBxCTLW0) |= (
    a830:	8c dd 00 00 	bis	r13,	0(r12)	;
        clockPhase +
        clockPolarity
        );

    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSWRST);
    a834:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a838:	30 41       	ret			

0000a83a <EUSCI_B_SPI_transmitData>:

void EUSCI_B_SPI_transmitData(uint16_t baseAddress,
                              uint8_t transmitData)
{
    HWREG16(baseAddress + OFS_UCBxTXBUF) = transmitData;
    a83a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    a83e:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e
}
    a842:	30 41       	ret			

0000a844 <EUSCI_B_SPI_receiveData>:

uint8_t EUSCI_B_SPI_receiveData(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_UCBxRXBUF));
    a844:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
}
    a848:	30 41       	ret			

0000a84a <EUSCI_B_SPI_enableInterrupt>:

void EUSCI_B_SPI_enableInterrupt(uint16_t baseAddress,
                                 uint8_t mask)
{
    a84a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCBxIE) |= mask;
    a84e:	8c dd 2a 00 	bis	r13,	42(r12)	; 0x002a
}
    a852:	30 41       	ret			

0000a854 <EUSCI_B_SPI_disableInterrupt>:

void EUSCI_B_SPI_disableInterrupt(uint16_t baseAddress,
                                  uint8_t mask)
{
    a854:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCBxIE) &= ~mask;
    a858:	8c cd 2a 00 	bic	r13,	42(r12)	; 0x002a
}
    a85c:	30 41       	ret			

0000a85e <EUSCI_B_SPI_getInterruptStatus>:

uint8_t EUSCI_B_SPI_getInterruptStatus(uint16_t baseAddress,
                                       uint8_t mask)
{
    return (HWREG16(baseAddress + OFS_UCBxIFG) & mask);
    a85e:	1c 4c 2c 00 	mov	44(r12),r12	;0x0002c
}
    a862:	4c fd       	and.b	r13,	r12	;
    a864:	30 41       	ret			

0000a866 <EUSCI_B_SPI_clearInterrupt>:

void EUSCI_B_SPI_clearInterrupt(uint16_t baseAddress,
                                uint8_t mask)
{
    a866:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    HWREG16(baseAddress + OFS_UCBxIFG) &= ~mask;
    a86a:	8c cd 2c 00 	bic	r13,	44(r12)	; 0x002c
}
    a86e:	30 41       	ret			

0000a870 <EUSCI_B_SPI_enable>:

void EUSCI_B_SPI_enable(uint16_t baseAddress)
{
    //Reset the UCSWRST bit to enable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) &= ~(UCSWRST);
    a870:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    a874:	30 41       	ret			

0000a876 <EUSCI_B_SPI_disable>:

void EUSCI_B_SPI_disable(uint16_t baseAddress)
{
    //Set the UCSWRST bit to disable the USCI Module
    HWREG16(baseAddress + OFS_UCBxCTLW0) |= UCSWRST;
    a876:	9c d3 00 00 	bis	#1,	0(r12)	;r3 As==01
}
    a87a:	30 41       	ret			

0000a87c <EUSCI_B_SPI_getReceiveBufferAddress>:

uint32_t EUSCI_B_SPI_getReceiveBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCBxRXBUF);
}
    a87c:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    a880:	0d 43       	clr	r13		;
    a882:	30 41       	ret			

0000a884 <EUSCI_B_SPI_getTransmitBufferAddress>:

uint32_t EUSCI_B_SPI_getTransmitBufferAddress(uint16_t baseAddress)
{
    return (baseAddress + OFS_UCBxTXBUF);
}
    a884:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    a888:	0d 43       	clr	r13		;
    a88a:	30 41       	ret			

0000a88c <EUSCI_B_SPI_isBusy>:

uint16_t EUSCI_B_SPI_isBusy(uint16_t baseAddress)
{
    //Return the bus busy status.
    return (HWREG16(baseAddress + OFS_UCBxSTATW) & UCBUSY);
}
    a88c:	1c 4c 08 00 	mov	8(r12),	r12	;
    a890:	1c f3       	and	#1,	r12	;r3 As==01
    a892:	30 41       	ret			

0000a894 <FlashCtl_eraseSegment>:

#include <assert.h>

void FlashCtl_eraseSegment(uint8_t *flash_ptr){
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a894:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a898:	2c 01 

    //Set Erase bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + ERASE;
    a89a:	b2 40 02 a5 	mov	#42242,	&0x0128	;#0xa502
    a89e:	28 01 

    //Dummy write to erase Flash seg
    *flash_ptr = 0;
    a8a0:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

    //test busy
    while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a8a4:	3c 40 2c 01 	mov	#300,	r12	;#0x012c
    a8a8:	dc b3 00 00 	bit.b	#1,	0(r12)	;r3 As==01
    a8ac:	fd 23       	jnz	$-4      	;abs 0xa8a8
    {
        ;
    }

    //Clear ERASE bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    a8ae:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    a8b2:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    a8b4:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    a8b8:	2c 01 
}
    a8ba:	30 41       	ret			

0000a8bc <FlashCtl_performMassErase>:

void FlashCtl_performMassErase(uint8_t *flash_ptr){
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a8bc:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a8c0:	2c 01 

    while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a8c2:	3d 40 2c 01 	mov	#300,	r13	;#0x012c
    a8c6:	dd b3 00 00 	bit.b	#1,	0(r13)	;r3 As==01
    a8ca:	fd 23       	jnz	$-4      	;abs 0xa8c6
    {
        ;
    }

    //Set MERAS bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + MERAS + ERASE;
    a8cc:	b2 40 06 a5 	mov	#42246,	&0x0128	;#0xa506
    a8d0:	28 01 

    //Dummy write to erase Flash seg
    *flash_ptr = 0;
    a8d2:	cc 43 00 00 	mov.b	#0,	0(r12)	;r3 As==00

    //test busy
    while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a8d6:	3c 40 2c 01 	mov	#300,	r12	;#0x012c
    a8da:	dc b3 00 00 	bit.b	#1,	0(r12)	;r3 As==01
    a8de:	fd 23       	jnz	$-4      	;abs 0xa8da
    {
        ;
    }

    //Clear MERAS bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    a8e0:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    a8e4:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    a8e6:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    a8ea:	2c 01 
}
    a8ec:	30 41       	ret			

0000a8ee <FlashCtl_performEraseCheck>:
bool FlashCtl_performEraseCheck(uint8_t *flash_ptr,
                                uint16_t numberOfBytes)
{
    uint16_t i;

    for(i = 0; i < numberOfBytes; i++)
    a8ee:	0d 93       	cmp	#0,	r13	;r3 As==00
    a8f0:	11 24       	jz	$+36     	;abs 0xa914
    {
        //was erasing successfull?
        if((*(flash_ptr + i)) != 0xFF)
    a8f2:	fc 93 00 00 	cmp.b	#-1,	0(r12)	;r3 As==11
    a8f6:	11 20       	jnz	$+36     	;abs 0xa91a
    a8f8:	0e 4c       	mov	r12,	r14	;
    a8fa:	1e 53       	inc	r14		;
    a8fc:	0d 5c       	add	r12,	r13	;
    a8fe:	30 40 0a a9 	br	#0xa90a		;
    a902:	1e 53       	inc	r14		;
    a904:	fe 93 ff ff 	cmp.b	#-1,	-1(r14)	;r3 As==11, 0xffff
    a908:	0b 20       	jnz	$+24     	;abs 0xa920
bool FlashCtl_performEraseCheck(uint8_t *flash_ptr,
                                uint16_t numberOfBytes)
{
    uint16_t i;

    for(i = 0; i < numberOfBytes; i++)
    a90a:	0e 9d       	cmp	r13,	r14	;
    a90c:	fa 23       	jnz	$-10     	;abs 0xa902
        if((*(flash_ptr + i)) != 0xFF)
        {
            return (STATUS_FAIL);
        }
    }
    return (STATUS_SUCCESS);
    a90e:	1c 43       	mov	#1,	r12	;r3 As==01
    a910:	30 40 22 a9 	br	#0xa922		;
    a914:	1c 43       	mov	#1,	r12	;r3 As==01
    a916:	30 40 22 a9 	br	#0xa922		;
    for(i = 0; i < numberOfBytes; i++)
    {
        //was erasing successfull?
        if((*(flash_ptr + i)) != 0xFF)
        {
            return (STATUS_FAIL);
    a91a:	0c 43       	clr	r12		;
    a91c:	30 40 22 a9 	br	#0xa922		;
    a920:	0c 43       	clr	r12		;
        }
    }
    return (STATUS_SUCCESS);
}
    a922:	30 41       	ret			

0000a924 <FlashCtl_write8>:
void FlashCtl_write8(uint8_t *data_ptr,
                     uint8_t *flash_ptr,
                     uint16_t count)
{
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a924:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a928:	2c 01 

    //Enable byte/word write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;
    a92a:	b2 40 40 a5 	mov	#42304,	&0x0128	;#0xa540
    a92e:	28 01 

    while(count > 0)
    a930:	0e 93       	cmp	#0,	r14	;r3 As==00
    a932:	0d 24       	jz	$+28     	;abs 0xa94e
    a934:	0b 4c       	mov	r12,	r11	;
    a936:	0c 5e       	add	r14,	r12	;
    {
        //test busy
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a938:	3f 40 2c 01 	mov	#300,	r15	;#0x012c
    a93c:	df b3 00 00 	bit.b	#1,	0(r15)	;r3 As==01
    a940:	fd 23       	jnz	$-4      	;abs 0xa93c
        {
            ;
        }

        //Write to Flash
        *flash_ptr++ = *data_ptr++;
    a942:	ed 4b 00 00 	mov.b	@r11,	0(r13)	;
    a946:	1b 53       	inc	r11		;
    a948:	1d 53       	inc	r13		;
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;

    //Enable byte/word write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;

    while(count > 0)
    a94a:	0b 9c       	cmp	r12,	r11	;
    a94c:	f7 23       	jnz	$-16     	;abs 0xa93c
        *flash_ptr++ = *data_ptr++;
        count--;
    }

    //Clear WRT bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    a94e:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    a952:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    a954:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    a958:	2c 01 
}
    a95a:	30 41       	ret			

0000a95c <FlashCtl_write16>:
void FlashCtl_write16(uint16_t *data_ptr,
                      uint16_t *flash_ptr,
                      uint16_t count)
{
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a95c:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a960:	2c 01 

    //Enable byte/word write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;
    a962:	b2 40 40 a5 	mov	#42304,	&0x0128	;#0xa540
    a966:	28 01 

    while(count > 0)
    a968:	0e 93       	cmp	#0,	r14	;r3 As==00
    a96a:	0c 24       	jz	$+26     	;abs 0xa984
    {
        //test busy
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a96c:	3f 40 2c 01 	mov	#300,	r15	;#0x012c
    a970:	df b3 00 00 	bit.b	#1,	0(r15)	;r3 As==01
    a974:	fd 23       	jnz	$-4      	;abs 0xa970
        {
            ;
        }

        //Write to Flash
        *flash_ptr++ = *data_ptr++;
    a976:	ad 4c 00 00 	mov	@r12,	0(r13)	;
        count--;
    a97a:	3e 53       	add	#-1,	r14	;r3 As==11
    a97c:	2c 53       	incd	r12		;
    a97e:	2d 53       	incd	r13		;
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;

    //Enable byte/word write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;

    while(count > 0)
    a980:	0e 93       	cmp	#0,	r14	;r3 As==00
    a982:	f6 23       	jnz	$-18     	;abs 0xa970
        *flash_ptr++ = *data_ptr++;
        count--;
    }

    //Clear WRT bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    a984:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    a988:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    a98a:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    a98e:	2c 01 
}
    a990:	30 41       	ret			

0000a992 <FlashCtl_write32>:

void FlashCtl_write32(uint32_t *data_ptr,
                      uint32_t *flash_ptr,
                      uint16_t count)
{
    a992:	0a 12       	push	r10		;
    //Create 16-bit pointers and assign to same values as data_ptr and flash_ptr
    uint16_t *data_ptr16 = (uint16_t*)data_ptr;
    uint16_t *flash_ptr16 = (uint16_t*)flash_ptr;
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a994:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a998:	2c 01 

    //Enable write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;
    a99a:	b2 40 40 a5 	mov	#42304,	&0x0128	;#0xa540
    a99e:	28 01 

    while(count > 0)
    a9a0:	0e 93       	cmp	#0,	r14	;r3 As==00
    a9a2:	17 24       	jz	$+48     	;abs 0xa9d2
    a9a4:	0a 4c       	mov	r12,	r10	;
    a9a6:	2a 53       	incd	r10		;
    a9a8:	0b 4d       	mov	r13,	r11	;
    a9aa:	2b 53       	incd	r11		;
    {
        //Test the busy bit
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a9ac:	3f 40 2c 01 	mov	#300,	r15	;#0x012c
    a9b0:	df b3 00 00 	bit.b	#1,	0(r15)	;r3 As==01
    a9b4:	fd 23       	jnz	$-4      	;abs 0xa9b0
        {
            ;
        }

        //Write to the flash
        *(uint16_t*)flash_ptr16++ = *data_ptr16++;
    a9b6:	ad 4c 00 00 	mov	@r12,	0(r13)	;

        //Test the busy bit
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    a9ba:	df b3 00 00 	bit.b	#1,	0(r15)	;r3 As==01
    a9be:	fd 23       	jnz	$-4      	;abs 0xa9ba
    a9c0:	2d 52       	add	#4,	r13	;r2 As==10
    a9c2:	2c 52       	add	#4,	r12	;r2 As==10
        {
            ;
        }

        //Write to the flash
        *(uint16_t*)flash_ptr16++ = *data_ptr16++;
    a9c4:	ab 4a 00 00 	mov	@r10,	0(r11)	;

        count--;
    a9c8:	3e 53       	add	#-1,	r14	;r3 As==11
    a9ca:	2a 52       	add	#4,	r10	;r2 As==10
    a9cc:	2b 52       	add	#4,	r11	;r2 As==10
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;

    //Enable write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;

    while(count > 0)
    a9ce:	0e 93       	cmp	#0,	r14	;r3 As==00
    a9d0:	ef 23       	jnz	$-32     	;abs 0xa9b0

        count--;
    }

    //Clear BLKWRT bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    a9d2:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    a9d6:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    a9d8:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    a9dc:	2c 01 
}
    a9de:	3a 41       	pop	r10		;
    a9e0:	30 41       	ret			

0000a9e2 <FlashCtl_fillMemory32>:

void FlashCtl_fillMemory32(uint32_t value,
                           uint32_t *flash_ptr,
                           uint16_t count)
{
    a9e2:	0a 12       	push	r10		;
    a9e4:	09 12       	push	r9		;
    a9e6:	08 12       	push	r8		;
    a9e8:	0a 4e       	mov	r14,	r10	;
    a9ea:	09 4f       	mov	r15,	r9	;
    //Create a 16-bit pointer and assign to same value as flash_ptr
    uint16_t *flash_ptr16 = (uint16_t*)flash_ptr;

    //Create two 16-bit data values from value
    uint16_t value_LSW = (uint16_t)value;
    a9ec:	08 4c       	mov	r12,	r8	;
    uint16_t value_MSW = (uint16_t)(value >> 16);
    a9ee:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    a9f2:	b0 12 0e d3 	call	#54030		;#0xd30e
    //Clear Lock bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY;
    a9f6:	b2 40 00 a5 	mov	#42240,	&0x012c	;#0xa500
    a9fa:	2c 01 

    //Enable write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;
    a9fc:	b2 40 40 a5 	mov	#42304,	&0x0128	;#0xa540
    aa00:	28 01 

    //test busy
    while(count > 0)
    aa02:	09 93       	cmp	#0,	r9	;r3 As==00
    aa04:	13 24       	jz	$+40     	;abs 0xaa2c
    aa06:	0e 4a       	mov	r10,	r14	;
    aa08:	2e 53       	incd	r14		;
    {
        //Test the busy bit
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    aa0a:	3d 40 2c 01 	mov	#300,	r13	;#0x012c
    aa0e:	dd b3 00 00 	bit.b	#1,	0(r13)	;r3 As==01
    aa12:	fd 23       	jnz	$-4      	;abs 0xaa0e
        {
            ;
        }

        //Write least-significant 16 bits to the flash
        *(uint16_t*)flash_ptr16++ = value_LSW;
    aa14:	8a 48 00 00 	mov	r8,	0(r10)	;

        //Test the busy bit
        while(HWREG8(FLASH_BASE + OFS_FCTL3) & BUSY)
    aa18:	dd b3 00 00 	bit.b	#1,	0(r13)	;r3 As==01
    aa1c:	fd 23       	jnz	$-4      	;abs 0xaa18
    aa1e:	2a 52       	add	#4,	r10	;r2 As==10
        {
            ;
        }

        //Write most-significant 16 bits to the flash
        *(uint16_t*)flash_ptr16++ = value_MSW;
    aa20:	8e 4c 00 00 	mov	r12,	0(r14)	;

        count--;
    aa24:	39 53       	add	#-1,	r9	;r3 As==11
    aa26:	2e 52       	add	#4,	r14	;r2 As==10

    //Enable write mode
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY + WRT;

    //test busy
    while(count > 0)
    aa28:	09 93       	cmp	#0,	r9	;r3 As==00
    aa2a:	f1 23       	jnz	$-28     	;abs 0xaa0e

        count--;
    }

    //Clear BLKWRT bit
    HWREG16(FLASH_BASE + OFS_FCTL1) = FWKEY;
    aa2c:	b2 40 00 a5 	mov	#42240,	&0x0128	;#0xa500
    aa30:	28 01 

    //Set LOCK bit
    HWREG16(FLASH_BASE + OFS_FCTL3) = FWKEY + LOCK;
    aa32:	b2 40 10 a5 	mov	#42256,	&0x012c	;#0xa510
    aa36:	2c 01 
}
    aa38:	30 40 70 d1 	br	#0xd170		;

0000aa3c <FlashCtl_getStatus>:

uint8_t FlashCtl_getStatus(uint8_t mask)
{
    return ((HWREG8(FLASH_BASE + OFS_FCTL3) & mask));
}
    aa3c:	5c f2 2c 01 	and.b	&0x012c,r12	;0x012c
    aa40:	30 41       	ret			

0000aa42 <FlashCtl_lockInfo>:

void FlashCtl_lockInfo(void)
{
    //Disable global interrupts while doing RMW operation on LOCKSEG bit
    uint16_t gieStatus;                         //Local variable to store GIE status
    gieStatus = __get_SR_register() & GIE;      //Store current SR register
    aa42:	0c 42       	mov	r2,	r12	;
    __disable_interrupt();                      //Disable global interrupt
    aa44:	32 c2       	dint			

    //Set the LOCKSEG bit in FCTL3.
    //Since LOCKSEG toggles when you write a 1 (and writing 0 has no effect),
    //read the register, XOR with LOCKSEG mask, mask the lower byte, and write it back.
    HWREG16(FLASH_BASE + OFS_FCTL3) =
        FWKEY + ((HWREG16(FLASH_BASE + OFS_FCTL3) ^ LOCKSEG) & 0xFF);
    aa46:	3e 40 2c 01 	mov	#300,	r14	;#0x012c
    aa4a:	2d 4e       	mov	@r14,	r13	;
    aa4c:	3d e0 40 00 	xor	#64,	r13	;#0x0040
    aa50:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    __disable_interrupt();                      //Disable global interrupt

    //Set the LOCKSEG bit in FCTL3.
    //Since LOCKSEG toggles when you write a 1 (and writing 0 has no effect),
    //read the register, XOR with LOCKSEG mask, mask the lower byte, and write it back.
    HWREG16(FLASH_BASE + OFS_FCTL3) =
    aa54:	3d 50 00 a5 	add	#42240,	r13	;#0xa500
    aa58:	8e 4d 00 00 	mov	r13,	0(r14)	;

void FlashCtl_lockInfo(void)
{
    //Disable global interrupts while doing RMW operation on LOCKSEG bit
    uint16_t gieStatus;                         //Local variable to store GIE status
    gieStatus = __get_SR_register() & GIE;      //Store current SR register
    aa5c:	3c f2       	and	#8,	r12	;r2 As==11
    //read the register, XOR with LOCKSEG mask, mask the lower byte, and write it back.
    HWREG16(FLASH_BASE + OFS_FCTL3) =
        FWKEY + ((HWREG16(FLASH_BASE + OFS_FCTL3) ^ LOCKSEG) & 0xFF);

    //Reinstate SR register to restore global interrupt enable status
    __bis_SR_register(gieStatus);
    aa5e:	02 dc       	bis	r12,	r2	;
}
    aa60:	30 41       	ret			

0000aa62 <FlashCtl_unlockInfo>:

void FlashCtl_unlockInfo(void)
{
    //Disable global interrupts while doing RMW operation on LOCKSEG bit
    uint16_t gieStatus;                         //Local variable to store GIE status
    gieStatus = __get_SR_register() & GIE;      //Store current SR register
    aa62:	0c 42       	mov	r2,	r12	;
    __disable_interrupt();                      //Disable global interrupt
    aa64:	32 c2       	dint			

    //Clear the LOCKSEG bit in FCTL3.
    //Since LOCKSEG toggles when you write a 1 (and writing 0 has no effect),
    //read the register, mask the lower byte, and write it back.
    HWREG16(FLASH_BASE +
            OFS_FCTL3) = FWKEY + (HWREG16(FLASH_BASE + OFS_FCTL3) & 0xFF);
    aa66:	1d 42 2c 01 	mov	&0x012c,r13	;0x012c
    aa6a:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    aa6e:	3d 50 00 a5 	add	#42240,	r13	;#0xa500
    aa72:	82 4d 2c 01 	mov	r13,	&0x012c	;

void FlashCtl_unlockInfo(void)
{
    //Disable global interrupts while doing RMW operation on LOCKSEG bit
    uint16_t gieStatus;                         //Local variable to store GIE status
    gieStatus = __get_SR_register() & GIE;      //Store current SR register
    aa76:	3c f2       	and	#8,	r12	;r2 As==11
    //read the register, mask the lower byte, and write it back.
    HWREG16(FLASH_BASE +
            OFS_FCTL3) = FWKEY + (HWREG16(FLASH_BASE + OFS_FCTL3) & 0xFF);

    //Reinstate SR register to restore global interrupt enable status
    __bis_SR_register(gieStatus);
    aa78:	02 dc       	bis	r12,	r2	;
}
    aa7a:	30 41       	ret			

0000aa7c <FlashCtl_setupClock>:

uint8_t FlashCtl_setupClock(uint32_t clockTargetFreq,
                            uint32_t clockSourceFreq,
                            uint16_t clockSource)
{
    aa7c:	0a 12       	push	r10		;
    aa7e:	0a 4c       	mov	r12,	r10	;
    aa80:	0b 4d       	mov	r13,	r11	;
    uint16_t divider;

    //Compute clock divider
    divider = (clockSourceFreq / clockTargetFreq);
    aa82:	0c 4e       	mov	r14,	r12	;
    aa84:	0d 4f       	mov	r15,	r13	;
    aa86:	0e 4a       	mov	r10,	r14	;
    aa88:	0f 4b       	mov	r11,	r15	;
    aa8a:	b0 12 86 d0 	call	#53382		;#0xd086

    // Divider must be between 1 and 64
    if(divider < 1 || divider > 64)
    aa8e:	3c 53       	add	#-1,	r12	;r3 As==11
    aa90:	3d 40 3f 00 	mov	#63,	r13	;#0x003f
    aa94:	0d 9c       	cmp	r12,	r13	;
    aa96:	0a 28       	jnc	$+22     	;abs 0xaaac
    aa98:	1d 41 04 00 	mov	4(r1),	r13	;
    aa9c:	3d 50 00 a5 	add	#42240,	r13	;#0xa500
    {
        divider = divider - 1;                      // Register value is FNx = (divider - 1)
    }

    //Set the clock source and divider in FCTL2 register
    HWREG16(FLASH_BASE + OFS_FCTL2) = FWKEY + clockSource + divider;
    aaa0:	0d 5c       	add	r12,	r13	;
    aaa2:	82 4d 2a 01 	mov	r13,	&0x012a	;

    return(STATUS_SUCCESS);
    aaa6:	1c 43       	mov	#1,	r12	;r3 As==01
    aaa8:	30 40 ae aa 	br	#0xaaae		;
    divider = (clockSourceFreq / clockTargetFreq);

    // Divider must be between 1 and 64
    if(divider < 1 || divider > 64)
    {
        return(STATUS_FAIL);                        // Divider is out of range
    aaac:	0c 43       	clr	r12		;

    //Set the clock source and divider in FCTL2 register
    HWREG16(FLASH_BASE + OFS_FCTL2) = FWKEY + clockSource + divider;

    return(STATUS_SUCCESS);
}
    aaae:	3a 41       	pop	r10		;
    aab0:	30 41       	ret			

0000aab2 <GPIO_setAsOutputPin>:
    0xFFFF
#endif
};

void GPIO_setAsOutputPin(uint8_t selectedPort,
                         uint16_t selectedPins) {
    aab2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    aab6:	0e 4c       	mov	r12,	r14	;
    aab8:	0e 5c       	add	r12,	r14	;
    aaba:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    aabe:	1c b3       	bit	#1,	r12	;r3 As==01
    aac0:	08 20       	jnz	$+18     	;abs 0xaad2
    {
        selectedPins <<= 8;
    aac2:	0d 5d       	rla	r13		;
    aac4:	0d 5d       	rla	r13		;
    aac6:	0d 5d       	rla	r13		;
    aac8:	0d 5d       	rla	r13		;
    aaca:	0d 5d       	rla	r13		;
    aacc:	0d 5d       	rla	r13		;
    aace:	0d 5d       	rla	r13		;
    aad0:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL0) &= ~selectedPins;
    aad2:	0c 4d       	mov	r13,	r12	;
    aad4:	3c e3       	inv	r12		;
    aad6:	8e fc 0a 00 	and	r12,	10(r14)	; 0x000a
    HWREG16(baseAddress + OFS_PASEL1) &= ~selectedPins;
    aada:	8e fc 0c 00 	and	r12,	12(r14)	; 0x000c
    HWREG16(baseAddress + OFS_PADIR) |= selectedPins;
    aade:	8e dd 04 00 	bis	r13,	4(r14)	;

    return;
}
    aae2:	30 41       	ret			

0000aae4 <GPIO_setAsInputPin>:

void GPIO_setAsInputPin(uint8_t selectedPort,
                        uint16_t selectedPins) {
    aae4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    aae8:	0e 4c       	mov	r12,	r14	;
    aaea:	0e 5c       	add	r12,	r14	;
    aaec:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    aaf0:	1c b3       	bit	#1,	r12	;r3 As==01
    aaf2:	08 20       	jnz	$+18     	;abs 0xab04
    {
        selectedPins <<= 8;
    aaf4:	0d 5d       	rla	r13		;
    aaf6:	0d 5d       	rla	r13		;
    aaf8:	0d 5d       	rla	r13		;
    aafa:	0d 5d       	rla	r13		;
    aafc:	0d 5d       	rla	r13		;
    aafe:	0d 5d       	rla	r13		;
    ab00:	0d 5d       	rla	r13		;
    ab02:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PASEL0) &= ~selectedPins;
    ab04:	3d e3       	inv	r13		;
    ab06:	8e fd 0a 00 	and	r13,	10(r14)	; 0x000a
    HWREG16(baseAddress + OFS_PASEL1) &= ~selectedPins;
    ab0a:	8e fd 0c 00 	and	r13,	12(r14)	; 0x000c
    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    ab0e:	8e fd 04 00 	and	r13,	4(r14)	;
}
    ab12:	30 41       	ret			

0000ab14 <GPIO_setAsPeripheralModuleFunctionOutputPin>:

void GPIO_setAsPeripheralModuleFunctionOutputPin(uint8_t selectedPort,
                                                 uint16_t selectedPins
                                                 ,
                                                 uint8_t mode) {
    ab14:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ab18:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ab1c:	0f 4c       	mov	r12,	r15	;
    ab1e:	0f 5c       	add	r12,	r15	;
    ab20:	1f 4f 02 82 	mov	-32254(r15),r15	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ab24:	1c b3       	bit	#1,	r12	;r3 As==01
    ab26:	08 20       	jnz	$+18     	;abs 0xab38
    {
        selectedPins <<= 8;
    ab28:	0d 5d       	rla	r13		;
    ab2a:	0d 5d       	rla	r13		;
    ab2c:	0d 5d       	rla	r13		;
    ab2e:	0d 5d       	rla	r13		;
    ab30:	0d 5d       	rla	r13		;
    ab32:	0d 5d       	rla	r13		;
    ab34:	0d 5d       	rla	r13		;
    ab36:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PADIR) |= selectedPins;
    ab38:	8f dd 04 00 	bis	r13,	4(r15)	;
    switch(mode)
    ab3c:	2e 93       	cmp	#2,	r14	;r3 As==10
    ab3e:	0b 24       	jz	$+24     	;abs 0xab56
    ab40:	3e 90 03 00 	cmp	#3,	r14	;
    ab44:	0e 24       	jz	$+30     	;abs 0xab62
    ab46:	1e 93       	cmp	#1,	r14	;r3 As==01
    ab48:	10 20       	jnz	$+34     	;abs 0xab6a
    {
    case GPIO_PRIMARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) |= selectedPins;
    ab4a:	8f dd 0a 00 	bis	r13,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) &= ~selectedPins;
    ab4e:	8f cd 0c 00 	bic	r13,	12(r15)	; 0x000c
        break;
    ab52:	30 40 6a ab 	br	#0xab6a		;
    case GPIO_SECONDARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) &= ~selectedPins;
    ab56:	8f cd 0a 00 	bic	r13,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) |= selectedPins;
    ab5a:	8f dd 0c 00 	bis	r13,	12(r15)	; 0x000c
        break;
    ab5e:	30 40 6a ab 	br	#0xab6a		;
    case GPIO_TERNARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) |= selectedPins;
    ab62:	8f dd 0a 00 	bis	r13,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) |= selectedPins;
    ab66:	8f dd 0c 00 	bis	r13,	12(r15)	; 0x000c
        break;
    }
}
    ab6a:	30 41       	ret			

0000ab6c <GPIO_setAsPeripheralModuleFunctionInputPin>:

void GPIO_setAsPeripheralModuleFunctionInputPin(uint8_t selectedPort,
                                                uint16_t selectedPins
                                                ,
                                                uint8_t mode) {
    ab6c:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ab70:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ab74:	0f 4c       	mov	r12,	r15	;
    ab76:	0f 5c       	add	r12,	r15	;
    ab78:	1f 4f 02 82 	mov	-32254(r15),r15	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ab7c:	1c b3       	bit	#1,	r12	;r3 As==01
    ab7e:	08 20       	jnz	$+18     	;abs 0xab90
    {
        selectedPins <<= 8;
    ab80:	0d 5d       	rla	r13		;
    ab82:	0d 5d       	rla	r13		;
    ab84:	0d 5d       	rla	r13		;
    ab86:	0d 5d       	rla	r13		;
    ab88:	0d 5d       	rla	r13		;
    ab8a:	0d 5d       	rla	r13		;
    ab8c:	0d 5d       	rla	r13		;
    ab8e:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PADIR) &= ~selectedPins;
    ab90:	0c 4d       	mov	r13,	r12	;
    ab92:	3c e3       	inv	r12		;
    ab94:	8f fc 04 00 	and	r12,	4(r15)	;
    switch(mode)
    ab98:	2e 93       	cmp	#2,	r14	;r3 As==10
    ab9a:	0b 24       	jz	$+24     	;abs 0xabb2
    ab9c:	3e 90 03 00 	cmp	#3,	r14	;
    aba0:	0e 24       	jz	$+30     	;abs 0xabbe
    aba2:	1e 93       	cmp	#1,	r14	;r3 As==01
    aba4:	10 20       	jnz	$+34     	;abs 0xabc6
    {
    case GPIO_PRIMARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) |= selectedPins;
    aba6:	8f dd 0a 00 	bis	r13,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) &= ~selectedPins;
    abaa:	8f fc 0c 00 	and	r12,	12(r15)	; 0x000c
        break;
    abae:	30 40 c6 ab 	br	#0xabc6		;
    case GPIO_SECONDARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) &= ~selectedPins;
    abb2:	8f fc 0a 00 	and	r12,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) |= selectedPins;
    abb6:	8f dd 0c 00 	bis	r13,	12(r15)	; 0x000c
        break;
    abba:	30 40 c6 ab 	br	#0xabc6		;
    case GPIO_TERNARY_MODULE_FUNCTION:
        HWREG16(baseAddress + OFS_PASEL0) |= selectedPins;
    abbe:	8f dd 0a 00 	bis	r13,	10(r15)	; 0x000a
        HWREG16(baseAddress + OFS_PASEL1) |= selectedPins;
    abc2:	8f dd 0c 00 	bis	r13,	12(r15)	; 0x000c
        break;
    }
}
    abc6:	30 41       	ret			

0000abc8 <GPIO_setOutputHighOnPin>:

void GPIO_setOutputHighOnPin(uint8_t selectedPort,
                             uint16_t selectedPins) {
    abc8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    abcc:	0e 4c       	mov	r12,	r14	;
    abce:	0e 5c       	add	r12,	r14	;
    abd0:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    abd4:	1c b3       	bit	#1,	r12	;r3 As==01
    abd6:	08 20       	jnz	$+18     	;abs 0xabe8
    {
        selectedPins <<= 8;
    abd8:	0d 5d       	rla	r13		;
    abda:	0d 5d       	rla	r13		;
    abdc:	0d 5d       	rla	r13		;
    abde:	0d 5d       	rla	r13		;
    abe0:	0d 5d       	rla	r13		;
    abe2:	0d 5d       	rla	r13		;
    abe4:	0d 5d       	rla	r13		;
    abe6:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) |= selectedPins;
    abe8:	8e dd 02 00 	bis	r13,	2(r14)	;
}
    abec:	30 41       	ret			

0000abee <GPIO_setOutputLowOnPin>:

void GPIO_setOutputLowOnPin(uint8_t selectedPort,
                            uint16_t selectedPins) {
    abee:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    abf2:	0e 4c       	mov	r12,	r14	;
    abf4:	0e 5c       	add	r12,	r14	;
    abf6:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    abfa:	1c b3       	bit	#1,	r12	;r3 As==01
    abfc:	08 20       	jnz	$+18     	;abs 0xac0e
    {
        selectedPins <<= 8;
    abfe:	0d 5d       	rla	r13		;
    ac00:	0d 5d       	rla	r13		;
    ac02:	0d 5d       	rla	r13		;
    ac04:	0d 5d       	rla	r13		;
    ac06:	0d 5d       	rla	r13		;
    ac08:	0d 5d       	rla	r13		;
    ac0a:	0d 5d       	rla	r13		;
    ac0c:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) &= ~selectedPins;
    ac0e:	8e cd 02 00 	bic	r13,	2(r14)	;
}
    ac12:	30 41       	ret			

0000ac14 <GPIO_toggleOutputOnPin>:

void GPIO_toggleOutputOnPin(uint8_t selectedPort,
                            uint16_t selectedPins) {
    ac14:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ac18:	0e 4c       	mov	r12,	r14	;
    ac1a:	0e 5c       	add	r12,	r14	;
    ac1c:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ac20:	1c b3       	bit	#1,	r12	;r3 As==01
    ac22:	08 20       	jnz	$+18     	;abs 0xac34
    {
        selectedPins <<= 8;
    ac24:	0d 5d       	rla	r13		;
    ac26:	0d 5d       	rla	r13		;
    ac28:	0d 5d       	rla	r13		;
    ac2a:	0d 5d       	rla	r13		;
    ac2c:	0d 5d       	rla	r13		;
    ac2e:	0d 5d       	rla	r13		;
    ac30:	0d 5d       	rla	r13		;
    ac32:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAOUT) ^= selectedPins;
    ac34:	8e ed 02 00 	xor	r13,	2(r14)	;
}
    ac38:	30 41       	ret			

0000ac3a <GPIO_getInputPinValue>:

uint8_t GPIO_getInputPinValue(uint8_t selectedPort,
                              uint16_t selectedPins) {
    ac3a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ac3e:	0e 4c       	mov	r12,	r14	;
    ac40:	0e 5c       	add	r12,	r14	;
    ac42:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ac46:	1c b3       	bit	#1,	r12	;r3 As==01
    ac48:	08 20       	jnz	$+18     	;abs 0xac5a
    {
        selectedPins <<= 8;
    ac4a:	0d 5d       	rla	r13		;
    ac4c:	0d 5d       	rla	r13		;
    ac4e:	0d 5d       	rla	r13		;
    ac50:	0d 5d       	rla	r13		;
    ac52:	0d 5d       	rla	r13		;
    ac54:	0d 5d       	rla	r13		;
    ac56:	0d 5d       	rla	r13		;
    ac58:	0d 5d       	rla	r13		;
    }

    uint16_t inputPinValue = HWREG16(baseAddress + OFS_PAIN) & (selectedPins);
    ac5a:	2d fe       	and	@r14,	r13	;

    if(inputPinValue > 0)
    ac5c:	0c 43       	clr	r12		;
    ac5e:	0c 8d       	sub	r13,	r12	;
    ac60:	0c dd       	bis	r13,	r12	;
    ac62:	b0 12 60 d2 	call	#53856		;#0xd260
    {
        return (GPIO_INPUT_PIN_HIGH);
    }
    return (GPIO_INPUT_PIN_LOW);
}
    ac66:	30 41       	ret			

0000ac68 <GPIO_enableInterrupt>:

void GPIO_enableInterrupt(uint8_t selectedPort,
                          uint16_t selectedPins) {
    ac68:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ac6c:	0e 4c       	mov	r12,	r14	;
    ac6e:	0e 5c       	add	r12,	r14	;
    ac70:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ac74:	1c b3       	bit	#1,	r12	;r3 As==01
    ac76:	08 20       	jnz	$+18     	;abs 0xac88
    {
        selectedPins <<= 8;
    ac78:	0d 5d       	rla	r13		;
    ac7a:	0d 5d       	rla	r13		;
    ac7c:	0d 5d       	rla	r13		;
    ac7e:	0d 5d       	rla	r13		;
    ac80:	0d 5d       	rla	r13		;
    ac82:	0d 5d       	rla	r13		;
    ac84:	0d 5d       	rla	r13		;
    ac86:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAIE) |= selectedPins;
    ac88:	8e dd 1a 00 	bis	r13,	26(r14)	; 0x001a
}
    ac8c:	30 41       	ret			

0000ac8e <GPIO_disableInterrupt>:

void GPIO_disableInterrupt(uint8_t selectedPort,
                           uint16_t selectedPins) {
    ac8e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ac92:	0e 4c       	mov	r12,	r14	;
    ac94:	0e 5c       	add	r12,	r14	;
    ac96:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ac9a:	1c b3       	bit	#1,	r12	;r3 As==01
    ac9c:	08 20       	jnz	$+18     	;abs 0xacae
    {
        selectedPins <<= 8;
    ac9e:	0d 5d       	rla	r13		;
    aca0:	0d 5d       	rla	r13		;
    aca2:	0d 5d       	rla	r13		;
    aca4:	0d 5d       	rla	r13		;
    aca6:	0d 5d       	rla	r13		;
    aca8:	0d 5d       	rla	r13		;
    acaa:	0d 5d       	rla	r13		;
    acac:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAIE) &= ~selectedPins;
    acae:	8e cd 1a 00 	bic	r13,	26(r14)	; 0x001a
}
    acb2:	30 41       	ret			

0000acb4 <GPIO_getInterruptStatus>:

uint16_t GPIO_getInterruptStatus(uint8_t selectedPort,
                                 uint16_t selectedPins) {
    acb4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    acb8:	0e 4c       	mov	r12,	r14	;
    acba:	0e 5c       	add	r12,	r14	;
    acbc:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    acc0:	1c b3       	bit	#1,	r12	;r3 As==01
    acc2:	07 20       	jnz	$+16     	;abs 0xacd2
    {
        return (HWREG8(baseAddress + OFS_PAIFG_H) & selectedPins);
    acc4:	5c 4e 1d 00 	mov.b	29(r14),r12	;0x0001d
    acc8:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    accc:	0c fd       	and	r13,	r12	;
    acce:	30 40 d8 ac 	br	#0xacd8		;
    }
    else
    {
        return (HWREG16(baseAddress + OFS_PAIFG) & selectedPins);
    acd2:	1c 4e 1c 00 	mov	28(r14),r12	;0x0001c
    acd6:	0c fd       	and	r13,	r12	;
    }
}
    acd8:	30 41       	ret			

0000acda <GPIO_clearInterrupt>:

void GPIO_clearInterrupt(uint8_t selectedPort,
                         uint16_t selectedPins) {
    acda:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    acde:	0e 4c       	mov	r12,	r14	;
    ace0:	0e 5c       	add	r12,	r14	;
    ace2:	1e 4e 02 82 	mov	-32254(r14),r14	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ace6:	1c b3       	bit	#1,	r12	;r3 As==01
    ace8:	08 20       	jnz	$+18     	;abs 0xacfa
    {
        selectedPins <<= 8;
    acea:	0d 5d       	rla	r13		;
    acec:	0d 5d       	rla	r13		;
    acee:	0d 5d       	rla	r13		;
    acf0:	0d 5d       	rla	r13		;
    acf2:	0d 5d       	rla	r13		;
    acf4:	0d 5d       	rla	r13		;
    acf6:	0d 5d       	rla	r13		;
    acf8:	0d 5d       	rla	r13		;
    }

    HWREG16(baseAddress + OFS_PAIFG) &= ~selectedPins;
    acfa:	8e cd 1c 00 	bic	r13,	28(r14)	; 0x001c
}
    acfe:	30 41       	ret			

0000ad00 <GPIO_selectInterruptEdge>:

void GPIO_selectInterruptEdge(uint8_t selectedPort,
                              uint16_t selectedPins,
                              uint8_t edgeSelect) {
    ad00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    ad04:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t baseAddress = GPIO_PORT_TO_BASE[selectedPort];
    ad08:	0f 4c       	mov	r12,	r15	;
    ad0a:	0f 5c       	add	r12,	r15	;
    ad0c:	1f 4f 02 82 	mov	-32254(r15),r15	;0xffff8202
        return;
    }
    #endif

    // Shift by 8 if port is even (upper 8-bits)
    if((selectedPort & 1) ^ 1)
    ad10:	1c b3       	bit	#1,	r12	;r3 As==01
    ad12:	08 20       	jnz	$+18     	;abs 0xad24
    {
        selectedPins <<= 8;
    ad14:	0d 5d       	rla	r13		;
    ad16:	0d 5d       	rla	r13		;
    ad18:	0d 5d       	rla	r13		;
    ad1a:	0d 5d       	rla	r13		;
    ad1c:	0d 5d       	rla	r13		;
    ad1e:	0d 5d       	rla	r13		;
    ad20:	0d 5d       	rla	r13		;
    ad22:	0d 5d       	rla	r13		;
    }

    if(GPIO_LOW_TO_HIGH_TRANSITION == edgeSelect)
    ad24:	0e 93       	cmp	#0,	r14	;r3 As==00
    ad26:	04 20       	jnz	$+10     	;abs 0xad30
    {
        HWREG16(baseAddress + OFS_PAIES) &= ~selectedPins;
    ad28:	8f cd 18 00 	bic	r13,	24(r15)	; 0x0018
    ad2c:	30 40 34 ad 	br	#0xad34		;
    }
    else
    {
        HWREG16(baseAddress + OFS_PAIES) |= selectedPins;
    ad30:	8f dd 18 00 	bis	r13,	24(r15)	; 0x0018
    }
}
    ad34:	30 41       	ret			

0000ad36 <MPY_setOperandOne8Bit>:

#include <assert.h>

void MPY_setOperandOne8Bit(uint8_t multiplicationType,
                           uint8_t operand)
{
    ad36:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG8(MPY_BASE + OFS_MPY + multiplicationType) = operand;
    ad3a:	cc 4d 30 01 	mov.b	r13,	304(r12); 0x0130
}
    ad3e:	30 41       	ret			

0000ad40 <MPY_setOperandOne16Bit>:

void inline MPY_setOperandOne16Bit(uint8_t multiplicationType,
                            uint16_t operand)
{
    ad40:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    HWREG16(MPY_BASE + OFS_MPY + multiplicationType) = operand;
    ad44:	8c 4d 30 01 	mov	r13,	304(r12); 0x0130
}
    ad48:	30 41       	ret			

0000ad4a <MPY_setOperandTwo8Bit>:

void MPY_setOperandTwo8Bit(uint8_t operand)
{
    HWREG8(MPY_BASE + OFS_OP2) = operand;
    ad4a:	c2 4c 38 01 	mov.b	r12,	&0x0138	;
}
    ad4e:	30 41       	ret			

0000ad50 <MPY_setOperandTwo16Bit>:

void inline MPY_setOperandTwo16Bit(uint16_t operand)
{
    HWREG16(MPY_BASE + OFS_OP2) = operand;
    ad50:	82 4c 38 01 	mov	r12,	&0x0138	;
}
    ad54:	30 41       	ret			

0000ad56 <MPY_getResult>:

uint32_t inline MPY_getResult(void)
{
    ad56:	0a 12       	push	r10		;
    ad58:	09 12       	push	r9		;
    uint32_t result;
    result = HWREG16(MPY_BASE + OFS_RESLO);
    ad5a:	0a 43       	clr	r10		;
    ad5c:	09 4a       	mov	r10,	r9	;
    ad5e:	1a 42 3a 01 	mov	&0x013a,r10	;0x013a
    result += ((uint32_t) HWREG16(MPY_BASE + OFS_RESHI) << 16);
    ad62:	1c 42 3c 01 	mov	&0x013c,r12	;0x013c
    ad66:	0d 49       	mov	r9,	r13	;
    ad68:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    ad6c:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    return(result);
}
    ad70:	0c 5a       	add	r10,	r12	;
    ad72:	0d 69       	addc	r9,	r13	;
    ad74:	30 40 72 d1 	br	#0xd172		;

0000ad78 <MPY_getSumExtension>:

uint16_t MPY_getSumExtension(void)
{
    return (HWREG16(MPY_BASE + OFS_SUMEXT));
}
    ad78:	1c 42 3e 01 	mov	&0x013e,r12	;0x013e
    ad7c:	30 41       	ret			

0000ad7e <PMM_setupVoltageMonitor>:

#include <assert.h>

void PMM_setupVoltageMonitor(uint8_t voltageMonitorLevel) {
    uint8_t currentStatus = VMONCTL;
    currentStatus &= ~(0x07);
    ad7e:	5d 42 61 00 	mov.b	&0x0061,r13	;0x0061
    ad82:	7d f0 f8 ff 	and.b	#65528,	r13	;#0xfff8
    currentStatus |= voltageMonitorLevel;
    VMONCTL = currentStatus;
    ad86:	4c dd       	bis.b	r13,	r12	;
    ad88:	c2 4c 61 00 	mov.b	r12,	&0x0061	;
}
    ad8c:	30 41       	ret			

0000ad8e <PMM_calibrateReference>:

void PMM_calibrateReference(void) {
    REFCAL0 = HWREG8(TLV_START + TLV_CAL_REFCAL0);
    ad8e:	d2 42 d1 13 	mov.b	&0x13d1,&0x0062	;0x13d1
    ad92:	62 00 
    REFCAL1 = HWREG8(TLV_START + TLV_CAL_REFCAL1);
    ad94:	d2 42 d0 13 	mov.b	&0x13d0,&0x0063	;0x13d0
    ad98:	63 00 
}
    ad9a:	30 41       	ret			

0000ad9c <PMM_setRegulatorStatus>:

void PMM_setRegulatorStatus(uint8_t status) {
    uint8_t currentStatus = LPM45CTL;
    currentStatus &= ~(PMMREGOFF);
    ad9c:	5d 42 60 00 	mov.b	&0x0060,r13	;0x0060
    ada0:	7d f0 ef ff 	and.b	#65519,	r13	;#0xffef
    currentStatus |= status;
    LPM45CTL = currentStatus;
    ada4:	4c dd       	bis.b	r13,	r12	;
    ada6:	c2 4c 60 00 	mov.b	r12,	&0x0060	;
}
    adaa:	30 41       	ret			

0000adac <PMM_unlockIOConfiguration>:

void PMM_unlockIOConfiguration(void) {
    LPM45CTL &= ~(LOCKLPM45);
    adac:	d2 c3 60 00 	bic.b	#1,	&0x0060	;r3 As==01
}
    adb0:	30 41       	ret			

0000adb2 <PMM_enableInterrupt>:

void PMM_enableInterrupt(uint8_t mask) {
    VMONCTL |= mask;
    adb2:	c2 dc 61 00 	bis.b	r12,	&0x0061	;
}
    adb6:	30 41       	ret			

0000adb8 <PMM_disableInterrupt>:

void PMM_disableInterrupt(uint8_t mask) {
    VMONCTL &= ~(mask);
    adb8:	c2 cc 61 00 	bic.b	r12,	&0x0061	;
}
    adbc:	30 41       	ret			

0000adbe <PMM_getInterruptStatus>:

uint8_t PMM_getInterruptStatus(uint8_t mask) {
    adbe:	4d 4c       	mov.b	r12,	r13	;
    uint8_t result = 0x00;

    if((mask & PMM_VMON_INTERRUPT) && (VMONCTL & VMONIFG))
    adc0:	3d b0 10 00 	bit	#16,	r13	;#0x0010
    adc4:	08 24       	jz	$+18     	;abs 0xadd6
    adc6:	f2 b0 20 00 	bit.b	#32,	&0x0061	;#0x0020
    adca:	61 00 
    adcc:	07 24       	jz	$+16     	;abs 0xaddc
    {
        result |= PMM_VMON_INTERRUPT;
    adce:	3c 40 10 00 	mov	#16,	r12	;#0x0010
    add2:	30 40 de ad 	br	#0xadde		;
void PMM_disableInterrupt(uint8_t mask) {
    VMONCTL &= ~(mask);
}

uint8_t PMM_getInterruptStatus(uint8_t mask) {
    uint8_t result = 0x00;
    add6:	0c 43       	clr	r12		;
    add8:	30 40 de ad 	br	#0xadde		;
    addc:	0c 43       	clr	r12		;
    if((mask & PMM_VMON_INTERRUPT) && (VMONCTL & VMONIFG))
    {
        result |= PMM_VMON_INTERRUPT;
    }

    if(mask & PMM_LPM45_INTERRUPT)
    adde:	2d b3       	bit	#2,	r13	;r3 As==10
    ade0:	06 24       	jz	$+14     	;abs 0xadee
    {
        result |= (LPM45CTL & LPM45IFG);
    ade2:	5d 42 60 00 	mov.b	&0x0060,r13	;0x0060
    ade6:	6d f3       	and.b	#2,	r13	;r3 As==10
    ade8:	4c dd       	bis.b	r13,	r12	;
    adea:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    }

    return(result);
}
    adee:	30 41       	ret			

0000adf0 <PMM_clearInterrupt>:

void PMM_clearInterrupt(uint8_t mask) {
    LPM45CTL &= ~(mask);
    adf0:	c2 cc 60 00 	bic.b	r12,	&0x0060	;
}
    adf4:	30 41       	ret			

0000adf6 <SD24_init>:

#include <assert.h>

void SD24_init(uint16_t baseAddress,
               uint8_t referenceSelect)
{
    adf6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    adfa:	0e 4c       	mov	r12,	r14	;
    adfc:	3e 50 52 00 	add	#82,	r14	;#0x0052
    ae00:	0f 4c       	mov	r12,	r15	;
    ae02:	3f 50 5a 00 	add	#90,	r15	;#0x005a

    // Reset all interrupts and flags, and turn off all groups
    for(converter = 0; converter < 4; converter++)
    {
        address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
        HWREG16(address) &= ~(SD24SC + SD24IFG + SD24GRP);
    ae06:	be f0 f8 ff 	and	#65528,	0(r14)	;#0xfff8
    ae0a:	00 00 
    ae0c:	2e 53       	incd	r14		;
{
    uint16_t address;
    uint8_t converter;

    // Reset all interrupts and flags, and turn off all groups
    for(converter = 0; converter < 4; converter++)
    ae0e:	0e 9f       	cmp	r15,	r14	;
    ae10:	fa 23       	jnz	$-10     	;abs 0xae06
        address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
        HWREG16(address) &= ~(SD24SC + SD24IFG + SD24GRP);
    }

    // Turn off overflow interrupts, and configure SD24 reference
    HWREG16(baseAddress + OFS_SD24CTL) = referenceSelect;
    ae12:	8c 4d 50 00 	mov	r13,	80(r12)	; 0x0050
    return;
}
    ae16:	30 41       	ret			

0000ae18 <SD24_initConverter>:

void SD24_initConverter(uint16_t baseAddress,
                        uint16_t converter,
                        uint16_t conversionMode)
{
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    ae18:	3d 50 29 00 	add	#41,	r13	;#0x0029
    ae1c:	0d 5d       	rla	r13		;
    ae1e:	0c 5d       	add	r13,	r12	;

    // Clearing previous settings for configuration
    HWREG16(address) &= ~(SD24SNGL);
    ae20:	bc f0 ff fb 	and	#64511,	0(r12)	;#0xfbff
    ae24:	00 00 

    HWREG16(address) |= conversionMode;
    ae26:	8c de 00 00 	bis	r14,	0(r12)	;
}
    ae2a:	30 41       	ret			

0000ae2c <SD24_initConverterAdvanced>:
void SD24_initConverterAdvanced(uint16_t baseAddress,
                                SD24_initConverterAdvancedParam *param)
{
    // Getting correct SD24CCTLx register
    uint16_t address = baseAddress +
                       (OFS_SD24CCTL0 + (param->converter * 0x02));
    ae2c:	6e 4d       	mov.b	@r13,	r14	;
    ae2e:	3e 50 29 00 	add	#41,	r14	;#0x0029
    ae32:	0e 5e       	rla	r14		;

void SD24_initConverterAdvanced(uint16_t baseAddress,
                                SD24_initConverterAdvancedParam *param)
{
    // Getting correct SD24CCTLx register
    uint16_t address = baseAddress +
    ae34:	0e 5c       	add	r12,	r14	;
                       (OFS_SD24CCTL0 + (param->converter * 0x02));

    // Clearing previous settings for configuration
    HWREG16(address) &= ~(SD24SNGL | SD24DF | SD24GRP | SD24OSR_32);
    ae36:	be f0 ee f8 	and	#63726,	0(r14)	;#0xf8ee
    ae3a:	00 00 
    ae3c:	1b 4d 08 00 	mov	8(r13),	r11	;
    ae40:	1b dd 02 00 	bis	2(r13),	r11	;

    HWREG16(address) |=
        (param->groupEnable | param->conversionMode | param->dataFormat
    ae44:	5f 4d 04 00 	mov.b	4(r13),	r15	;
    ae48:	0f db       	bis	r11,	r15	;
    ae4a:	5b 4d 06 00 	mov.b	6(r13),	r11	;
     | param->oversampleRatio);
    ae4e:	0f db       	bis	r11,	r15	;
                       (OFS_SD24CCTL0 + (param->converter * 0x02));

    // Clearing previous settings for configuration
    HWREG16(address) &= ~(SD24SNGL | SD24DF | SD24GRP | SD24OSR_32);

    HWREG16(address) |=
    ae50:	8e df 00 00 	bis	r15,	0(r14)	;
        (param->groupEnable | param->conversionMode | param->dataFormat
     | param->oversampleRatio);

    // Getting correct SD24INTCTLx register
    address = baseAddress + (OFS_SD24INCTL0 + (param->converter));
    ae54:	6e 4d       	mov.b	@r13,	r14	;
    ae56:	0c 5e       	add	r14,	r12	;

    // Clearing previous settings for configuration
    HWREG8(address) &= ~(SD24_GAIN_8 | SD24_GAIN_16 | SD24INTDLY | SD24INCH_7);
    ae58:	fc f0 80 ff 	and.b	#65408,	0(r12)	;#0xff80
    ae5c:	00 00 

    HWREG8(address) |=
    ae5e:	5e 4d 07 00 	mov.b	7(r13),	r14	;
    ae62:	5e dd 0a 00 	bis.b	10(r13),r14	;0x0000a
    ae66:	5e dd 05 00 	bis.b	5(r13),	r14	;
    ae6a:	cc de 00 00 	bis.b	r14,	0(r12)	;
        (param->gain | param->interruptDelay | param->inputChannel);
}
    ae6e:	30 41       	ret			

0000ae70 <SD24_setConverterDataFormat>:

void SD24_setConverterDataFormat(uint16_t baseAddress,
                                 uint16_t converter,
                                 uint16_t dataFormat)
{
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    ae70:	3d 50 29 00 	add	#41,	r13	;#0x0029
    ae74:	0d 5d       	rla	r13		;
    ae76:	0c 5d       	add	r13,	r12	;

    // Clearing previous settings for configuration
    HWREG16(address) &= ~(SD24DF);
    ae78:	bc f0 ef ff 	and	#65519,	0(r12)	;#0xffef
    ae7c:	00 00 

    HWREG16(address) |= dataFormat;
    ae7e:	8c de 00 00 	bis	r14,	0(r12)	;
}
    ae82:	30 41       	ret			

0000ae84 <SD24_startConverterConversion>:

void SD24_startConverterConversion(uint16_t baseAddress,
                                   uint8_t converter)
{
    ae84:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    ae88:	3d 50 29 00 	add	#41,	r13	;#0x0029
    ae8c:	0d 5d       	rla	r13		;
    ae8e:	0c 5d       	add	r13,	r12	;
        (SD24_CONVERTER_2 == converter) ||
        (SD24_CONVERTER_3 == converter)
        );

    // Setting SD24SC bit to start conversion
    HWREG16(address) |= SD24SC;
    ae90:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10
}
    ae94:	30 41       	ret			

0000ae96 <SD24_stopConverterConversion>:

void SD24_stopConverterConversion(uint16_t baseAddress,
                                  uint8_t converter)
{
    ae96:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
        (SD24_CONVERTER_1 == converter) ||
        (SD24_CONVERTER_2 == converter) ||
        (SD24_CONVERTER_3 == converter)
        );

    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    ae9a:	3d 50 29 00 	add	#41,	r13	;#0x0029
    ae9e:	0d 5d       	rla	r13		;
    aea0:	0c 5d       	add	r13,	r12	;

    // Setting SD24SC bit to start conversion
    HWREG16(address) &= ~(SD24SC);
    aea2:	ac c3 00 00 	bic	#2,	0(r12)	;r3 As==10
}
    aea6:	30 41       	ret			

0000aea8 <SD24_setInputChannel>:

void SD24_setInputChannel(uint16_t baseAddress,
                          uint8_t converter,
                          uint8_t inputChannel)
{
    aea8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint16_t address = baseAddress + (OFS_SD24INCTL0 + (converter));
    aeac:	0c 5d       	add	r13,	r12	;

    // Clear previous settings
    HWREG8(address) &= ~(SD24INCH_7);
    aeae:	fc f0 f8 ff 	and.b	#65528,	0(r12)	;#0xfff8
    aeb2:	00 00 

    HWREG8(address) |= inputChannel;
    aeb4:	cc de 00 00 	bis.b	r14,	0(r12)	;
}
    aeb8:	30 41       	ret			

0000aeba <SD24_setInterruptDelay>:

void SD24_setInterruptDelay(uint16_t baseAddress,
                            uint8_t converter,
                            uint8_t interruptDelay)
{
    aeba:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    aebe:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    uint16_t address = baseAddress + (OFS_SD24INCTL0 + (converter));
    aec2:	0c 5d       	add	r13,	r12	;
        (SD24_CONVERTER_2 == converter) ||
        (SD24_CONVERTER_3 == converter)
        );

    // Clear previous settings
    HWREG16(address) &= ~(SD24INTDLY);
    aec4:	bc f0 bf ff 	and	#65471,	0(r12)	;#0xffbf
    aec8:	00 00 

    HWREG16(address) |= interruptDelay;
    aeca:	8c de 00 00 	bis	r14,	0(r12)	;
}
    aece:	30 41       	ret			

0000aed0 <SD24_setOversampling>:

void SD24_setOversampling(uint16_t baseAddress,
                          uint8_t converter,
                          uint16_t oversampleRatio)
{
    aed0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    aed4:	3d 50 29 00 	add	#41,	r13	;#0x0029
    aed8:	0d 5d       	rla	r13		;
    aeda:	0c 5d       	add	r13,	r12	;
        (SD24_CONVERTER_2 == converter) ||
        (SD24_CONVERTER_3 == converter)
        );

    // Clear previous settings
    HWREG16(address) &= ~(SD24OSR0 | SD24OSR1);
    aedc:	bc f0 ff fc 	and	#64767,	0(r12)	;#0xfcff
    aee0:	00 00 

    HWREG16(address) |= oversampleRatio;
    aee2:	8c de 00 00 	bis	r14,	0(r12)	;
}
    aee6:	30 41       	ret			

0000aee8 <SD24_setGain>:

void SD24_setGain(uint16_t baseAddress,
                  uint8_t converter,
                  uint8_t gain)
{
    aee8:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    uint16_t address = baseAddress + (OFS_SD24INCTL0 + (converter));
    aeec:	0c 5d       	add	r13,	r12	;

    // Clear previous settings
    HWREG8(address) &= ~(SD24GAIN0 | SD24GAIN1 | SD24GAIN2);
    aeee:	fc f0 c7 ff 	and.b	#65479,	0(r12)	;#0xffc7
    aef2:	00 00 

    HWREG8(address) |= gain;
    aef4:	cc de 00 00 	bis.b	r14,	0(r12)	;
}
    aef8:	30 41       	ret			

0000aefa <SD24_getResults>:

uint32_t SD24_getResults(uint16_t baseAddress,
                         uint8_t converter)
{
    aefa:	21 83       	decd	r1		;
    aefc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    volatile uint16_t OSR;

    // Calculate address of MEM results
    uint16_t address = baseAddress + (OFS_SD24MEM0 + (converter * 0x02));
    af00:	3d 50 30 00 	add	#48,	r13	;#0x0030
    af04:	0d 5d       	rla	r13		;

    // Get high word result
    HWREG16(baseAddress +
            (OFS_SD24CCTL0 + (converter * 0x02))) &= ~(SD24LSBACC);
    af06:	0f 4d       	mov	r13,	r15	;
    af08:	3f 50 f2 ff 	add	#65522,	r15	;#0xfff2
    af0c:	0f 5c       	add	r12,	r15	;
    af0e:	bf f0 bf ff 	and	#65471,	0(r15)	;#0xffbf
    af12:	00 00 
                         uint8_t converter)
{
    volatile uint16_t OSR;

    // Calculate address of MEM results
    uint16_t address = baseAddress + (OFS_SD24MEM0 + (converter * 0x02));
    af14:	0c 5d       	add	r13,	r12	;

    // Get high word result
    HWREG16(baseAddress +
            (OFS_SD24CCTL0 + (converter * 0x02))) &= ~(SD24LSBACC);
    uint32_t highResult = (uint32_t)HWREG16(address);
    af16:	0e 43       	clr	r14		;
    af18:	0d 4e       	mov	r14,	r13	;
    af1a:	2e 4c       	mov	@r12,	r14	;

    // Get low word result
    HWREG16(baseAddress + (OFS_SD24CCTL0 + (converter * 0x02))) |= SD24LSBACC;
    af1c:	bf d0 40 00 	bis	#64,	0(r15)	;#0x0040
    af20:	00 00 
    uint16_t lowResult = HWREG16(address);
    af22:	2c 4c       	mov	@r12,	r12	;
    HWREG16(baseAddress +
            (OFS_SD24CCTL0 + (converter * 0x02))) &= ~(SD24LSBACC);
    af24:	bf f0 bf ff 	and	#65471,	0(r15)	;#0xffbf
    af28:	00 00 

    // Determine the OSR and combine the high and low result words as appropriate
    OSR =
    af2a:	2f 4f       	mov	@r15,	r15	;
    af2c:	3f f0 00 03 	and	#768,	r15	;#0x0300
    af30:	81 4f 00 00 	mov	r15,	0(r1)	;
        HWREG16(baseAddress +
                (OFS_SD24CCTL0 + (converter * 0x02))) & (SD24OSR0 | SD24OSR1);

    if(OSR == SD24_OVERSAMPLE_256)
    af34:	2f 41       	mov	@r1,	r15	;
    af36:	0f 9d       	cmp	r13,	r15	;
    af38:	14 20       	jnz	$+42     	;abs 0xaf62
    {
        return((highResult << 8) | lowResult);
    af3a:	0f 4e       	mov	r14,	r15	;
    af3c:	0f 5e       	add	r14,	r15	;
    af3e:	0d 6d       	rlc	r13		;
    af40:	0f 5f       	rla	r15		;
    af42:	0d 6d       	rlc	r13		;
    af44:	0f 5f       	rla	r15		;
    af46:	0d 6d       	rlc	r13		;
    af48:	0f 5f       	rla	r15		;
    af4a:	0d 6d       	rlc	r13		;
    af4c:	0f 5f       	rla	r15		;
    af4e:	0d 6d       	rlc	r13		;
    af50:	0f 5f       	rla	r15		;
    af52:	0d 6d       	rlc	r13		;
    af54:	0f 5f       	rla	r15		;
    af56:	0d 6d       	rlc	r13		;
    af58:	0f 5f       	rla	r15		;
    af5a:	0d 6d       	rlc	r13		;
    af5c:	0c df       	bis	r15,	r12	;
    af5e:	30 40 9e af 	br	#0xaf9e		;
    }
    else if(OSR == SD24_OVERSAMPLE_128)
    af62:	2f 41       	mov	@r1,	r15	;
    af64:	3f 90 00 01 	cmp	#256,	r15	;#0x0100
    af68:	0e 20       	jnz	$+30     	;abs 0xaf86
    {
        return((highResult << 5) | lowResult);
    af6a:	0b 4e       	mov	r14,	r11	;
    af6c:	0b 5e       	add	r14,	r11	;
    af6e:	0d 6d       	rlc	r13		;
    af70:	0b 5b       	rla	r11		;
    af72:	0d 6d       	rlc	r13		;
    af74:	0b 5b       	rla	r11		;
    af76:	0d 6d       	rlc	r13		;
    af78:	0b 5b       	rla	r11		;
    af7a:	0d 6d       	rlc	r13		;
    af7c:	0b 5b       	rla	r11		;
    af7e:	0d 6d       	rlc	r13		;
    af80:	0c db       	bis	r11,	r12	;
    af82:	30 40 9e af 	br	#0xaf9e		;
    }
    else if(OSR == SD24_OVERSAMPLE_64)
    af86:	2f 41       	mov	@r1,	r15	;
    af88:	3f 90 00 02 	cmp	#512,	r15	;#0x0200
    af8c:	07 20       	jnz	$+16     	;abs 0xaf9c
    {
        return((highResult << 2) | lowResult);
    af8e:	0e 5e       	rla	r14		;
    af90:	0d 6d       	rlc	r13		;
    af92:	0e 5e       	rla	r14		;
    af94:	0d 6d       	rlc	r13		;
    af96:	0c de       	bis	r14,	r12	;
    af98:	30 40 9e af 	br	#0xaf9e		;
    }
    else        // OSR = SD24_OVERSAMPLE_32
    {
        return (highResult);
    af9c:	0c 4e       	mov	r14,	r12	;
    }
}
    af9e:	21 53       	incd	r1		;
    afa0:	30 41       	ret			

0000afa2 <SD24_getHighWordResults>:

uint16_t SD24_getHighWordResults(uint16_t baseAddress,
                                 uint8_t converter)
{
    afa2:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // Calculate address of MEM results
    uint16_t address = baseAddress + (OFS_SD24MEM0 + (converter * 0x02));
    afa6:	3d 50 30 00 	add	#48,	r13	;#0x0030
    afaa:	0d 5d       	rla	r13		;

    // Get high word result
    HWREG16(baseAddress +
            (OFS_SD24CCTL0 + (converter * 0x02))) &= ~(SD24LSBACC);
    afac:	0e 4d       	mov	r13,	r14	;
    afae:	3e 50 f2 ff 	add	#65522,	r14	;#0xfff2
    afb2:	0e 5c       	add	r12,	r14	;
    afb4:	be f0 bf ff 	and	#65471,	0(r14)	;#0xffbf
    afb8:	00 00 

uint16_t SD24_getHighWordResults(uint16_t baseAddress,
                                 uint8_t converter)
{
    // Calculate address of MEM results
    uint16_t address = baseAddress + (OFS_SD24MEM0 + (converter * 0x02));
    afba:	0d 5c       	add	r12,	r13	;
    HWREG16(baseAddress +
            (OFS_SD24CCTL0 + (converter * 0x02))) &= ~(SD24LSBACC);
    uint16_t highResult = HWREG16(address);

    return(highResult);
}
    afbc:	2c 4d       	mov	@r13,	r12	;
    afbe:	30 41       	ret			

0000afc0 <SD24_enableInterrupt>:

void SD24_enableInterrupt(uint16_t baseAddress,
                          uint8_t converter,
                          uint16_t mask)
{
    afc0:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // Calculating address
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    afc4:	3d 50 29 00 	add	#41,	r13	;#0x0029
    afc8:	0d 5d       	rla	r13		;
    afca:	0d 5c       	add	r12,	r13	;

    //Clear Interrupt Flags
    HWREG16(address) &= ~(SD24IFG | SD24OVIFG);
    afcc:	bd f0 db ff 	and	#65499,	0(r13)	;#0xffdb
    afd0:	00 00 

    //Enable Interrupt
    if(mask & SD24_CONVERTER_INTERRUPT)
    afd2:	2e b2       	bit	#4,	r14	;r2 As==10
    afd4:	02 24       	jz	$+6      	;abs 0xafda
    {
        HWREG16(address) |= (SD24IE);
    afd6:	bd d2 00 00 	bis	#8,	0(r13)	;r2 As==11
    }
    if(mask & SD24_CONVERTER_OVERFLOW_INTERRUPT)
    afda:	3e b0 20 00 	bit	#32,	r14	;#0x0020
    afde:	02 24       	jz	$+6      	;abs 0xafe4
    {
        HWREG16(baseAddress + OFS_SD24CTL) |= (SD24OVIE);
    afe0:	ac d3 50 00 	bis	#2,	80(r12)	;r3 As==10, 0x0050
    }
}
    afe4:	30 41       	ret			

0000afe6 <SD24_disableInterrupt>:

void SD24_disableInterrupt(uint16_t baseAddress,
                           uint8_t converter,
                           uint16_t mask)
{
    afe6:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // Calculating address
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));

    //Enable Interrupt
    if(mask & SD24_CONVERTER_INTERRUPT)
    afea:	2e b2       	bit	#4,	r14	;r2 As==10
    afec:	06 24       	jz	$+14     	;abs 0xaffa
void SD24_disableInterrupt(uint16_t baseAddress,
                           uint8_t converter,
                           uint16_t mask)
{
    // Calculating address
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    afee:	3d 50 29 00 	add	#41,	r13	;#0x0029
    aff2:	0d 5d       	rla	r13		;
    aff4:	0d 5c       	add	r12,	r13	;

    //Enable Interrupt
    if(mask & SD24_CONVERTER_INTERRUPT)
    {
        HWREG16(address) &= ~(SD24IE);
    aff6:	bd c2 00 00 	bic	#8,	0(r13)	;r2 As==11
    }
    if(mask & SD24_CONVERTER_OVERFLOW_INTERRUPT)
    affa:	3e b0 20 00 	bit	#32,	r14	;#0x0020
    affe:	02 24       	jz	$+6      	;abs 0xb004
    {
        HWREG16(baseAddress + OFS_SD24CTL) &= ~(SD24OVIE);
    b000:	ac c3 50 00 	bic	#2,	80(r12)	;r3 As==10, 0x0050
    }
}
    b004:	30 41       	ret			

0000b006 <SD24_clearInterrupt>:

void SD24_clearInterrupt(uint16_t baseAddress,
                         uint8_t converter,
                         uint16_t mask)
{
    b006:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // Calculating address
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    b00a:	3d 50 29 00 	add	#41,	r13	;#0x0029
    b00e:	0d 5d       	rla	r13		;
    b010:	0c 5d       	add	r13,	r12	;

    //Clear Interrupt Flags
    HWREG16(address) &= ~(mask);
    b012:	8c ce 00 00 	bic	r14,	0(r12)	;
}
    b016:	30 41       	ret			

0000b018 <SD24_getInterruptStatus>:

uint16_t SD24_getInterruptStatus(uint16_t baseAddress,
                                 uint8_t converter,
                                 uint16_t mask)
{
    b018:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    // Calculate address
    uint16_t address = baseAddress + (OFS_SD24CCTL0 + (converter * 0x02));
    b01c:	3d 50 29 00 	add	#41,	r13	;#0x0029
    b020:	0d 5d       	rla	r13		;
    b022:	0d 5c       	add	r12,	r13	;
    b024:	0c 4e       	mov	r14,	r12	;
    b026:	3c f0 24 00 	and	#36,	r12	;#0x0024

    // Read and return interrupt statuses
    return (HWREG16(address) & (mask) & (SD24IFG | SD24OVIFG));
}
    b02a:	2c fd       	and	@r13,	r12	;
    b02c:	30 41       	ret			

0000b02e <SFR_enableInterrupt>:

#include <assert.h>

void SFR_enableInterrupt(uint8_t interruptMask)
{
    HWREG8(SFR_BASE + OFS_SFRIE1_L) |= interruptMask;
    b02e:	c2 dc 00 00 	bis.b	r12,	&0x0000	;
}
    b032:	30 41       	ret			

0000b034 <SFR_disableInterrupt>:

void SFR_disableInterrupt(uint8_t interruptMask)
{
    HWREG8(SFR_BASE + OFS_SFRIE1_L) &= ~(interruptMask);
    b034:	c2 cc 00 00 	bic.b	r12,	&0x0000	;
}
    b038:	30 41       	ret			

0000b03a <SFR_getInterruptStatus>:

uint8_t SFR_getInterruptStatus(uint8_t interruptFlagMask)
{
    return (HWREG8(SFR_BASE + OFS_SFRIFG1_L) & interruptFlagMask);
}
    b03a:	5c f2 02 00 	and.b	&0x0002,r12	;0x0002
    b03e:	30 41       	ret			

0000b040 <SFR_clearInterrupt>:

void SFR_clearInterrupt(uint8_t interruptFlagMask)
{
    HWREG8(SFR_BASE + OFS_SFRIFG1_L) &= ~(interruptFlagMask);
    b040:	c2 cc 02 00 	bic.b	r12,	&0x0002	;
}
    b044:	30 41       	ret			

0000b046 <Timer_A_startCounter>:
#include <assert.h>

void Timer_A_startCounter(uint16_t baseAddress,
                          uint16_t timerMode)
{
    HWREG16(baseAddress + OFS_TAxCTL) |= timerMode;
    b046:	8c dd 00 00 	bis	r13,	0(r12)	;
}
    b04a:	30 41       	ret			

0000b04c <Timer_A_initContinuousMode>:

void Timer_A_initContinuousMode(uint16_t baseAddress,
                                Timer_A_initContinuousModeParam *param)
{
    b04c:	0a 12       	push	r10		;
    b04e:	09 12       	push	r9		;
    b050:	08 12       	push	r8		;
    b052:	07 12       	push	r7		;
    b054:	0a 4c       	mov	r12,	r10	;
    b056:	09 4d       	mov	r13,	r9	;
    HWREG16(baseAddress +
            OFS_TAxCTL) &= ~(TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK +
    b058:	bc f0 09 fc 	and	#64521,	0(r12)	;#0xfc09
    b05c:	00 00 
                             TIMER_A_UPDOWN_MODE +
                             TIMER_A_DO_CLEAR +
                             TIMER_A_TAIE_INTERRUPT_ENABLE +
                             ID__8
                             );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b05e:	27 4c       	mov	@r12,	r7	;
    b060:	18 4d 06 00 	mov	6(r13),	r8	;
    b064:	28 5d       	add	@r13,	r8	;
                                          param->timerClear +
    b066:	18 5d 04 00 	add	4(r13),	r8	;
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
    b06a:	1c 4d 02 00 	mov	2(r13),	r12	;
    b06e:	b0 12 90 d2 	call	#53904		;#0xd290
                                            3) << 6));
    b072:	0c 5c       	rla	r12		;
    b074:	0e 4c       	mov	r12,	r14	;
    b076:	0e 5c       	add	r12,	r14	;
    b078:	0e 5e       	rla	r14		;
    b07a:	0e 5e       	rla	r14		;
    b07c:	0e 5e       	rla	r14		;
    b07e:	0e 5e       	rla	r14		;
                             TIMER_A_TAIE_INTERRUPT_ENABLE +
                             ID__8
                             );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
    b080:	08 5e       	add	r14,	r8	;
                             TIMER_A_UPDOWN_MODE +
                             TIMER_A_DO_CLEAR +
                             TIMER_A_TAIE_INTERRUPT_ENABLE +
                             ID__8
                             );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b082:	07 d8       	bis	r8,	r7	;
    b084:	8a 47 00 00 	mov	r7,	0(r10)	;
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
                                            3) << 6));

    if(param->startTimer)
    b088:	c9 93 08 00 	cmp.b	#0,	8(r9)	;r3 As==00
    b08c:	03 24       	jz	$+8      	;abs 0xb094
    {
        HWREG16(baseAddress + OFS_TAxCTL) |= TIMER_A_CONTINUOUS_MODE;
    b08e:	ba d0 20 00 	bis	#32,	0(r10)	;#0x0020
    b092:	00 00 
    }
}
    b094:	30 40 6e d1 	br	#0xd16e		;

0000b098 <Timer_A_initUpMode>:

void Timer_A_initUpMode(uint16_t baseAddress,
                        Timer_A_initUpModeParam *param)
{
    b098:	0a 12       	push	r10		;
    b09a:	09 12       	push	r9		;
    b09c:	08 12       	push	r8		;
    b09e:	07 12       	push	r7		;
    b0a0:	0a 4c       	mov	r12,	r10	;
    b0a2:	09 4d       	mov	r13,	r9	;
    HWREG16(baseAddress + OFS_TAxCTL) &=
    b0a4:	bc f0 09 fc 	and	#64521,	0(r12)	;#0xfc09
    b0a8:	00 00 
          TIMER_A_UPDOWN_MODE +
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b0aa:	27 4c       	mov	@r12,	r7	;
    b0ac:	18 4d 0a 00 	mov	10(r13),r8	;0x0000a
    b0b0:	28 5d       	add	@r13,	r8	;
                                          param->timerClear +
    b0b2:	18 5d 06 00 	add	6(r13),	r8	;
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
    b0b6:	1c 4d 02 00 	mov	2(r13),	r12	;
    b0ba:	b0 12 90 d2 	call	#53904		;#0xd290
                                            3) << 6));
    b0be:	0c 5c       	rla	r12		;
    b0c0:	0e 4c       	mov	r12,	r14	;
    b0c2:	0e 5c       	add	r12,	r14	;
    b0c4:	0e 5e       	rla	r14		;
    b0c6:	0e 5e       	rla	r14		;
    b0c8:	0e 5e       	rla	r14		;
    b0ca:	0e 5e       	rla	r14		;
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
    b0cc:	08 5e       	add	r14,	r8	;
          TIMER_A_UPDOWN_MODE +
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b0ce:	07 d8       	bis	r8,	r7	;
    b0d0:	8a 47 00 00 	mov	r7,	0(r10)	;
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
                                            3) << 6));

    if(param->startTimer)
    b0d4:	c9 93 0c 00 	cmp.b	#0,	12(r9)	;r3 As==00, 0x000c
    b0d8:	03 24       	jz	$+8      	;abs 0xb0e0
    {
        HWREG16(baseAddress + OFS_TAxCTL) |= TIMER_A_UP_MODE;
    b0da:	ba d0 10 00 	bis	#16,	0(r10)	;#0x0010
    b0de:	00 00 
    }

    if(TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE ==
    b0e0:	b9 90 10 00 	cmp	#16,	8(r9)	;#0x0010
    b0e4:	08 00 
    b0e6:	05 20       	jnz	$+12     	;abs 0xb0f2
       param->captureCompareInterruptEnable_CCR0_CCIE)
    {
        HWREG16(baseAddress +
                OFS_TAxCCTL0) |= TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE;
    b0e8:	ba d0 10 00 	bis	#16,	2(r10)	;#0x0010
    b0ec:	02 00 
    b0ee:	30 40 f8 b0 	br	#0xb0f8		;
    }
    else
    {
        HWREG16(baseAddress +
                OFS_TAxCCTL0) &= ~TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE;
    b0f2:	ba f0 ef ff 	and	#65519,	2(r10)	;#0xffef
    b0f6:	02 00 
    }

    HWREG16(baseAddress + OFS_TAxCCR0) = param->timerPeriod;
    b0f8:	9a 49 04 00 	mov	4(r9),	18(r10)	; 0x0012
    b0fc:	12 00 
}
    b0fe:	30 40 6e d1 	br	#0xd16e		;

0000b102 <Timer_A_initUpDownMode>:

void Timer_A_initUpDownMode(uint16_t baseAddress,
                            Timer_A_initUpDownModeParam *param)
{
    b102:	0a 12       	push	r10		;
    b104:	09 12       	push	r9		;
    b106:	08 12       	push	r8		;
    b108:	07 12       	push	r7		;
    b10a:	0a 4c       	mov	r12,	r10	;
    b10c:	09 4d       	mov	r13,	r9	;
    HWREG16(baseAddress + OFS_TAxCTL) &=
    b10e:	bc f0 09 fc 	and	#64521,	0(r12)	;#0xfc09
    b112:	00 00 
          TIMER_A_UPDOWN_MODE +
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b114:	27 4c       	mov	@r12,	r7	;
    b116:	18 4d 0a 00 	mov	10(r13),r8	;0x0000a
    b11a:	28 5d       	add	@r13,	r8	;
                                          param->timerClear +
    b11c:	18 5d 06 00 	add	6(r13),	r8	;
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
    b120:	1c 4d 02 00 	mov	2(r13),	r12	;
    b124:	b0 12 90 d2 	call	#53904		;#0xd290
                                            3) << 6));
    b128:	0c 5c       	rla	r12		;
    b12a:	0e 4c       	mov	r12,	r14	;
    b12c:	0e 5c       	add	r12,	r14	;
    b12e:	0e 5e       	rla	r14		;
    b130:	0e 5e       	rla	r14		;
    b132:	0e 5e       	rla	r14		;
    b134:	0e 5e       	rla	r14		;
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
    b136:	08 5e       	add	r14,	r8	;
          TIMER_A_UPDOWN_MODE +
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b138:	07 d8       	bis	r8,	r7	;
    b13a:	8a 47 00 00 	mov	r7,	0(r10)	;
                                          param->timerClear +
                                          param->timerInterruptEnable_TAIE +
                                          ((param->clockSourceDivider >>
                                            3) << 6));

    if(param->startTimer)
    b13e:	c9 93 0c 00 	cmp.b	#0,	12(r9)	;r3 As==00, 0x000c
    b142:	03 24       	jz	$+8      	;abs 0xb14a
    {
        HWREG16(baseAddress + OFS_TAxCTL) |= TIMER_A_UPDOWN_MODE;
    b144:	ba d0 30 00 	bis	#48,	0(r10)	;#0x0030
    b148:	00 00 
    }

    if(TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE ==
    b14a:	b9 90 10 00 	cmp	#16,	8(r9)	;#0x0010
    b14e:	08 00 
    b150:	05 20       	jnz	$+12     	;abs 0xb15c
       param->captureCompareInterruptEnable_CCR0_CCIE)
    {
        HWREG16(baseAddress +
                OFS_TAxCCTL0) |= TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE;
    b152:	ba d0 10 00 	bis	#16,	2(r10)	;#0x0010
    b156:	02 00 
    b158:	30 40 62 b1 	br	#0xb162		;
    }
    else
    {
        HWREG16(baseAddress +
                OFS_TAxCCTL0) &= ~TIMER_A_CCIE_CCR0_INTERRUPT_ENABLE;
    b15c:	ba f0 ef ff 	and	#65519,	2(r10)	;#0xffef
    b160:	02 00 
    }

    HWREG16(baseAddress + OFS_TAxCCR0) = param->timerPeriod;
    b162:	9a 49 04 00 	mov	4(r9),	18(r10)	; 0x0012
    b166:	12 00 
}
    b168:	30 40 6e d1 	br	#0xd16e		;

0000b16c <Timer_A_initCaptureMode>:

void Timer_A_initCaptureMode(uint16_t baseAddress,
                             Timer_A_initCaptureModeParam *param)
{
    HWREG16(baseAddress + param->captureRegister) |= CAP;
    b16c:	0e 4c       	mov	r12,	r14	;
    b16e:	2e 5d       	add	@r13,	r14	;
    b170:	be d0 00 01 	bis	#256,	0(r14)	;#0x0100
    b174:	00 00 

    HWREG16(baseAddress + param->captureRegister) &=
    b176:	0e 4c       	mov	r12,	r14	;
    b178:	2e 5d       	add	@r13,	r14	;
    b17a:	be f0 f9 47 	and	#18425,	0(r14)	;#0x47f9
    b17e:	00 00 
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          CM_3
          );

    HWREG16(baseAddress + param->captureRegister) |= (param->captureMode +
    b180:	2c 5d       	add	@r13,	r12	;
    b182:	1e 4d 04 00 	mov	4(r13),	r14	;
    b186:	1e 5d 02 00 	add	2(r13),	r14	;
                                                      param->captureInputSelect
                                                      +
    b18a:	1e 5d 06 00 	add	6(r13),	r14	;
                                                      param->
                                                      synchronizeCaptureSource +
    b18e:	1e 5d 08 00 	add	8(r13),	r14	;
                                                      param->
                                                      captureInterruptEnable +
    b192:	1e 5d 0a 00 	add	10(r13),r14	;0x0000a
          TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          CM_3
          );

    HWREG16(baseAddress + param->captureRegister) |= (param->captureMode +
    b196:	8c de 00 00 	bis	r14,	0(r12)	;
                                                      synchronizeCaptureSource +
                                                      param->
                                                      captureInterruptEnable +
                                                      param->captureOutputMode
                                                      );
}
    b19a:	30 41       	ret			

0000b19c <Timer_A_initCompareMode>:

void Timer_A_initCompareMode(uint16_t baseAddress,
                             Timer_A_initCompareModeParam *param)
{
    HWREG16(baseAddress + param->compareRegister) &= ~CAP;
    b19c:	0e 4c       	mov	r12,	r14	;
    b19e:	2e 5d       	add	@r13,	r14	;
    b1a0:	be f0 ff fe 	and	#65279,	0(r14)	;#0xfeff
    b1a4:	00 00 

    HWREG16(baseAddress + param->compareRegister) &=
    b1a6:	0e 4c       	mov	r12,	r14	;
    b1a8:	2e 5d       	add	@r13,	r14	;
    b1aa:	be f0 0f ff 	and	#65295,	0(r14)	;#0xff0f
    b1ae:	00 00 
        ~(TIMER_A_CAPTURECOMPARE_INTERRUPT_ENABLE +
          TIMER_A_OUTPUTMODE_RESET_SET
          );

    HWREG16(baseAddress +
            param->compareRegister) |= (param->compareInterruptEnable +
    b1b0:	0e 4c       	mov	r12,	r14	;
    b1b2:	2e 5d       	add	@r13,	r14	;
    b1b4:	1f 4d 04 00 	mov	4(r13),	r15	;
    b1b8:	1f 5d 02 00 	add	2(r13),	r15	;
    b1bc:	8e df 00 00 	bis	r15,	0(r14)	;
                                        param->compareOutputMode
                                        );

    HWREG16(baseAddress + param->compareRegister +
    b1c0:	2c 5d       	add	@r13,	r12	;
            OFS_TAxR) = param->compareValue;
    b1c2:	9c 4d 06 00 	mov	6(r13),	16(r12)	; 0x0010
    b1c6:	10 00 
}
    b1c8:	30 41       	ret			

0000b1ca <Timer_A_enableInterrupt>:

void Timer_A_enableInterrupt(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_TAxCTL) |= TAIE;
    b1ca:	ac d3 00 00 	bis	#2,	0(r12)	;r3 As==10
}
    b1ce:	30 41       	ret			

0000b1d0 <Timer_A_disableInterrupt>:

void Timer_A_disableInterrupt(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_TAxCTL) &= ~TAIE;
    b1d0:	ac c3 00 00 	bic	#2,	0(r12)	;r3 As==10
}
    b1d4:	30 41       	ret			

0000b1d6 <Timer_A_getInterruptStatus>:

uint32_t Timer_A_getInterruptStatus(uint16_t baseAddress)
{
    return (HWREG16(baseAddress + OFS_TAxCTL) & TAIFG);
}
    b1d6:	2c 4c       	mov	@r12,	r12	;
    b1d8:	1c f3       	and	#1,	r12	;r3 As==01
    b1da:	0d 43       	clr	r13		;
    b1dc:	30 41       	ret			

0000b1de <Timer_A_enableCaptureCompareInterrupt>:

void Timer_A_enableCaptureCompareInterrupt(uint16_t baseAddress,
                                           uint16_t captureCompareRegister)
{
    HWREG16(baseAddress + captureCompareRegister) |= CCIE;
    b1de:	0c 5d       	add	r13,	r12	;
    b1e0:	bc d0 10 00 	bis	#16,	0(r12)	;#0x0010
    b1e4:	00 00 
}
    b1e6:	30 41       	ret			

0000b1e8 <Timer_A_disableCaptureCompareInterrupt>:

void Timer_A_disableCaptureCompareInterrupt(uint16_t baseAddress,
                                            uint16_t captureCompareRegister)
{
    HWREG16(baseAddress + captureCompareRegister) &= ~CCIE;
    b1e8:	0c 5d       	add	r13,	r12	;
    b1ea:	bc f0 ef ff 	and	#65519,	0(r12)	;#0xffef
    b1ee:	00 00 
}
    b1f0:	30 41       	ret			

0000b1f2 <Timer_A_getCaptureCompareInterruptStatus>:

uint32_t Timer_A_getCaptureCompareInterruptStatus(uint16_t baseAddress,
                                                  uint16_t captureCompareRegister,
                                                  uint16_t mask)
{
    return (HWREG16(baseAddress + captureCompareRegister) & mask);
    b1f2:	0c 5d       	add	r13,	r12	;
}
    b1f4:	2c 4c       	mov	@r12,	r12	;
    b1f6:	0c fe       	and	r14,	r12	;
    b1f8:	0d 43       	clr	r13		;
    b1fa:	30 41       	ret			

0000b1fc <Timer_A_clear>:

void Timer_A_clear(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_TAxCTL) |= TACLR;
    b1fc:	ac d2 00 00 	bis	#4,	0(r12)	;r2 As==10
}
    b200:	30 41       	ret			

0000b202 <Timer_A_getSynchronizedCaptureCompareInput>:

uint8_t Timer_A_getSynchronizedCaptureCompareInput(uint16_t baseAddress,
                                                   uint16_t captureCompareRegister,
                                                   uint16_t synchronized)
{
    if(HWREG16(baseAddress + captureCompareRegister) & synchronized)
    b202:	0c 5d       	add	r13,	r12	;
    b204:	2e fc       	and	@r12,	r14	;
    b206:	0c 43       	clr	r12		;
    b208:	0c 8e       	sub	r14,	r12	;
    b20a:	0c de       	bis	r14,	r12	;
    b20c:	b0 12 60 d2 	call	#53856		;#0xd260
    }
    else
    {
        return (TIMER_A_CAPTURECOMPARE_INPUT_LOW);
    }
}
    b210:	30 41       	ret			

0000b212 <Timer_A_getOutputForOutputModeOutBitValue>:

uint8_t Timer_A_getOutputForOutputModeOutBitValue(uint16_t baseAddress,
                                                  uint16_t captureCompareRegister)
{
    if(HWREG16(baseAddress + captureCompareRegister) & OUT)
    b212:	0c 5d       	add	r13,	r12	;
    b214:	ac b2 00 00 	bit	#4,	0(r12)	;r2 As==10
    b218:	03 20       	jnz	$+8      	;abs 0xb220
    {
        return (TIMER_A_OUTPUTMODE_OUTBITVALUE_HIGH);
    }
    else
    {
        return (TIMER_A_OUTPUTMODE_OUTBITVALUE_LOW);
    b21a:	0c 43       	clr	r12		;
    b21c:	30 40 22 b2 	br	#0xb222		;
uint8_t Timer_A_getOutputForOutputModeOutBitValue(uint16_t baseAddress,
                                                  uint16_t captureCompareRegister)
{
    if(HWREG16(baseAddress + captureCompareRegister) & OUT)
    {
        return (TIMER_A_OUTPUTMODE_OUTBITVALUE_HIGH);
    b220:	2c 42       	mov	#4,	r12	;r2 As==10
    }
    else
    {
        return (TIMER_A_OUTPUTMODE_OUTBITVALUE_LOW);
    }
}
    b222:	30 41       	ret			

0000b224 <Timer_A_getCaptureCompareCount>:

uint16_t Timer_A_getCaptureCompareCount(uint16_t baseAddress,
                                        uint16_t captureCompareRegister)
{
    return  (HWREG16(baseAddress + OFS_TAxR + captureCompareRegister));
    b224:	0c 5d       	add	r13,	r12	;
}
    b226:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    b22a:	30 41       	ret			

0000b22c <Timer_A_setOutputForOutputModeOutBitValue>:

void Timer_A_setOutputForOutputModeOutBitValue(uint16_t baseAddress,
                                               uint16_t captureCompareRegister,
                                               uint8_t outputModeOutBitValue)
{
    b22c:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    HWREG16(baseAddress + captureCompareRegister) &= ~OUT;
    b230:	0c 5d       	add	r13,	r12	;
    b232:	ac c2 00 00 	bic	#4,	0(r12)	;r2 As==10
    HWREG16(baseAddress + captureCompareRegister) |= outputModeOutBitValue;
    b236:	8c de 00 00 	bis	r14,	0(r12)	;
}
    b23a:	30 41       	ret			

0000b23c <Timer_A_outputPWM>:

void Timer_A_outputPWM(uint16_t baseAddress,
                       Timer_A_outputPWMParam *param)
{
    b23c:	0a 12       	push	r10		;
    b23e:	09 12       	push	r9		;
    b240:	08 12       	push	r8		;
    b242:	07 12       	push	r7		;
    b244:	0a 4c       	mov	r12,	r10	;
    b246:	09 4d       	mov	r13,	r9	;
    HWREG16(baseAddress + OFS_TAxCTL) &=
    b248:	bc f0 09 fc 	and	#64521,	0(r12)	;#0xfc09
    b24c:	00 00 
        ~(TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK +
          TIMER_A_UPDOWN_MODE + TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b24e:	28 4c       	mov	@r12,	r8	;
    b250:	27 4d       	mov	@r13,	r7	;
    b252:	37 50 14 00 	add	#20,	r7	;#0x0014
                                          TIMER_A_UP_MODE +
                                          TIMER_A_DO_CLEAR +
                                          ((param->clockSourceDivider >>
    b256:	1c 4d 02 00 	mov	2(r13),	r12	;
    b25a:	b0 12 90 d2 	call	#53904		;#0xd290
                                            3) << 6));
    b25e:	0c 5c       	rla	r12		;
    b260:	0e 4c       	mov	r12,	r14	;
    b262:	0e 5c       	add	r12,	r14	;
    b264:	0e 5e       	rla	r14		;
    b266:	0e 5e       	rla	r14		;
    b268:	0e 5e       	rla	r14		;
    b26a:	0e 5e       	rla	r14		;
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
                                          TIMER_A_UP_MODE +
                                          TIMER_A_DO_CLEAR +
    b26c:	07 5e       	add	r14,	r7	;
        ~(TIMER_A_CLOCKSOURCE_INVERTED_EXTERNAL_TXCLK +
          TIMER_A_UPDOWN_MODE + TIMER_A_DO_CLEAR +
          TIMER_A_TAIE_INTERRUPT_ENABLE +
          ID__8
          );
    HWREG16(baseAddress + OFS_TAxCTL) |= (param->clockSource +
    b26e:	08 d7       	bis	r7,	r8	;
    b270:	8a 48 00 00 	mov	r8,	0(r10)	;
                                          TIMER_A_UP_MODE +
                                          TIMER_A_DO_CLEAR +
                                          ((param->clockSourceDivider >>
                                            3) << 6));

    HWREG16(baseAddress + OFS_TAxCCR0) = param->timerPeriod;
    b274:	9a 49 04 00 	mov	4(r9),	18(r10)	; 0x0012
    b278:	12 00 

    HWREG16(baseAddress + OFS_TAxCCTL0) &=
    b27a:	ba f0 0f ff 	and	#65295,	2(r10)	;#0xff0f
    b27e:	02 00 
        ~(TIMER_A_CAPTURECOMPARE_INTERRUPT_ENABLE +
          TIMER_A_OUTPUTMODE_RESET_SET);

    HWREG16(baseAddress + param->compareRegister) |= param->compareOutputMode;
    b280:	0c 4a       	mov	r10,	r12	;
    b282:	1c 59 06 00 	add	6(r9),	r12	;
    b286:	9c d9 08 00 	bis	8(r9),	0(r12)	;
    b28a:	00 00 

    HWREG16(baseAddress + param->compareRegister + OFS_TAxR) = param->dutyCycle;
    b28c:	1a 59 06 00 	add	6(r9),	r10	;
    b290:	9a 49 0a 00 	mov	10(r9),	16(r10)	;0x0000a, 0x0010
    b294:	10 00 
}
    b296:	30 40 6e d1 	br	#0xd16e		;

0000b29a <Timer_A_stop>:

void Timer_A_stop(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_TAxCTL) &= ~MC_3;
    b29a:	bc f0 cf ff 	and	#65487,	0(r12)	;#0xffcf
    b29e:	00 00 
}
    b2a0:	30 41       	ret			

0000b2a2 <Timer_A_setCompareValue>:

void Timer_A_setCompareValue(uint16_t baseAddress,
                             uint16_t compareRegister,
                             uint16_t compareValue)
{
    HWREG16(baseAddress + compareRegister + OFS_TAxR) = compareValue;
    b2a2:	0c 5d       	add	r13,	r12	;
    b2a4:	8c 4e 10 00 	mov	r14,	16(r12)	; 0x0010
}
    b2a8:	30 41       	ret			

0000b2aa <Timer_A_setOutputMode>:

void Timer_A_setOutputMode(uint16_t baseAddress,
                           uint16_t compareRegister,
                           uint16_t compareOutputMode)
{
    uint16_t temp = HWREG16(baseAddress + compareRegister);
    b2aa:	0c 5d       	add	r13,	r12	;
    HWREG16(baseAddress +
            compareRegister) = (temp & ~(OUTMOD_7)) | compareOutputMode;
    b2ac:	2d 4c       	mov	@r12,	r13	;
    b2ae:	3d f0 1f ff 	and	#65311,	r13	;#0xff1f
    b2b2:	0d de       	bis	r14,	r13	;
    b2b4:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    b2b8:	30 41       	ret			

0000b2ba <Timer_A_clearTimerInterrupt>:

void Timer_A_clearTimerInterrupt(uint16_t baseAddress)
{
    HWREG16(baseAddress + OFS_TAxCTL) &= ~TAIFG;
    b2ba:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    b2be:	30 41       	ret			

0000b2c0 <Timer_A_clearCaptureCompareInterrupt>:

void Timer_A_clearCaptureCompareInterrupt(uint16_t baseAddress,
                                          uint16_t captureCompareRegister)
{
    HWREG16(baseAddress + captureCompareRegister) &= ~CCIFG;
    b2c0:	0c 5d       	add	r13,	r12	;
    b2c2:	9c c3 00 00 	bic	#1,	0(r12)	;r3 As==01
}
    b2c6:	30 41       	ret			

0000b2c8 <Timer_A_getCounterValue>:

uint16_t Timer_A_getCounterValue(uint16_t baseAddress)
{
    uint16_t voteOne, voteTwo, res;

    voteTwo = HWREG16(baseAddress + OFS_TAxR);
    b2c8:	0f 4c       	mov	r12,	r15	;
    b2ca:	3f 50 10 00 	add	#16,	r15	;#0x0010
    b2ce:	2d 4f       	mov	@r15,	r13	;
        else
        {
            res = 0;
        }
    }
    while(res > TIMER_A_THRESHOLD);
    b2d0:	3b 40 32 00 	mov	#50,	r11	;#0x0032
    voteTwo = HWREG16(baseAddress + OFS_TAxR);

    do
    {
        voteOne = voteTwo;
        voteTwo = HWREG16(baseAddress + OFS_TAxR);
    b2d4:	2c 4f       	mov	@r15,	r12	;

        if(voteTwo > voteOne)
    b2d6:	0d 9c       	cmp	r12,	r13	;
    b2d8:	04 2c       	jc	$+10     	;abs 0xb2e2
        {
            res = voteTwo - voteOne;
    b2da:	0e 4c       	mov	r12,	r14	;
    b2dc:	0e 8d       	sub	r13,	r14	;
    b2de:	30 40 ea b2 	br	#0xb2ea		;
        }
        else if(voteOne > voteTwo)
    b2e2:	0c 9d       	cmp	r13,	r12	;
    b2e4:	05 2c       	jc	$+12     	;abs 0xb2f0
        {
            res = voteOne - voteTwo;
    b2e6:	0e 4d       	mov	r13,	r14	;
    b2e8:	0e 8c       	sub	r12,	r14	;
    voteTwo = HWREG16(baseAddress + OFS_TAxR);

    do
    {
        voteOne = voteTwo;
        voteTwo = HWREG16(baseAddress + OFS_TAxR);
    b2ea:	0d 4c       	mov	r12,	r13	;
        else
        {
            res = 0;
        }
    }
    while(res > TIMER_A_THRESHOLD);
    b2ec:	0b 9e       	cmp	r14,	r11	;
    b2ee:	f2 2b       	jnc	$-26     	;abs 0xb2d4

    return(voteTwo);
}
    b2f0:	30 41       	ret			

0000b2f2 <TLV_getInfo>:

#include <assert.h>

void TLV_getInfo(uint8_t tag,
                 uint8_t *length,
                 uint16_t **data_address) {
    b2f2:	0a 12       	push	r10		;
    b2f4:	09 12       	push	r9		;
    b2f6:	08 12       	push	r8		;
    b2f8:	4a 4c       	mov.b	r12,	r10	;
    b2fa:	08 4d       	mov	r13,	r8	;
    b2fc:	09 4e       	mov	r14,	r9	;
    // Get access type
    *length = (tag & 0xC0) >> 5;
    b2fe:	0c 4a       	mov	r10,	r12	;
    b300:	3c f0 c0 00 	and	#192,	r12	;#0x00c0
    b304:	b0 12 00 d2 	call	#53760		;#0xd200
    b308:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    if(*length == 0)
    b30c:	0c 93       	cmp	#0,	r12	;r3 As==00
    b30e:	04 24       	jz	$+10     	;abs 0xb318

void TLV_getInfo(uint8_t tag,
                 uint8_t *length,
                 uint16_t **data_address) {
    // Get access type
    *length = (tag & 0xC0) >> 5;
    b310:	c8 4c 00 00 	mov.b	r12,	0(r8)	;
    b314:	30 40 1c b3 	br	#0xb31c		;
    if(*length == 0)
    {
        *length = 1;
    b318:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01
    }

    *data_address = ((uint16_t *)((uint16_t)(TLV_START + (tag & 0x3F))));
    b31c:	3a f0 3f 00 	and	#63,	r10	;#0x003f
    b320:	3a 50 c0 13 	add	#5056,	r10	;#0x13c0
    b324:	89 4a 00 00 	mov	r10,	0(r9)	;

    return;
}
    b328:	30 40 70 d1 	br	#0xd170		;

0000b32c <TLV_performChecksumCheck>:

bool TLV_performChecksumCheck(void) {
    b32c:	3c 40 c2 13 	mov	#5058,	r12	;#0x13c2
    uint16_t checksum = 0;
    b330:	0d 43       	clr	r13		;
    uint16_t *tlv_address = ((uint16_t *)TLV_START) + TLV_CHKSUM_L + 1;
    uint16_t *tlv_end = (uint16_t *) TLV_END;

    do
    {
        checksum ^= *tlv_address++;
    b332:	2d ec       	xor	@r12,	r13	;
    b334:	2c 53       	incd	r12		;
    }
    while(tlv_address <= tlv_end);
    b336:	3c 90 00 14 	cmp	#5120,	r12	;#0x1400
    b33a:	fb 23       	jnz	$-8      	;abs 0xb332

    checksum ^= 0xFFFF;
    checksum++;

    if(checksum == HWREG16(TLV_START + TLV_CHKSUM_L))
    b33c:	1e 42 c0 13 	mov	&0x13c0,r14	;0x13c0
        checksum ^= *tlv_address++;
    }
    while(tlv_address <= tlv_end);

    checksum ^= 0xFFFF;
    checksum++;
    b340:	0f 43       	clr	r15		;
    b342:	0f 8d       	sub	r13,	r15	;

    if(checksum == HWREG16(TLV_START + TLV_CHKSUM_L))
    b344:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b346:	0f 9e       	cmp	r14,	r15	;
    b348:	01 24       	jz	$+4      	;abs 0xb34c
    b34a:	4c 43       	clr.b	r12		;
    }
    else
    {
        return(false);
    }
}
    b34c:	30 41       	ret			

0000b34e <WDT_hold>:

void WDT_hold(uint16_t baseAddress)
{
    // Set Hold bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTHOLD);
    b34e:	2d 4c       	mov	@r12,	r13	;
#include <assert.h>

void WDT_hold(uint16_t baseAddress)
{
    // Set Hold bit
    uint8_t newWDTStatus =
    b350:	7d d0 80 ff 	bis.b	#65408,	r13	;#0xff80
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTHOLD);

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    b354:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    b358:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    b35c:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    b360:	30 41       	ret			

0000b362 <WDT_start>:
{
    // Reset Hold bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) & ~(WDTHOLD));

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    b362:	2d 4c       	mov	@r12,	r13	;
    b364:	3d f0 7f 00 	and	#127,	r13	;#0x007f
    b368:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    b36c:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    b370:	30 41       	ret			

0000b372 <WDT_resetTimer>:

void WDT_resetTimer(uint16_t baseAddress)
{
    // Set Counter Clear bit
    uint8_t newWDTStatus =
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTCNTCL);
    b372:	2d 4c       	mov	@r12,	r13	;
}

void WDT_resetTimer(uint16_t baseAddress)
{
    // Set Counter Clear bit
    uint8_t newWDTStatus =
    b374:	7d d2       	bis.b	#8,	r13	;r2 As==11
        ((HWREG16(baseAddress + OFS_WDTCTL) & 0x00FF) | WDTCNTCL);

    HWREG16(baseAddress + OFS_WDTCTL) = WDTPW + newWDTStatus;
    b376:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    b37a:	3d 50 00 5a 	add	#23040,	r13	;#0x5a00
    b37e:	8c 4d 00 00 	mov	r13,	0(r12)	;
}
    b382:	30 41       	ret			

0000b384 <WDT_initWatchdogTimer>:

void WDT_initWatchdogTimer(uint16_t baseAddress,
                           uint8_t clockSelect,
                           uint8_t clockDivider)
{
    b384:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    b388:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    HWREG16(baseAddress + OFS_WDTCTL) =
        WDTPW + WDTCNTCL + WDTHOLD + clockSelect + clockDivider;
    b38c:	3d 50 88 5a 	add	#23176,	r13	;#0x5a88

void WDT_initWatchdogTimer(uint16_t baseAddress,
                           uint8_t clockSelect,
                           uint8_t clockDivider)
{
    HWREG16(baseAddress + OFS_WDTCTL) =
    b390:	0d 5e       	add	r14,	r13	;
    b392:	8c 4d 00 00 	mov	r13,	0(r12)	;
        WDTPW + WDTCNTCL + WDTHOLD + clockSelect + clockDivider;
}
    b396:	30 41       	ret			

0000b398 <WDT_initIntervalTimer>:

void WDT_initIntervalTimer(uint16_t baseAddress,
                           uint8_t clockSelect,
                           uint8_t clockDivider)
{
    b398:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    b39c:	3e f0 ff 00 	and	#255,	r14	;#0x00ff
    HWREG16(baseAddress + OFS_WDTCTL) =
        WDTPW + WDTCNTCL + WDTHOLD + WDTTMSEL + clockSelect + clockDivider;
    b3a0:	3d 50 98 5a 	add	#23192,	r13	;#0x5a98

void WDT_initIntervalTimer(uint16_t baseAddress,
                           uint8_t clockSelect,
                           uint8_t clockDivider)
{
    HWREG16(baseAddress + OFS_WDTCTL) =
    b3a4:	0d 5e       	add	r14,	r13	;
    b3a6:	8c 4d 00 00 	mov	r13,	0(r12)	;
        WDTPW + WDTCNTCL + WDTHOLD + WDTTMSEL + clockSelect + clockDivider;
}
    b3aa:	30 41       	ret			

0000b3ac <fifo_add>:
static uint8_t* tx_writeptr = &tx_buf[0];		//Where new data should be added
static uint8_t* tx_end = &tx_buf[TXBUF_LEN-1];
static uint8_t* tx_start = &tx_buf[0];
static uint16_t tx_buff_count = 0;

void fifo_add(uint8_t byte){
    b3ac:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
	if(tx_buff_count > TXBUF_LEN) return;
    b3b0:	1d 42 2c 02 	mov	&0x022c,r13	;0x022c
    b3b4:	3e 40 f4 01 	mov	#500,	r14	;#0x01f4
    b3b8:	0e 9d       	cmp	r13,	r14	;
    b3ba:	14 28       	jnc	$+42     	;abs 0xb3e4
	*tx_writeptr++ = byte;
    b3bc:	1f 42 04 02 	mov	&0x0204,r15	;0x0204
    b3c0:	0e 4f       	mov	r15,	r14	;
    b3c2:	1e 53       	inc	r14		;
    b3c4:	82 4e 04 02 	mov	r14,	&0x0204	;
    b3c8:	cf 4c 00 00 	mov.b	r12,	0(r15)	;
	tx_buff_count++;
    b3cc:	1d 53       	inc	r13		;
    b3ce:	82 4d 2c 02 	mov	r13,	&0x022c	;
	if(tx_writeptr > tx_end) tx_writeptr = tx_start;
    b3d2:	3c 40 21 04 	mov	#1057,	r12	;#0x0421
    b3d6:	0c 9e       	cmp	r14,	r12	;
    b3d8:	03 2c       	jc	$+8      	;abs 0xb3e0
    b3da:	b2 40 2e 02 	mov	#558,	&0x0204	;#0x022e
    b3de:	04 02 
	UCA0IE |= UCTXIE;
    b3e0:	a2 d3 5a 01 	bis	#2,	&0x015a	;r3 As==10
}
    b3e4:	30 41       	ret			

0000b3e6 <fifo_get>:

/* return 0 when no more bytes are in the fifo*/
uint16_t fifo_get(uint8_t* byte){
	uint8_t ret = tx_buff_count;
    b3e6:	1d 42 2c 02 	mov	&0x022c,r13	;0x022c
	if(tx_buff_count){
    b3ea:	0d 93       	cmp	#0,	r13	;r3 As==00
    b3ec:	13 24       	jz	$+40     	;abs 0xb414
		*byte = *tx_readptr++;
    b3ee:	1f 42 06 02 	mov	&0x0206,r15	;0x0206
    b3f2:	0e 4f       	mov	r15,	r14	;
    b3f4:	1e 53       	inc	r14		;
    b3f6:	82 4e 06 02 	mov	r14,	&0x0206	;
    b3fa:	ec 4f 00 00 	mov.b	@r15,	0(r12)	;
		tx_buff_count--;
    b3fe:	0c 4d       	mov	r13,	r12	;
    b400:	3c 53       	add	#-1,	r12	;r3 As==11
    b402:	82 4c 2c 02 	mov	r12,	&0x022c	;
		if(tx_readptr > tx_end) tx_readptr = tx_start;
    b406:	3c 40 21 04 	mov	#1057,	r12	;#0x0421
    b40a:	0c 9e       	cmp	r14,	r12	;
    b40c:	03 2c       	jc	$+8      	;abs 0xb414
    b40e:	b2 40 2e 02 	mov	#558,	&0x0206	;#0x022e
    b412:	06 02 
	}
	return ret;
}
    b414:	4c 4d       	mov.b	r13,	r12	;
    b416:	30 41       	ret			

0000b418 <fifo_getavilable>:

uint16_t fifo_getavilable(){
	return TXBUF_LEN - tx_buff_count;
}
    b418:	3c 40 f4 01 	mov	#500,	r12	;#0x01f4
    b41c:	1c 82 2c 02 	sub	&0x022c,r12	;0x022c
    b420:	30 41       	ret			

0000b422 <puts>:
 * puts() is used by printf() to display or send a string.. This function
 *     determines where printf prints to. For this case it sends a string
 *     out over UART, another option could be to display the string on an
 *     LCD display.
 **/
void puts(char *s) {
    b422:	0a 12       	push	r10		;
    b424:	09 12       	push	r9		;
	uint8_t c;
	while ((c = *s++)) {
    b426:	0a 4c       	mov	r12,	r10	;
    b428:	1a 53       	inc	r10		;
    b42a:	6c 4c       	mov.b	@r12,	r12	;
    b42c:	0c 93       	cmp	#0,	r12	;r3 As==00
    b42e:	08 24       	jz	$+18     	;abs 0xb440
		fifo_add(c);
    b430:	39 40 ac b3 	mov	#45996,	r9	;#0xb3ac
    b434:	89 12       	call	r9		;
    b436:	1a 53       	inc	r10		;
 *     out over UART, another option could be to display the string on an
 *     LCD display.
 **/
void puts(char *s) {
	uint8_t c;
	while ((c = *s++)) {
    b438:	5c 4a ff ff 	mov.b	-1(r10),r12	;
    b43c:	0c 93       	cmp	#0,	r12	;r3 As==00
    b43e:	fa 23       	jnz	$-10     	;abs 0xb434
		fifo_add(c);
	}
}
    b440:	30 40 72 d1 	br	#0xd172		;

0000b444 <putc>:
 * puts() is used by printf() to display or send a character. This function
 *     determines where printf prints to. For this case it sends a character
 *     out over UART.
 **/
void putc(uint8_t b) {
	fifo_add(b);
    b444:	b0 12 ac b3 	call	#45996		;#0xb3ac
}
    b448:	30 41       	ret			

0000b44a <USCI_A0_ISR>:

__attribute__((interrupt(USCI_A0_VECTOR))) void USCI_A0_ISR(void) {
    b44a:	0f 12       	push	r15		;
    b44c:	0e 12       	push	r14		;
    b44e:	0d 12       	push	r13		;
    b450:	0c 12       	push	r12		;
    b452:	0b 12       	push	r11		;
    b454:	0a 12       	push	r10		;
    b456:	09 12       	push	r9		;
    b458:	08 12       	push	r8		;
    b45a:	07 12       	push	r7		;
    b45c:	06 12       	push	r6		;
    b45e:	05 12       	push	r5		;
    b460:	04 12       	push	r4		;
    b462:	21 83       	decd	r1		;
	uint8_t byte;
	switch(__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG))
    b464:	1c 42 5e 01 	mov	&0x015e,r12	;0x015e
    b468:	2c 93       	cmp	#2,	r12	;r3 As==10
    b46a:	04 24       	jz	$+10     	;abs 0xb474
    b46c:	2c 92       	cmp	#4,	r12	;r2 As==10
    b46e:	07 24       	jz	$+16     	;abs 0xb47e
    b470:	30 40 9e b4 	br	#0xb49e		;
//		//if (r == 't')						// 'u' received?
//		{
//			FLAGS |= TX;					// Set flag to transmit data
//			__bic_SR_register_on_exit(LPM3_bits);	// Wake-up CPU
//		}
		UCA0TXBUF = UCA0RXBUF;	//Echo what comes in
    b474:	92 42 4c 01 	mov	&0x014c,&0x014e	;0x014c
    b478:	4e 01 
		break;
    b47a:	30 40 9e b4 	br	#0xb49e		;
	case USCI_UART_UCTXIFG:
		if(fifo_get(&byte)){
    b47e:	0c 41       	mov	r1,	r12	;
    b480:	1c 53       	inc	r12		;
    b482:	b0 12 e6 b3 	call	#46054		;#0xb3e6
    b486:	0c 93       	cmp	#0,	r12	;r3 As==00
    b488:	08 24       	jz	$+18     	;abs 0xb49a
			UCA0TXBUF = byte;
    b48a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    b48e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    b492:	82 4c 4e 01 	mov	r12,	&0x014e	;
    b496:	30 40 9e b4 	br	#0xb49e		;
		}
		else{	//Nothing more to send
            UCA0IE &= ~UCTXIE;
    b49a:	a2 c3 5a 01 	bic	#2,	&0x015a	;r3 As==10
		break;
	case USCI_UART_UCSTTIFG: break;
	case USCI_UART_UCTXCPTIFG: break;
	default: break;
	}
}
    b49e:	21 53       	incd	r1		;
    b4a0:	34 41       	pop	r4		;
    b4a2:	35 41       	pop	r5		;
    b4a4:	36 41       	pop	r6		;
    b4a6:	37 41       	pop	r7		;
    b4a8:	38 41       	pop	r8		;
    b4aa:	39 41       	pop	r9		;
    b4ac:	3a 41       	pop	r10		;
    b4ae:	3b 41       	pop	r11		;
    b4b0:	3c 41       	pop	r12		;
    b4b2:	3d 41       	pop	r13		;
    b4b4:	3e 41       	pop	r14		;
    b4b6:	3f 41       	pop	r15		;
    b4b8:	00 13       	reti			

0000b4ba <tlv_setup>:
#include "communication.h"
#include "metrology-background.h"

//static inline
void tlv_setup (void)
{
    b4ba:	0a 12       	push	r10		;
    b4bc:	21 83       	decd	r1		;
	// Check the TLV checksum
	if(!TLV_performChecksumCheck()) return;
    b4be:	b0 12 2c b3 	call	#45868		;#0xb32c
    b4c2:	4c 93       	cmp.b	#0,	r12	;r3 As==00
    b4c4:	3a 24       	jz	$+118    	;abs 0xb53a

	uint16_t *data_address;
	TLV_getInfo(TLV_REF_CALIBRATION_REFCAL0, 0, &data_address);
    b4c6:	3a 40 f2 b2 	mov	#45810,	r10	;#0xb2f2
    b4ca:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    b4ce:	0d 43       	clr	r13		;
    b4d0:	0e 41       	mov	r1,	r14	;
    b4d2:	8a 12       	call	r10		;
	REFCAL0 = *(uint8_t *)data_address;
    b4d4:	2c 41       	mov	@r1,	r12	;
    b4d6:	e2 4c 62 00 	mov.b	@r12,	&0x0062	;
	TLV_getInfo(TLV_REF_CALIBRATION_REFCAL1, 0, &data_address);
    b4da:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    b4de:	0d 43       	clr	r13		;
    b4e0:	0e 41       	mov	r1,	r14	;
    b4e2:	8a 12       	call	r10		;
	REFCAL1 = *(uint8_t *)data_address;
    b4e4:	2c 41       	mov	@r1,	r12	;
    b4e6:	e2 4c 63 00 	mov.b	@r12,	&0x0063	;
	TLV_getInfo(TLV_DCO_CALIBRATION_CSIRFCAL, 0, &data_address);
    b4ea:	7c 40 14 00 	mov.b	#20,	r12	;#0x0014
    b4ee:	0d 43       	clr	r13		;
    b4f0:	0e 41       	mov	r1,	r14	;
    b4f2:	8a 12       	call	r10		;
	CSIRFCAL = *(uint8_t *)data_address;
    b4f4:	2c 41       	mov	@r1,	r12	;
    b4f6:	e2 4c 52 00 	mov.b	@r12,	&0x0052	;
	TLV_getInfo(TLV_DCO_CALIBRATION_CSIRTCAL, 0, &data_address);
    b4fa:	7c 40 15 00 	mov.b	#21,	r12	;#0x0015
    b4fe:	0d 43       	clr	r13		;
    b500:	0e 41       	mov	r1,	r14	;
    b502:	8a 12       	call	r10		;
	CSIRTCAL = *(uint8_t *)data_address;
    b504:	2c 41       	mov	@r1,	r12	;
    b506:	e2 4c 53 00 	mov.b	@r12,	&0x0053	;
	TLV_getInfo(TLV_DCO_CALIBRATION_CSERFCAL, 0, &data_address);
    b50a:	7c 40 16 00 	mov.b	#22,	r12	;#0x0016
    b50e:	0d 43       	clr	r13		;
    b510:	0e 41       	mov	r1,	r14	;
    b512:	8a 12       	call	r10		;
	CSERFCAL = *(uint8_t *)data_address;
    b514:	2c 41       	mov	@r1,	r12	;
    b516:	e2 4c 54 00 	mov.b	@r12,	&0x0054	;
	TLV_getInfo(TLV_DCO_CALIBRATION_CSERTCAL, 0, &data_address);
    b51a:	7c 40 17 00 	mov.b	#23,	r12	;#0x0017
    b51e:	0d 43       	clr	r13		;
    b520:	0e 41       	mov	r1,	r14	;
    b522:	8a 12       	call	r10		;
	CSERTCAL = *(uint8_t *)data_address;
    b524:	2c 41       	mov	@r1,	r12	;
    b526:	e2 4c 55 00 	mov.b	@r12,	&0x0055	;
	TLV_getInfo(TLV_SD24_CALIBRATION_TAG, 0, &data_address);
    b52a:	7c 40 18 00 	mov.b	#24,	r12	;#0x0018
    b52e:	0d 43       	clr	r13		;
    b530:	0e 41       	mov	r1,	r14	;
    b532:	8a 12       	call	r10		;
	SD24TRIM = *(uint8_t *)data_address;
    b534:	2c 41       	mov	@r1,	r12	;
    b536:	e2 4c bf 00 	mov.b	@r12,	&0x00bf	;
}
    b53a:	21 53       	incd	r1		;
    b53c:	3a 41       	pop	r10		;
    b53e:	30 41       	ret			

0000b540 <uart_setup>:

void uart_setup(){
    b540:	31 80 10 00 	sub	#16,	r1	;#0x0010
	/* Configure the port with the reset bit held high */
	EUSCI_A_UART_initParam uartConfig = {
    b544:	f1 40 80 ff 	mov.b	#65408,	0(r1)	;#0xff80
    b548:	00 00 
    b54a:	b1 42 02 00 	mov	#8,	2(r1)	;r2 As==11
    b54e:	f1 40 0e 00 	mov.b	#14,	4(r1)	;#0x000e
    b552:	04 00 
    b554:	f1 40 22 00 	mov.b	#34,	5(r1)	;#0x0022
    b558:	05 00 
    b55a:	c1 43 06 00 	mov.b	#0,	6(r1)	;r3 As==00
    b55e:	81 43 08 00 	mov	#0,	8(r1)	;r3 As==00
    b562:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a
    b566:	81 43 0c 00 	mov	#0,	12(r1)	;r3 As==00, 0x000c
    b56a:	d1 43 0e 00 	mov.b	#1,	14(r1)	;r3 As==01, 0x000e
			EUSCI_A_UART_ONE_STOP_BIT,               // One stop bit
			EUSCI_A_UART_MODE,                       // UART mode
			EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION  // Oversampling Baudrate
	};

	UCA0TXBUF = 0;
    b56e:	82 43 4e 01 	mov	#0,	&0x014e	;r3 As==00

	// Settings P1.2 and P1.3 as UART pins. P1.4 as LED output
	GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1,
    b572:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b574:	3d 40 0c 00 	mov	#12,	r13	;#0x000c
    b578:	4e 4c       	mov.b	r12,	r14	;
    b57a:	b0 12 6c ab 	call	#43884		;#0xab6c
			GPIO_PIN2 | GPIO_PIN3,
			GPIO_PRIMARY_MODULE_FUNCTION);
	GPIO_setAsOutputPin(GPIO_PORT_P1, GPIO_PIN4);
    b57e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b580:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    b584:	b0 12 b2 aa 	call	#43698		;#0xaab2
	GPIO_setOutputLowOnPin(GPIO_PORT_P1, GPIO_PIN4);
    b588:	5c 43       	mov.b	#1,	r12	;r3 As==01
    b58a:	3d 40 10 00 	mov	#16,	r13	;#0x0010
    b58e:	b0 12 ee ab 	call	#44014		;#0xabee

	// Configure and enable the UART peripheral
	EUSCI_A_UART_init(EUSCI_A0_BASE, &uartConfig);
    b592:	3c 40 40 01 	mov	#320,	r12	;#0x0140
    b596:	0d 41       	mov	r1,	r13	;
    b598:	b0 12 36 a1 	call	#41270		;#0xa136
	EUSCI_A_UART_enable(EUSCI_A0_BASE);
    b59c:	3c 40 40 01 	mov	#320,	r12	;#0x0140
    b5a0:	b0 12 4e a2 	call	#41550		;#0xa24e

	EUSCI_A_UART_enableInterrupt(EUSCI_A0_BASE,
    b5a4:	3c 40 40 01 	mov	#320,	r12	;#0x0140
    b5a8:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b5aa:	b0 12 0c a2 	call	#41484		;#0xa20c
			EUSCI_A_UART_RECEIVE_INTERRUPT);
}
    b5ae:	31 50 10 00 	add	#16,	r1	;#0x0010
    b5b2:	30 41       	ret			

0000b5b4 <adc_setup>:

void adc_setup(){
    b5b4:	0a 12       	push	r10		;
    b5b6:	31 80 0c 00 	sub	#12,	r1	;#0x000c
	// Internal ref
	SD24_init(SD24_BASE, SD24_REF_INTERNAL);
    b5ba:	3c 40 b0 00 	mov	#176,	r12	;#0x00b0
    b5be:	6d 42       	mov.b	#4,	r13	;r2 As==10
    b5c0:	b0 12 f6 ad 	call	#44534		;#0xadf6

	//Group with Channel 0
	SD24_initConverterAdvancedParam param = {0};
    b5c4:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    b5c8:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
    b5cc:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    b5d0:	81 43 0a 00 	mov	#0,	10(r1)	;r3 As==00, 0x000a
	param.converter = SD24_CONVERTER_0;
	param.conversionMode = SD24_CONTINUOUS_MODE;
	param.groupEnable = SD24_GROUPED;
    b5d4:	d1 43 04 00 	mov.b	#1,	4(r1)	;r3 As==01
	param.inputChannel = SD24_INPUT_CH_ANALOG;
	param.dataFormat = SD24_DATA_FORMAT_2COMPLEMENT;
    b5d8:	f1 40 10 00 	mov.b	#16,	6(r1)	;#0x0010
    b5dc:	06 00 
	param.interruptDelay = SD24_FIRST_SAMPLE_INTERRUPT;
    b5de:	f1 40 40 00 	mov.b	#64,	7(r1)	;#0x0040
    b5e2:	07 00 
#if (OSR_FILTER == 256)
	param.oversampleRatio = SD24_OVERSAMPLE_256;
#else
	param.oversampleRatio = SD24_OVERSAMPLE_128;
    b5e4:	b1 40 00 01 	mov	#256,	8(r1)	;#0x0100
    b5e8:	08 00 
#endif
	param.gain = SD24_GAIN_1;
	SD24_initConverterAdvanced(SD24_BASE, &param);
    b5ea:	3a 40 2c ae 	mov	#44588,	r10	;#0xae2c
    b5ee:	3c 40 b0 00 	mov	#176,	r12	;#0x00b0
    b5f2:	0d 41       	mov	r1,	r13	;
    b5f4:	8a 12       	call	r10		;

	//Group with Channel 1
	param.converter = SD24_CONVERTER_1;
    b5f6:	d1 43 00 00 	mov.b	#1,	0(r1)	;r3 As==01
	param.conversionMode = SD24_CONTINUOUS_MODE;
    b5fa:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00
	param.groupEnable = SD24_NOT_GROUPED;
    b5fe:	c1 43 04 00 	mov.b	#0,	4(r1)	;r3 As==00
	param.inputChannel = SD24_INPUT_CH_ANALOG;
    b602:	c1 43 05 00 	mov.b	#0,	5(r1)	;r3 As==00
	param.dataFormat = SD24_DATA_FORMAT_2COMPLEMENT;
    b606:	f1 40 10 00 	mov.b	#16,	6(r1)	;#0x0010
    b60a:	06 00 
	param.interruptDelay = SD24_FIRST_SAMPLE_INTERRUPT;
    b60c:	f1 40 40 00 	mov.b	#64,	7(r1)	;#0x0040
    b610:	07 00 
#if (OSR_FILTER == 256)
	param.oversampleRatio = SD24_OVERSAMPLE_256;
#else
	param.oversampleRatio = SD24_OVERSAMPLE_128;
    b612:	b1 40 00 01 	mov	#256,	8(r1)	;#0x0100
    b616:	08 00 
#endif
	param.gain = SD24_GAIN_1;
    b618:	c1 43 0a 00 	mov.b	#0,	10(r1)	;r3 As==00, 0x000a
	SD24_initConverterAdvanced(SD24_BASE, &param);
    b61c:	3c 40 b0 00 	mov	#176,	r12	;#0x00b0
    b620:	0d 41       	mov	r1,	r13	;
    b622:	8a 12       	call	r10		;
	SD24_enableInterrupt(SD24_BASE, SD24_CONVERTER_1, SD24_CONVERTER_INTERRUPT);
    b624:	3c 40 b0 00 	mov	#176,	r12	;#0x00b0
    b628:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b62a:	2e 42       	mov	#4,	r14	;r2 As==10
    b62c:	b0 12 c0 af 	call	#44992		;#0xafc0

	// Delay ~200us for 1.2V ref to settle
	__delay_cycles(3200);
    b630:	0d 12       	push	r13		;
    b632:	3d 40 28 04 	mov	#1064,	r13	;#0x0428
    b636:	1d 83       	dec	r13		;
    b638:	fe 23       	jnz	$-2      	;abs 0xb636
    b63a:	3d 41       	pop	r13		;
    b63c:	03 43       	nop			
}
    b63e:	31 50 0c 00 	add	#12,	r1	;#0x000c
    b642:	3a 41       	pop	r10		;
    b644:	30 41       	ret			

0000b646 <main>:

int main(void) {
    b646:	0a 12       	push	r10		;
	// Stop WDT
	WDT_hold(WDT_BASE);
    b648:	3c 40 20 01 	mov	#288,	r12	;#0x0120
    b64c:	b0 12 4e b3 	call	#45902		;#0xb34e

	// LED for indicating checksum result (Blue)
	GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN1);
    b650:	3a 40 b2 aa 	mov	#43698,	r10	;#0xaab2
    b654:	6c 43       	mov.b	#2,	r12	;r3 As==10
    b656:	2d 43       	mov	#2,	r13	;r3 As==10
    b658:	8a 12       	call	r10		;
	GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN1);
    b65a:	6c 43       	mov.b	#2,	r12	;r3 As==10
    b65c:	2d 43       	mov	#2,	r13	;r3 As==10
    b65e:	b0 12 c8 ab 	call	#43976		;#0xabc8
	tlv_setup();
    b662:	b0 12 ba b4 	call	#46266		;#0xb4ba

	//Set LED Pin
	GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN2);
    b666:	6c 43       	mov.b	#2,	r12	;r3 As==10
    b668:	2d 42       	mov	#4,	r13	;r2 As==10
    b66a:	8a 12       	call	r10		;

	uart_setup();
    b66c:	b0 12 40 b5 	call	#46400		;#0xb540
	adc_setup();
    b670:	b0 12 b4 b5 	call	#46516		;#0xb5b4

	_enable_interrupts();
    b674:	32 d2       	eint			
    b676:	03 43       	nop			
	metrology_start();
    b678:	b0 12 88 b7 	call	#46984		;#0xb788

	while(1) {
		//volatile unsigned int i;	// volatile to prevent optimization

		metrology_print_status();
    b67c:	3a 40 94 b7 	mov	#46996,	r10	;#0xb794
    b680:	8a 12       	call	r10		;

//		i = -1;					// SW Delay
//		do i--;
//		while(i != 0);

	};
    b682:	30 40 80 b6 	br	#0xb680		;

0000b686 <int48_to_64>:
    use where interrupt code could not see a half completed operation.
    \param y The destination 64 bit value, which is zeroed
    \param x A pointer to the source 48 bit value.
 */
static __inline__ int64_t int48_to_64(int16_t x[3])
{
    b686:	0a 12       	push	r10		;
    b688:	09 12       	push	r9		;
    b68a:	08 12       	push	r8		;
    b68c:	21 83       	decd	r1		;
    b68e:	0a 4c       	mov	r12,	r10	;
    int64_t y;

    y = x[2];
    b690:	18 4c 04 00 	mov	4(r12),	r8	;
    b694:	0c 48       	mov	r8,	r12	;
    b696:	b0 12 ec d1 	call	#53740		;#0xd1ec
    b69a:	0f 4c       	mov	r12,	r15	;
    y <<= 16;
    b69c:	39 40 14 cd 	mov	#52500,	r9	;#0xcd14
    b6a0:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    b6a4:	00 00 
    b6a6:	0c 48       	mov	r8,	r12	;
    b6a8:	0d 4f       	mov	r15,	r13	;
    b6aa:	0e 4f       	mov	r15,	r14	;
    b6ac:	89 12       	call	r9		;
    y |= (uint16_t) x[1];
    b6ae:	1c da 02 00 	bis	2(r10),	r12	;
    y <<= 16;
    b6b2:	89 12       	call	r9		;
    y |= (uint16_t) x[0];
    return  y;
}
    b6b4:	2c da       	bis	@r10,	r12	;
    b6b6:	21 53       	incd	r1		;
    b6b8:	30 40 70 d1 	br	#0xd170		;

0000b6bc <int64_to_48>:
    use where interrupt code could not see a half completed operation.
    \param y A pointer to the destination 48 bit value.
    \param x The source 64 bit value, which is zeroed
 */
static __inline__ void int64_to_48(int16_t y[3], int64_t x)
{
    b6bc:	0a 12       	push	r10		;
    b6be:	09 12       	push	r9		;
    b6c0:	08 12       	push	r8		;
    b6c2:	07 12       	push	r7		;
    b6c4:	06 12       	push	r6		;
    b6c6:	05 12       	push	r5		;
    b6c8:	21 83       	decd	r1		;
    b6ca:	0a 4c       	mov	r12,	r10	;
    b6cc:	19 41 10 00 	mov	16(r1),	r9	;0x00010
    b6d0:	15 41 12 00 	mov	18(r1),	r5	;0x00012
    b6d4:	16 41 14 00 	mov	20(r1),	r6	;0x00014
    b6d8:	17 41 16 00 	mov	22(r1),	r7	;0x00016
    y[2] = x >> 32;
    b6dc:	38 40 90 cd 	mov	#52624,	r8	;#0xcd90
    b6e0:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    b6e4:	00 00 
    b6e6:	0c 49       	mov	r9,	r12	;
    b6e8:	0d 45       	mov	r5,	r13	;
    b6ea:	0e 46       	mov	r6,	r14	;
    b6ec:	0f 47       	mov	r7,	r15	;
    b6ee:	88 12       	call	r8		;
    b6f0:	8a 4c 04 00 	mov	r12,	4(r10)	;
    y[1] = x >> 16;
    b6f4:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    b6f8:	00 00 
    b6fa:	0c 49       	mov	r9,	r12	;
    b6fc:	0d 45       	mov	r5,	r13	;
    b6fe:	0e 46       	mov	r6,	r14	;
    b700:	0f 47       	mov	r7,	r15	;
    b702:	88 12       	call	r8		;
    b704:	8a 4c 02 00 	mov	r12,	2(r10)	;
    y[0] = x;
    b708:	8a 49 00 00 	mov	r9,	0(r10)	;
}
    b70c:	21 53       	incd	r1		;
    b70e:	30 40 6a d1 	br	#0xd16a		;

0000b712 <transfer48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value, which is zeroed
 */
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    b712:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    b716:	04 00 
    y[1] = x[1];
    b718:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    b71c:	02 00 
    y[0] = x[0];
    b71e:	ac 4d 00 00 	mov	@r13,	0(r12)	;
    x[0] =
    x[1] =
    x[2] = 0;
    b722:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    x[1] =
    b726:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
static __inline__ void transfer48(int16_t y[3], int16_t x[3])
{
    y[2] = x[2];
    y[1] = x[1];
    y[0] = x[0];
    x[0] =
    b72a:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    x[1] =
    x[2] = 0;
}
    b72e:	30 41       	ret			

0000b730 <assign48>:
    \param y A pointer to the destination 48 bit value.
    \param x A pointer to the source 48 bit value.
 */
static __inline__ void assign48(int16_t y[3], const int16_t x[3])
{
    y[2] = x[2];
    b730:	9c 4d 04 00 	mov	4(r13),	4(r12)	;
    b734:	04 00 
    y[1] = x[1];
    b736:	9c 4d 02 00 	mov	2(r13),	2(r12)	;
    b73a:	02 00 
    y[0] = x[0];
    b73c:	ac 4d 00 00 	mov	@r13,	0(r12)	;
}
    b740:	30 41       	ret			

0000b742 <clear48>:
    interrupts are already disabled.
    \param z A pointer to the 48 bit accumulator.
 */
static __inline__ void clear48(int16_t z[3])
{
    z[2] = 0;
    b742:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    z[1] = 0;
    b746:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    z[0] = 0;
    b74a:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
}
    b74e:	30 41       	ret			

0000b750 <accum48>:
    /* Accumulate a 32 bit integer value into a 48 bit one represented
       by a 3 element int16_t array */
#if defined(__MSP430__)  &&  defined(__GNUC__)
    int16_t y_ex;

    __asm__ __volatile__ (
    b750:	0f 43       	clr	r15		;
    b752:	0f 4e       	mov	r14,	r15	;
    b754:	0f 5f       	rla	r15		;
    b756:	0f 7f       	subc	r15,	r15	;
    b758:	3f e3       	inv	r15		;
    b75a:	8c 5d 00 00 	add	r13,	0(r12)	;
    b75e:	8c 6e 02 00 	addc	r14,	2(r12)	;
    b762:	8c 6f 04 00 	addc	r15,	4(r12)	;
    acc >>= 16;
    x[1] = acc;
    acc >>= 16;
    x[2] = acc;
#endif
}
    b766:	30 41       	ret			

0000b768 <brief_pause>:
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    b768:	0c 93       	cmp	#0,	r12	;r3 As==00
    b76a:	04 24       	jz	$+10     	;abs 0xb774
    {
        n--;
    b76c:	3c 53       	add	#-1,	r12	;r3 As==11
        __no_operation();
    b76e:	03 43       	nop			
}
#endif

static void __inline__ brief_pause(unsigned int n)
{
    while (n > 0)
    b770:	0c 93       	cmp	#0,	r12	;r3 As==00
    b772:	fc 23       	jnz	$-6      	;abs 0xb76c
    {
        n--;
        __no_operation();
    }
}
    b774:	30 41       	ret			

0000b776 <restart_watchdog>:

static void __inline__ restart_watchdog(void)
{
#if defined(__MSP430__)
    WDTCTL = (WDTCTL & 0xFF) | WDTPW | WDTCNTCL;
    b776:	1c 42 20 01 	mov	&0x0120,r12	;0x0120
    b77a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    b77e:	3c d0 08 5a 	bis	#23048,	r12	;#0x5a08
    b782:	82 4c 20 01 	mov	r12,	&0x0120	;
#endif
}
    b786:	30 41       	ret			

0000b788 <metrology_start>:

void metrology_start(){
	//printf("metrology_start \n");

	//Start sampling
	SD24_startConverterConversion(SD24_BASE, SD24_CONVERTER_1);
    b788:	3c 40 b0 00 	mov	#176,	r12	;#0x00b0
    b78c:	5d 43       	mov.b	#1,	r13	;r3 As==01
    b78e:	b0 12 84 ae 	call	#44676		;#0xae84
}
    b792:	30 41       	ret			

0000b794 <metrology_print_status>:
	int32_t x = metrology.voltage_period.period;
	x = (int32_t) SAMPLES_PER_10_SECONDS*256L*10L/(x >> 16);
	return x;
}

void metrology_print_status(){
    b794:	0a 12       	push	r10		;
    b796:	21 83       	decd	r1		;
	uint16_t p_status;
	volatile frequency_t frequency;
	//volatile int64_t P_active;

	p_status = status;
    b798:	1c 42 10 05 	mov	&0x0510,r12	;0x0510
	int dp;
	status &= ~PHASE_STATUS_NEW_LOG;
    b79c:	0d 4c       	mov	r12,	r13	;
    b79e:	1d c3       	bic	#1,	r13	;r3 As==01
    b7a0:	82 4d 10 05 	mov	r13,	&0x0510	;

	if (p_status & PHASE_STATUS_NEW_LOG)
    b7a4:	1c b3       	bit	#1,	r12	;r3 As==01
    b7a6:	61 24       	jz	$+196    	;abs 0xb86a

        /* The background activity has informed us that it is time to
           perform a block processing operation. */
        //calculate_phase_readings();

		dp = metrology.dp_set;
    b7a8:	3c 40 88 04 	mov	#1160,	r12	;#0x0488
    b7ac:	5a 4c 87 00 	mov.b	135(r12),r10	;0x00087
    b7b0:	8a 11       	sxt	r10		;
	SD24_startConverterConversion(SD24_BASE, SD24_CONVERTER_1);
}

static int16_t evaluate_mains_frequency(void){
	int32_t x = metrology.voltage_period.period;
	x = (int32_t) SAMPLES_PER_10_SECONDS*256L*10L/(x >> 16);
    b7b2:	1d 4c 80 00 	mov	128(r12),r13	;0x00080
    b7b6:	1c 4c 7e 00 	mov	126(r12),r12	;0x0007e
    b7ba:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    b7be:	b0 12 5a d2 	call	#53850		;#0xd25a
    b7c2:	0e 4c       	mov	r12,	r14	;
    b7c4:	0f 4d       	mov	r13,	r15	;
    b7c6:	3c 40 00 80 	mov	#32768,	r12	;#0x8000
    b7ca:	3d 40 1a 06 	mov	#1562,	r13	;#0x061a
    b7ce:	b0 12 a2 cf 	call	#53154		;#0xcfa2
           perform a block processing operation. */
        //calculate_phase_readings();

		dp = metrology.dp_set;

        frequency = evaluate_mains_frequency();
    b7d2:	81 4c 00 00 	mov	r12,	0(r1)	;
      //  P_active = *metrology.current.dot_prod[dp].P_active / metrology.current.dot_prod[dp].sample_count;
        //P_active >>= 9;
        //P_active = mul48_32_16(P_active, 12826);

        if(frequency > 4800 && frequency < 5200){
    b7d6:	2c 41       	mov	@r1,	r12	;
    b7d8:	3d 40 c0 12 	mov	#4800,	r13	;#0x12c0
    b7dc:	0d 9c       	cmp	r12,	r13	;
    b7de:	0b 2c       	jc	$+24     	;abs 0xb7f6
    b7e0:	2c 41       	mov	@r1,	r12	;
    b7e2:	3d 40 4f 14 	mov	#5199,	r13	;#0x144f
    b7e6:	0d 9c       	cmp	r12,	r13	;
    b7e8:	06 28       	jnc	$+14     	;abs 0xb7f6
//        	printf("Freq = %u", frequency);
        	GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN1);	//Green
    b7ea:	6c 43       	mov.b	#2,	r12	;r3 As==10
    b7ec:	2d 43       	mov	#2,	r13	;r3 As==10
    b7ee:	b0 12 c8 ab 	call	#43976		;#0xabc8
    b7f2:	30 40 fe b7 	br	#0xb7fe		;
        }
        else{
        	GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN1);	//Green
    b7f6:	6c 43       	mov.b	#2,	r12	;r3 As==10
    b7f8:	2d 43       	mov	#2,	r13	;r3 As==10
    b7fa:	b0 12 ee ab 	call	#44014		;#0xabee
        }
        //printf("%i", frequency);


        memset(&metrology.dot_prod[dp], 0, sizeof(metrology.dot_prod[0]));
    b7fe:	0d 4a       	mov	r10,	r13	;
    b800:	0d 5a       	add	r10,	r13	;
    b802:	0d 5d       	rla	r13		;
    b804:	0d 5a       	add	r10,	r13	;
    b806:	0d 5d       	rla	r13		;
    b808:	3d 50 18 00 	add	#24,	r13	;#0x0018
    b80c:	3d 50 88 04 	add	#1160,	r13	;#0x0488
    b810:	8d 43 00 00 	mov	#0,	0(r13)	;r3 As==00
    b814:	8d 43 02 00 	mov	#0,	2(r13)	;r3 As==00
    b818:	8d 43 04 00 	mov	#0,	4(r13)	;r3 As==00
    b81c:	8d 43 06 00 	mov	#0,	6(r13)	;r3 As==00
    b820:	8d 43 08 00 	mov	#0,	8(r13)	;r3 As==00
        memset(&metrology.current.dot_prod[dp], 0, sizeof(metrology.current.dot_prod[0]));
    b824:	0c 4a       	mov	r10,	r12	;
    b826:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    b82a:	b0 12 14 d3 	call	#54036		;#0xd314
    b82e:	3c 50 3a 00 	add	#58,	r12	;#0x003a
    b832:	3c 50 88 04 	add	#1160,	r12	;#0x0488
    b836:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    b83a:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00
    b83e:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00
    b842:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00
    b846:	8c 43 08 00 	mov	#0,	8(r12)	;r3 As==00
    b84a:	8c 43 0a 00 	mov	#0,	10(r12)	;r3 As==00, 0x000a
    b84e:	8c 43 0c 00 	mov	#0,	12(r12)	;r3 As==00, 0x000c
    b852:	8c 43 0e 00 	mov	#0,	14(r12)	;r3 As==00, 0x000e
    b856:	8c 43 10 00 	mov	#0,	16(r12)	;r3 As==00, 0x0010
    b85a:	8c 43 12 00 	mov	#0,	18(r12)	;r3 As==00, 0x0012
    b85e:	8c 43 14 00 	mov	#0,	20(r12)	;r3 As==00, 0x0014
    b862:	8c 43 16 00 	mov	#0,	22(r12)	;r3 As==00, 0x0016
    b866:	8c 43 18 00 	mov	#0,	24(r12)	;r3 As==00, 0x0018
    }
}
    b86a:	21 53       	incd	r1		;
    b86c:	3a 41       	pop	r10		;
    b86e:	30 41       	ret			

0000b870 <log_parameters>:

static void __inline__ log_parameters(void){

	/* Tell the foreground there are things to process, and swap the dot product sets. */
	metrology.dp_set ^= 1;
    b870:	3c 40 88 04 	mov	#1160,	r12	;#0x0488
    b874:	dc e3 87 00 	xor.b	#1,	135(r12);r3 As==01, 0x0087
	status |= PHASE_STATUS_NEW_LOG;
    b878:	92 d3 10 05 	bis	#1,	&0x0510	;r3 As==01
}
    b87c:	30 41       	ret			

0000b87e <abs32>:

static __inline__ int32_t abs32(int32_t x)
{
    b87e:	0a 12       	push	r10		;
    return (x < 0)  ?  -x  :  x;
    b880:	0d 93       	cmp	#0,	r13	;r3 As==00
    b882:	08 34       	jge	$+18     	;abs 0xb894
    b884:	0e 43       	clr	r14		;
    b886:	0f 43       	clr	r15		;
    b888:	0a 4e       	mov	r14,	r10	;
    b88a:	0b 4f       	mov	r15,	r11	;
    b88c:	0a 8c       	sub	r12,	r10	;
    b88e:	0b 7d       	subc	r13,	r11	;
    b890:	0c 4a       	mov	r10,	r12	;
    b892:	0d 4b       	mov	r11,	r13	;
}
    b894:	3a 41       	pop	r10		;
    b896:	30 41       	ret			

0000b898 <sqac48_16_mpy>:

//x and accumulate in z
static __inline__ void sqac48_16_mpy(register uint64_t* z, register int16_t x)// __attribute__((always_inline))
{
    b898:	0a 12       	push	r10		;
    b89a:	09 12       	push	r9		;
    b89c:	08 12       	push	r8		;
    b89e:	0a 4c       	mov	r12,	r10	;
    b8a0:	09 4d       	mov	r13,	r9	;
    b8a2:	0d 93       	cmp	#0,	r13	;r3 As==00
    b8a4:	03 34       	jge	$+8      	;abs 0xb8ac
    b8a6:	0c 43       	clr	r12		;
    b8a8:	0c 8d       	sub	r13,	r12	;
    b8aa:	09 4c       	mov	r12,	r9	;
	if(x < 0) x = -x;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, x);
    b8ac:	4c 43       	clr.b	r12		;
    b8ae:	0d 49       	mov	r9,	r13	;
    b8b0:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(x);
    b8b4:	0c 49       	mov	r9,	r12	;
    b8b6:	b0 12 50 ad 	call	#44368		;#0xad50

	*z += MPY_getResult();
    b8ba:	b0 12 56 ad 	call	#44374		;#0xad56
    b8be:	2b 4a       	mov	@r10,	r11	;
    b8c0:	18 4a 02 00 	mov	2(r10),	r8	;
    b8c4:	1e 4a 04 00 	mov	4(r10),	r14	;
    b8c8:	19 4a 06 00 	mov	6(r10),	r9	;
    b8cc:	0c 5b       	add	r11,	r12	;
    b8ce:	1f 43       	mov	#1,	r15	;r3 As==01
    b8d0:	0c 9b       	cmp	r11,	r12	;
    b8d2:	01 28       	jnc	$+4      	;abs 0xb8d6
    b8d4:	0f 43       	clr	r15		;
    b8d6:	0d 58       	add	r8,	r13	;
    b8d8:	1b 43       	mov	#1,	r11	;r3 As==01
    b8da:	0d 98       	cmp	r8,	r13	;
    b8dc:	01 28       	jnc	$+4      	;abs 0xb8e0
    b8de:	0b 43       	clr	r11		;
    b8e0:	0f 5d       	add	r13,	r15	;
    b8e2:	18 43       	mov	#1,	r8	;r3 As==01
    b8e4:	0f 9d       	cmp	r13,	r15	;
    b8e6:	01 28       	jnc	$+4      	;abs 0xb8ea
    b8e8:	08 43       	clr	r8		;
    b8ea:	0b d8       	bis	r8,	r11	;
    b8ec:	08 4e       	mov	r14,	r8	;
    b8ee:	1d 43       	mov	#1,	r13	;r3 As==01
    b8f0:	0e 9e       	cmp	r14,	r14	;
    b8f2:	01 28       	jnc	$+4      	;abs 0xb8f6
    b8f4:	0d 43       	clr	r13		;
    b8f6:	0e 5b       	add	r11,	r14	;
    b8f8:	1b 43       	mov	#1,	r11	;r3 As==01
    b8fa:	0e 98       	cmp	r8,	r14	;
    b8fc:	01 28       	jnc	$+4      	;abs 0xb900
    b8fe:	0b 43       	clr	r11		;
    b900:	0d db       	bis	r11,	r13	;
    b902:	8a 4c 00 00 	mov	r12,	0(r10)	;
    b906:	8a 4f 02 00 	mov	r15,	2(r10)	;
    b90a:	8a 4e 04 00 	mov	r14,	4(r10)	;
    b90e:	0d 59       	add	r9,	r13	;
    b910:	8a 4d 06 00 	mov	r13,	6(r10)	;
}
    b914:	30 40 70 d1 	br	#0xd170		;

0000b918 <sqac64_24_mpy>:

//x and accumulate in z
static __inline__ void sqac64_24_mpy(register uint64_t* z, register int32_t x)// __attribute__((always_inline))
{
    b918:	0a 12       	push	r10		;
    b91a:	09 12       	push	r9		;
    b91c:	08 12       	push	r8		;
    b91e:	07 12       	push	r7		;
    b920:	06 12       	push	r6		;
    b922:	05 12       	push	r5		;
    b924:	21 83       	decd	r1		;
    b926:	0a 4c       	mov	r12,	r10	;
    b928:	08 4d       	mov	r13,	r8	;
    b92a:	09 4e       	mov	r14,	r9	;
    b92c:	0e 93       	cmp	#0,	r14	;r3 As==00
    b92e:	08 34       	jge	$+18     	;abs 0xb940
    b930:	0c 43       	clr	r12		;
    b932:	0d 43       	clr	r13		;
    b934:	0e 4c       	mov	r12,	r14	;
    b936:	0f 4d       	mov	r13,	r15	;
    b938:	0e 88       	sub	r8,	r14	;
    b93a:	0f 79       	subc	r9,	r15	;
    b93c:	08 4e       	mov	r14,	r8	;
    b93e:	09 4f       	mov	r15,	r9	;
    b940:	0d 49       	mov	r9,	r13	;

	if(x < 0) x = -x;

	/* Simplified multiplication */
	oplo = x;
	ophi = x >> 16;
    b942:	0c 48       	mov	r8,	r12	;
    b944:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    b948:	b0 12 5a d2 	call	#53850		;#0xd25a
    b94c:	09 4c       	mov	r12,	r9	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    b94e:	4c 43       	clr.b	r12		;
    b950:	0d 48       	mov	r8,	r13	;
    b952:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(oplo);
    b956:	0c 48       	mov	r8,	r12	;
    b958:	b0 12 50 ad 	call	#44368		;#0xad50
	*z += MPY_getResult();
    b95c:	b0 12 56 ad 	call	#44374		;#0xad56
    b960:	0e 4d       	mov	r13,	r14	;
    b962:	28 4a       	mov	@r10,	r8	;
    b964:	16 4a 02 00 	mov	2(r10),	r6	;
    b968:	1d 4a 04 00 	mov	4(r10),	r13	;
    b96c:	17 4a 06 00 	mov	6(r10),	r7	;
    b970:	0c 58       	add	r8,	r12	;
    b972:	1f 43       	mov	#1,	r15	;r3 As==01
    b974:	0c 98       	cmp	r8,	r12	;
    b976:	01 28       	jnc	$+4      	;abs 0xb97a
    b978:	0f 43       	clr	r15		;
    b97a:	0e 56       	add	r6,	r14	;
    b97c:	18 43       	mov	#1,	r8	;r3 As==01
    b97e:	0e 96       	cmp	r6,	r14	;
    b980:	01 28       	jnc	$+4      	;abs 0xb984
    b982:	08 43       	clr	r8		;
    b984:	0f 5e       	add	r14,	r15	;
    b986:	16 43       	mov	#1,	r6	;r3 As==01
    b988:	0f 9e       	cmp	r14,	r15	;
    b98a:	01 28       	jnc	$+4      	;abs 0xb98e
    b98c:	06 43       	clr	r6		;
    b98e:	08 d6       	bis	r6,	r8	;
    b990:	06 4d       	mov	r13,	r6	;
    b992:	1e 43       	mov	#1,	r14	;r3 As==01
    b994:	0d 9d       	cmp	r13,	r13	;
    b996:	01 28       	jnc	$+4      	;abs 0xb99a
    b998:	0e 43       	clr	r14		;
    b99a:	0d 58       	add	r8,	r13	;
    b99c:	18 43       	mov	#1,	r8	;r3 As==01
    b99e:	0d 96       	cmp	r6,	r13	;
    b9a0:	01 28       	jnc	$+4      	;abs 0xb9a4
    b9a2:	08 43       	clr	r8		;
    b9a4:	0e d8       	bis	r8,	r14	;
    b9a6:	8a 4c 00 00 	mov	r12,	0(r10)	;
    b9aa:	8a 4f 02 00 	mov	r15,	2(r10)	;
    b9ae:	8a 4d 04 00 	mov	r13,	4(r10)	;
    b9b2:	0e 57       	add	r7,	r14	;
    b9b4:	8a 4e 06 00 	mov	r14,	6(r10)	;

	MPY_setOperandTwo16Bit(ophi);
    b9b8:	0c 49       	mov	r9,	r12	;
    b9ba:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    b9be:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 16;
    b9c2:	0f 43       	clr	r15		;
    b9c4:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    b9c8:	00 00 
    b9ca:	0e 4f       	mov	r15,	r14	;
    b9cc:	b0 12 14 cd 	call	#52500		;#0xcd14
    b9d0:	05 4d       	mov	r13,	r5	;
    b9d2:	0b 4e       	mov	r14,	r11	;
    b9d4:	08 4c       	mov	r12,	r8	;
    b9d6:	08 5c       	add	r12,	r8	;
    b9d8:	17 43       	mov	#1,	r7	;r3 As==01
    b9da:	08 9c       	cmp	r12,	r8	;
    b9dc:	01 28       	jnc	$+4      	;abs 0xb9e0
    b9de:	07 43       	clr	r7		;
    b9e0:	0d 5d       	rla	r13		;
    b9e2:	16 43       	mov	#1,	r6	;r3 As==01
    b9e4:	0d 95       	cmp	r5,	r13	;
    b9e6:	01 28       	jnc	$+4      	;abs 0xb9ea
    b9e8:	06 43       	clr	r6		;
    b9ea:	0c 47       	mov	r7,	r12	;
    b9ec:	0c 5d       	add	r13,	r12	;
    b9ee:	17 43       	mov	#1,	r7	;r3 As==01
    b9f0:	0c 9d       	cmp	r13,	r12	;
    b9f2:	01 28       	jnc	$+4      	;abs 0xb9f6
    b9f4:	07 43       	clr	r7		;
    b9f6:	06 d7       	bis	r7,	r6	;
    b9f8:	0e 5e       	rla	r14		;
    b9fa:	17 43       	mov	#1,	r7	;r3 As==01
    b9fc:	0e 9b       	cmp	r11,	r14	;
    b9fe:	01 28       	jnc	$+4      	;abs 0xba02
    ba00:	07 43       	clr	r7		;
    ba02:	0d 46       	mov	r6,	r13	;
    ba04:	0d 5e       	add	r14,	r13	;
    ba06:	16 43       	mov	#1,	r6	;r3 As==01
    ba08:	0d 9e       	cmp	r14,	r13	;
    ba0a:	01 28       	jnc	$+4      	;abs 0xba0e
    ba0c:	06 43       	clr	r6		;
    ba0e:	07 d6       	bis	r6,	r7	;
    ba10:	0f 5f       	rla	r15		;
    ba12:	0f 57       	add	r7,	r15	;
	*z += (uint64_t) sum << 16;
    ba14:	2b 4a       	mov	@r10,	r11	;
    ba16:	15 4a 02 00 	mov	2(r10),	r5	;
    ba1a:	16 4a 04 00 	mov	4(r10),	r6	;
    ba1e:	17 4a 06 00 	mov	6(r10),	r7	;
    ba22:	0e 4b       	mov	r11,	r14	;
    ba24:	0e 58       	add	r8,	r14	;
    ba26:	18 43       	mov	#1,	r8	;r3 As==01
    ba28:	0e 9b       	cmp	r11,	r14	;
    ba2a:	01 28       	jnc	$+4      	;abs 0xba2e
    ba2c:	08 43       	clr	r8		;
    ba2e:	0b 45       	mov	r5,	r11	;
    ba30:	0b 5c       	add	r12,	r11	;
    ba32:	1c 43       	mov	#1,	r12	;r3 As==01
    ba34:	0b 95       	cmp	r5,	r11	;
    ba36:	01 28       	jnc	$+4      	;abs 0xba3a
    ba38:	0c 43       	clr	r12		;
    ba3a:	08 5b       	add	r11,	r8	;
    ba3c:	15 43       	mov	#1,	r5	;r3 As==01
    ba3e:	08 9b       	cmp	r11,	r8	;
    ba40:	01 28       	jnc	$+4      	;abs 0xba44
    ba42:	05 43       	clr	r5		;
    ba44:	0c d5       	bis	r5,	r12	;
    ba46:	0d 56       	add	r6,	r13	;
    ba48:	1b 43       	mov	#1,	r11	;r3 As==01
    ba4a:	0d 96       	cmp	r6,	r13	;
    ba4c:	01 28       	jnc	$+4      	;abs 0xba50
    ba4e:	0b 43       	clr	r11		;
    ba50:	0c 5d       	add	r13,	r12	;
    ba52:	16 43       	mov	#1,	r6	;r3 As==01
    ba54:	0c 9d       	cmp	r13,	r12	;
    ba56:	01 28       	jnc	$+4      	;abs 0xba5a
    ba58:	06 43       	clr	r6		;
    ba5a:	0b d6       	bis	r6,	r11	;
    ba5c:	0f 57       	add	r7,	r15	;
    ba5e:	8a 4e 00 00 	mov	r14,	0(r10)	;
    ba62:	8a 48 02 00 	mov	r8,	2(r10)	;
    ba66:	8a 4c 04 00 	mov	r12,	4(r10)	;
    ba6a:	0b 5f       	add	r15,	r11	;
    ba6c:	8a 4b 06 00 	mov	r11,	6(r10)	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, ophi);
    ba70:	4c 43       	clr.b	r12		;
    ba72:	0d 49       	mov	r9,	r13	;
    ba74:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(ophi);
    ba78:	0c 49       	mov	r9,	r12	;
    ba7a:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    ba7e:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 32;
    ba82:	0f 43       	clr	r15		;
    ba84:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    ba88:	00 00 
    ba8a:	0e 4f       	mov	r15,	r14	;
    ba8c:	b0 12 14 cd 	call	#52500		;#0xcd14
    ba90:	29 4a       	mov	@r10,	r9	;
    ba92:	1b 4a 02 00 	mov	2(r10),	r11	;
    ba96:	16 4a 04 00 	mov	4(r10),	r6	;
    ba9a:	17 4a 06 00 	mov	6(r10),	r7	;
    ba9e:	0c 59       	add	r9,	r12	;
    baa0:	18 43       	mov	#1,	r8	;r3 As==01
    baa2:	0c 99       	cmp	r9,	r12	;
    baa4:	01 28       	jnc	$+4      	;abs 0xbaa8
    baa6:	08 43       	clr	r8		;
    baa8:	0d 5b       	add	r11,	r13	;
    baaa:	19 43       	mov	#1,	r9	;r3 As==01
    baac:	0d 9b       	cmp	r11,	r13	;
    baae:	01 28       	jnc	$+4      	;abs 0xbab2
    bab0:	09 43       	clr	r9		;
    bab2:	08 5d       	add	r13,	r8	;
    bab4:	15 43       	mov	#1,	r5	;r3 As==01
    bab6:	08 9d       	cmp	r13,	r8	;
    bab8:	01 28       	jnc	$+4      	;abs 0xbabc
    baba:	05 43       	clr	r5		;
    babc:	09 d5       	bis	r5,	r9	;
    babe:	0e 56       	add	r6,	r14	;
    bac0:	1d 43       	mov	#1,	r13	;r3 As==01
    bac2:	0e 96       	cmp	r6,	r14	;
    bac4:	01 28       	jnc	$+4      	;abs 0xbac8
    bac6:	0d 43       	clr	r13		;
    bac8:	09 5e       	add	r14,	r9	;
    baca:	16 43       	mov	#1,	r6	;r3 As==01
    bacc:	09 9e       	cmp	r14,	r9	;
    bace:	01 28       	jnc	$+4      	;abs 0xbad2
    bad0:	06 43       	clr	r6		;
    bad2:	0d d6       	bis	r6,	r13	;
    bad4:	0f 57       	add	r7,	r15	;
    bad6:	8a 4c 00 00 	mov	r12,	0(r10)	;
    bada:	8a 48 02 00 	mov	r8,	2(r10)	;
    bade:	8a 49 04 00 	mov	r9,	4(r10)	;
    bae2:	0d 5f       	add	r15,	r13	;
    bae4:	8a 4d 06 00 	mov	r13,	6(r10)	;
}
    bae8:	21 53       	incd	r1		;
    baea:	30 40 6a d1 	br	#0xd16a		;

0000baee <mac64_16_24_mpy>:

static __inline__ void mac64_16_24_mpy(register int64_t *z, register int16_t x, register int32_t y){
    baee:	0a 12       	push	r10		;
    baf0:	09 12       	push	r9		;
    baf2:	08 12       	push	r8		;
    baf4:	07 12       	push	r7		;
    baf6:	06 12       	push	r6		;
    baf8:	05 12       	push	r5		;
    bafa:	04 12       	push	r4		;
    bafc:	31 80 0c 00 	sub	#12,	r1	;#0x000c
    bb00:	07 4c       	mov	r12,	r7	;
    bb02:	0a 4d       	mov	r13,	r10	;
    bb04:	81 4f 04 00 	mov	r15,	4(r1)	;
    bb08:	0c 4e       	mov	r14,	r12	;
    bb0a:	0d 4f       	mov	r15,	r13	;
    bb0c:	0f 93       	cmp	#0,	r15	;r3 As==00
    bb0e:	08 34       	jge	$+18     	;abs 0xbb20
    bb10:	0e 43       	clr	r14		;
    bb12:	0f 43       	clr	r15		;
    bb14:	08 4e       	mov	r14,	r8	;
    bb16:	09 4f       	mov	r15,	r9	;
    bb18:	08 8c       	sub	r12,	r8	;
    bb1a:	09 7d       	subc	r13,	r9	;
    bb1c:	0c 48       	mov	r8,	r12	;
    bb1e:	0d 49       	mov	r9,	r13	;
    bb20:	04 4c       	mov	r12,	r4	;
    bb22:	09 4d       	mov	r13,	r9	;
    bb24:	0d 4a       	mov	r10,	r13	;
    bb26:	0a 93       	cmp	#0,	r10	;r3 As==00
    bb28:	03 34       	jge	$+8      	;abs 0xbb30
    bb2a:	0c 43       	clr	r12		;
    bb2c:	0c 8a       	sub	r10,	r12	;
    bb2e:	0d 4c       	mov	r12,	r13	;
	if(y < 0) y = -y;

	oplo = x;
	ophi = y >> 16;
	//MSB
	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    bb30:	4c 43       	clr.b	r12		;
    bb32:	b0 12 40 ad 	call	#44352		;#0xad40

	if(x < 0) x = -x;
	if(y < 0) y = -y;

	oplo = x;
	ophi = y >> 16;
    bb36:	0c 44       	mov	r4,	r12	;
    bb38:	0d 49       	mov	r9,	r13	;
    bb3a:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    bb3e:	b0 12 5a d2 	call	#53850		;#0xd25a
	//MSB
	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
	MPY_setOperandTwo16Bit(ophi);
    bb42:	35 40 50 ad 	mov	#44368,	r5	;#0xad50
    bb46:	85 12       	call	r5		;
	result = (uint64_t)MPY_getResult() << 16;
    bb48:	36 40 56 ad 	mov	#44374,	r6	;#0xad56
    bb4c:	86 12       	call	r6		;
    bb4e:	09 43       	clr	r9		;
    bb50:	38 40 14 cd 	mov	#52500,	r8	;#0xcd14
    bb54:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    bb58:	00 00 
    bb5a:	0e 49       	mov	r9,	r14	;
    bb5c:	0f 49       	mov	r9,	r15	;
    bb5e:	88 12       	call	r8		;
	result <<= 16;
    bb60:	88 12       	call	r8		;
    bb62:	81 4c 02 00 	mov	r12,	2(r1)	;
    bb66:	08 4d       	mov	r13,	r8	;
    bb68:	81 4e 06 00 	mov	r14,	6(r1)	;
    bb6c:	81 4f 08 00 	mov	r15,	8(r1)	;

	//LSB
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
    bb70:	0c 44       	mov	r4,	r12	;
    bb72:	85 12       	call	r5		;
	result += MPY_getResult();
    bb74:	86 12       	call	r6		;
    bb76:	0e 49       	mov	r9,	r14	;
    bb78:	1f 41 02 00 	mov	2(r1),	r15	;
    bb7c:	0f 5c       	add	r12,	r15	;
    bb7e:	81 4f 02 00 	mov	r15,	2(r1)	;
    bb82:	16 43       	mov	#1,	r6	;r3 As==01
    bb84:	0f 9c       	cmp	r12,	r15	;
    bb86:	01 28       	jnc	$+4      	;abs 0xbb8a
    bb88:	06 49       	mov	r9,	r6	;
    bb8a:	08 5d       	add	r13,	r8	;
    bb8c:	19 43       	mov	#1,	r9	;r3 As==01
    bb8e:	08 9d       	cmp	r13,	r8	;
    bb90:	01 28       	jnc	$+4      	;abs 0xbb94
    bb92:	09 43       	clr	r9		;
    bb94:	06 58       	add	r8,	r6	;
    bb96:	1c 43       	mov	#1,	r12	;r3 As==01
    bb98:	06 98       	cmp	r8,	r6	;
    bb9a:	01 28       	jnc	$+4      	;abs 0xbb9e
    bb9c:	0c 43       	clr	r12		;
    bb9e:	09 dc       	bis	r12,	r9	;
    bba0:	1d 41 06 00 	mov	6(r1),	r13	;
    bba4:	1c 43       	mov	#1,	r12	;r3 As==01
    bba6:	0d 9e       	cmp	r14,	r13	;
    bba8:	01 28       	jnc	$+4      	;abs 0xbbac
    bbaa:	0c 43       	clr	r12		;
    bbac:	09 5d       	add	r13,	r9	;
    bbae:	1e 43       	mov	#1,	r14	;r3 As==01
    bbb0:	09 9d       	cmp	r13,	r9	;
    bbb2:	01 28       	jnc	$+4      	;abs 0xbbb6
    bbb4:	0e 43       	clr	r14		;
    bbb6:	0c de       	bis	r14,	r12	;
    bbb8:	1c 51 08 00 	add	8(r1),	r12	;
    bbbc:	81 4c 08 00 	mov	r12,	8(r1)	;
    bbc0:	81 46 0a 00 	mov	r6,	10(r1)	; 0x000a

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    bbc4:	25 47       	mov	@r7,	r5	;
    bbc6:	14 47 02 00 	mov	2(r7),	r4	;
    bbca:	18 47 04 00 	mov	4(r7),	r8	;
    bbce:	91 47 06 00 	mov	6(r7),	6(r1)	;
    bbd2:	06 00 
	sum = MPY_getResult();
	*z += (uint64_t) sum << 32;
}

static __inline__ void mac64_16_24_mpy(register int64_t *z, register int16_t x, register int32_t y){
	int sign = (x ^ y) < 0;	// 0 = positive, 1 = negative
    bbd4:	3a b0 00 80 	bit	#32768,	r10	;#0x8000
    bbd8:	0b 7b       	subc	r11,	r11	;
    bbda:	3b e3       	inv	r11		;
    bbdc:	1c 41 04 00 	mov	4(r1),	r12	;
    bbe0:	0c eb       	xor	r11,	r12	;
    bbe2:	b0 12 60 d2 	call	#53856		;#0xd260
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
	result += MPY_getResult();

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    bbe6:	0d 43       	clr	r13		;
    bbe8:	0d 9c       	cmp	r12,	r13	;
    bbea:	29 34       	jge	$+84     	;abs 0xbc3e
    bbec:	0c 4d       	mov	r13,	r12	;
    bbee:	0b 4d       	mov	r13,	r11	;
    bbf0:	0d 4c       	mov	r12,	r13	;
    bbf2:	1d 81 02 00 	sub	2(r1),	r13	;
    bbf6:	1f 43       	mov	#1,	r15	;r3 As==01
    bbf8:	0d 9c       	cmp	r12,	r13	;
    bbfa:	01 20       	jnz	$+4      	;abs 0xbbfe
    bbfc:	0f 4c       	mov	r12,	r15	;
    bbfe:	0e 4c       	mov	r12,	r14	;
    bc00:	1e 81 0a 00 	sub	10(r1),	r14	;0x0000a
    bc04:	1a 43       	mov	#1,	r10	;r3 As==01
    bc06:	0c 9e       	cmp	r14,	r12	;
    bc08:	01 28       	jnc	$+4      	;abs 0xbc0c
    bc0a:	0a 43       	clr	r10		;
    bc0c:	06 4e       	mov	r14,	r6	;
    bc0e:	06 8f       	sub	r15,	r6	;
    bc10:	1f 43       	mov	#1,	r15	;r3 As==01
    bc12:	0e 96       	cmp	r6,	r14	;
    bc14:	01 28       	jnc	$+4      	;abs 0xbc18
    bc16:	0f 43       	clr	r15		;
    bc18:	0a df       	bis	r15,	r10	;
    bc1a:	0e 4c       	mov	r12,	r14	;
    bc1c:	0e 89       	sub	r9,	r14	;
    bc1e:	1f 43       	mov	#1,	r15	;r3 As==01
    bc20:	0b 9e       	cmp	r14,	r11	;
    bc22:	01 28       	jnc	$+4      	;abs 0xbc26
    bc24:	0f 43       	clr	r15		;
    bc26:	09 4e       	mov	r14,	r9	;
    bc28:	09 8a       	sub	r10,	r9	;
    bc2a:	1a 43       	mov	#1,	r10	;r3 As==01
    bc2c:	0e 99       	cmp	r9,	r14	;
    bc2e:	01 28       	jnc	$+4      	;abs 0xbc32
    bc30:	0a 43       	clr	r10		;
    bc32:	0f da       	bis	r10,	r15	;
    bc34:	1c 81 08 00 	sub	8(r1),	r12	;
    bc38:	0c 8f       	sub	r15,	r12	;
    bc3a:	30 40 46 bc 	br	#0xbc46		;
    bc3e:	1d 41 02 00 	mov	2(r1),	r13	;
    bc42:	1c 41 08 00 	mov	8(r1),	r12	;
    bc46:	0d 55       	add	r5,	r13	;
    bc48:	1f 43       	mov	#1,	r15	;r3 As==01
    bc4a:	0d 95       	cmp	r5,	r13	;
    bc4c:	01 28       	jnc	$+4      	;abs 0xbc50
    bc4e:	0f 43       	clr	r15		;
    bc50:	06 54       	add	r4,	r6	;
    bc52:	1e 43       	mov	#1,	r14	;r3 As==01
    bc54:	06 94       	cmp	r4,	r6	;
    bc56:	01 28       	jnc	$+4      	;abs 0xbc5a
    bc58:	0e 43       	clr	r14		;
    bc5a:	0f 56       	add	r6,	r15	;
    bc5c:	1a 43       	mov	#1,	r10	;r3 As==01
    bc5e:	0f 96       	cmp	r6,	r15	;
    bc60:	01 28       	jnc	$+4      	;abs 0xbc64
    bc62:	0a 43       	clr	r10		;
    bc64:	0e da       	bis	r10,	r14	;
    bc66:	09 58       	add	r8,	r9	;
    bc68:	1a 43       	mov	#1,	r10	;r3 As==01
    bc6a:	09 98       	cmp	r8,	r9	;
    bc6c:	01 28       	jnc	$+4      	;abs 0xbc70
    bc6e:	0a 43       	clr	r10		;
    bc70:	0e 59       	add	r9,	r14	;
    bc72:	18 43       	mov	#1,	r8	;r3 As==01
    bc74:	0e 99       	cmp	r9,	r14	;
    bc76:	01 28       	jnc	$+4      	;abs 0xbc7a
    bc78:	08 43       	clr	r8		;
    bc7a:	0a d8       	bis	r8,	r10	;
    bc7c:	1c 51 06 00 	add	6(r1),	r12	;
    bc80:	87 4d 00 00 	mov	r13,	0(r7)	;
    bc84:	87 4f 02 00 	mov	r15,	2(r7)	;
    bc88:	87 4e 04 00 	mov	r14,	4(r7)	;
    bc8c:	0a 5c       	add	r12,	r10	;
    bc8e:	87 4a 06 00 	mov	r10,	6(r7)	;
//        "addc.w  #0,6(z) \n"
//
//        "popmm   1,11 \n"
//    	"xret \n"
//    );
}
    bc92:	31 50 0c 00 	add	#12,	r1	;#0x000c
    bc96:	30 40 68 d1 	br	#0xd168		;

0000bc9a <per_sample_dsp>:
int16_t V_History_Count = 0;
int16_t V_History_SampleCount = 0;
int16_t V_History_break = 9999;

static __inline__ int per_sample_dsp(void)
{
    bc9a:	0a 12       	push	r10		;
    bc9c:	09 12       	push	r9		;
    bc9e:	08 12       	push	r8		;
    bca0:	07 12       	push	r7		;
    bca2:	06 12       	push	r6		;
    bca4:	05 12       	push	r5		;
    bca6:	04 12       	push	r4		;
    bca8:	31 80 0e 00 	sub	#14,	r1	;#0x000e
	int kick = 0;
	voltage_sample_t V_sample = adc_v_buffer;
    bcac:	91 42 26 04 	mov	&0x0426,2(r1)	;0x0426
    bcb0:	02 00 
	voltage_sample_t V_corrected;
	current_sample_t I_sample;
	current_sample_t I_corrected = adc_i_buffer;
    bcb2:	17 42 22 04 	mov	&0x0422,r7	;0x0422
    bcb6:	91 42 24 04 	mov	&0x0424,8(r1)	;0x0424
    bcba:	08 00 
	struct phase_dot_prod_set_s* phase_dot_products;
	struct current_sensor_dot_prod_set_s *sensor_dot_products;
	int8_t loggers = 0;

	//Use the set of data that the frontend is NOT using
	dp = metrology.dp_set ^ 1;
    bcbc:	5c 42 0f 05 	mov.b	&0x050f,r12	;0x050f
    bcc0:	5c e3       	xor.b	#1,	r12	;r3 As==01
    bcc2:	44 4c       	mov.b	r12,	r4	;
    bcc4:	84 11       	sxt	r4		;
	phase_dot_products = &metrology.dot_prod[dp];
	sensor_dot_products = &metrology.current.dot_prod[dp];

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
    bcc6:	0a 44       	mov	r4,	r10	;
    bcc8:	0a 54       	add	r4,	r10	;
    bcca:	0a 5a       	rla	r10		;
    bccc:	0a 54       	add	r4,	r10	;
    bcce:	0a 5a       	rla	r10		;
    bcd0:	3a 50 18 00 	add	#24,	r10	;#0x0018
    bcd4:	3a 50 88 04 	add	#1160,	r10	;#0x0488
    bcd8:	19 41 02 00 	mov	2(r1),	r9	;
    bcdc:	09 93       	cmp	#0,	r9	;r3 As==00
    bcde:	03 34       	jge	$+8      	;abs 0xbce6
    bce0:	0c 43       	clr	r12		;
    bce2:	0c 89       	sub	r9,	r12	;
    bce4:	09 4c       	mov	r12,	r9	;
//x and accumulate in z
static __inline__ void sqac48_16_mpy(register uint64_t* z, register int16_t x)// __attribute__((always_inline))
{
	if(x < 0) x = -x;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, x);
    bce6:	81 49 04 00 	mov	r9,	4(r1)	;
    bcea:	4c 43       	clr.b	r12		;
    bcec:	0d 49       	mov	r9,	r13	;
    bcee:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(x);
    bcf2:	0c 49       	mov	r9,	r12	;
    bcf4:	b0 12 50 ad 	call	#44368		;#0xad50

	*z += MPY_getResult();
    bcf8:	b0 12 56 ad 	call	#44374		;#0xad56
    bcfc:	29 4a       	mov	@r10,	r9	;
    bcfe:	16 4a 02 00 	mov	2(r10),	r6	;
    bd02:	1e 4a 04 00 	mov	4(r10),	r14	;
    bd06:	18 4a 06 00 	mov	6(r10),	r8	;
    bd0a:	0c 59       	add	r9,	r12	;
    bd0c:	1f 43       	mov	#1,	r15	;r3 As==01
    bd0e:	0c 99       	cmp	r9,	r12	;
    bd10:	01 28       	jnc	$+4      	;abs 0xbd14
    bd12:	0f 43       	clr	r15		;
    bd14:	0d 56       	add	r6,	r13	;
    bd16:	19 43       	mov	#1,	r9	;r3 As==01
    bd18:	0d 96       	cmp	r6,	r13	;
    bd1a:	01 28       	jnc	$+4      	;abs 0xbd1e
    bd1c:	09 43       	clr	r9		;
    bd1e:	0f 5d       	add	r13,	r15	;
    bd20:	16 43       	mov	#1,	r6	;r3 As==01
    bd22:	0f 9d       	cmp	r13,	r15	;
    bd24:	01 28       	jnc	$+4      	;abs 0xbd28
    bd26:	06 43       	clr	r6		;
    bd28:	09 d6       	bis	r6,	r9	;
    bd2a:	06 4e       	mov	r14,	r6	;
    bd2c:	1d 43       	mov	#1,	r13	;r3 As==01
    bd2e:	0e 9e       	cmp	r14,	r14	;
    bd30:	01 28       	jnc	$+4      	;abs 0xbd34
    bd32:	0d 43       	clr	r13		;
    bd34:	0e 59       	add	r9,	r14	;
    bd36:	19 43       	mov	#1,	r9	;r3 As==01
    bd38:	0e 96       	cmp	r6,	r14	;
    bd3a:	01 28       	jnc	$+4      	;abs 0xbd3e
    bd3c:	09 43       	clr	r9		;
    bd3e:	0d d9       	bis	r9,	r13	;
    bd40:	8a 4c 00 00 	mov	r12,	0(r10)	;
    bd44:	8a 4f 02 00 	mov	r15,	2(r10)	;
    bd48:	8a 4e 04 00 	mov	r14,	4(r10)	;
    bd4c:	0d 58       	add	r8,	r13	;
    bd4e:	8a 4d 06 00 	mov	r13,	6(r10)	;
	sensor_dot_products = &metrology.current.dot_prod[dp];

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
    bd52:	0c 44       	mov	r4,	r12	;
    bd54:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    bd58:	b0 12 14 d3 	call	#54036		;#0xd314
    bd5c:	3c 50 4a 00 	add	#74,	r12	;#0x004a
    bd60:	0a 4c       	mov	r12,	r10	;
    bd62:	3a 50 88 04 	add	#1160,	r10	;#0x0488
    bd66:	08 47       	mov	r7,	r8	;
    bd68:	19 41 08 00 	mov	8(r1),	r9	;
    bd6c:	09 93       	cmp	#0,	r9	;r3 As==00
    bd6e:	08 34       	jge	$+18     	;abs 0xbd80
    bd70:	0c 43       	clr	r12		;
    bd72:	0d 43       	clr	r13		;
    bd74:	0e 4c       	mov	r12,	r14	;
    bd76:	0f 4d       	mov	r13,	r15	;
    bd78:	0e 88       	sub	r8,	r14	;
    bd7a:	0f 79       	subc	r9,	r15	;
    bd7c:	08 4e       	mov	r14,	r8	;
    bd7e:	09 4f       	mov	r15,	r9	;
    bd80:	0d 49       	mov	r9,	r13	;
	uint32_t sum;

	if(x < 0) x = -x;

	/* Simplified multiplication */
	oplo = x;
    bd82:	81 48 06 00 	mov	r8,	6(r1)	;
	ophi = x >> 16;
    bd86:	0c 48       	mov	r8,	r12	;
    bd88:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    bd8c:	b0 12 5a d2 	call	#53850		;#0xd25a
    bd90:	07 4c       	mov	r12,	r7	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    bd92:	4c 43       	clr.b	r12		;
    bd94:	0d 48       	mov	r8,	r13	;
    bd96:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(oplo);
    bd9a:	0c 48       	mov	r8,	r12	;
    bd9c:	b0 12 50 ad 	call	#44368		;#0xad50
	*z += MPY_getResult();
    bda0:	b0 12 56 ad 	call	#44374		;#0xad56
    bda4:	29 4a       	mov	@r10,	r9	;
    bda6:	16 4a 02 00 	mov	2(r10),	r6	;
    bdaa:	1e 4a 04 00 	mov	4(r10),	r14	;
    bdae:	18 4a 06 00 	mov	6(r10),	r8	;
    bdb2:	0c 59       	add	r9,	r12	;
    bdb4:	1f 43       	mov	#1,	r15	;r3 As==01
    bdb6:	0c 99       	cmp	r9,	r12	;
    bdb8:	01 28       	jnc	$+4      	;abs 0xbdbc
    bdba:	0f 43       	clr	r15		;
    bdbc:	0d 56       	add	r6,	r13	;
    bdbe:	19 43       	mov	#1,	r9	;r3 As==01
    bdc0:	0d 96       	cmp	r6,	r13	;
    bdc2:	01 28       	jnc	$+4      	;abs 0xbdc6
    bdc4:	09 43       	clr	r9		;
    bdc6:	0f 5d       	add	r13,	r15	;
    bdc8:	16 43       	mov	#1,	r6	;r3 As==01
    bdca:	0f 9d       	cmp	r13,	r15	;
    bdcc:	01 28       	jnc	$+4      	;abs 0xbdd0
    bdce:	06 43       	clr	r6		;
    bdd0:	09 d6       	bis	r6,	r9	;
    bdd2:	06 4e       	mov	r14,	r6	;
    bdd4:	1d 43       	mov	#1,	r13	;r3 As==01
    bdd6:	0e 9e       	cmp	r14,	r14	;
    bdd8:	01 28       	jnc	$+4      	;abs 0xbddc
    bdda:	0d 43       	clr	r13		;
    bddc:	0e 59       	add	r9,	r14	;
    bdde:	19 43       	mov	#1,	r9	;r3 As==01
    bde0:	0e 96       	cmp	r6,	r14	;
    bde2:	01 28       	jnc	$+4      	;abs 0xbde6
    bde4:	09 43       	clr	r9		;
    bde6:	0d d9       	bis	r9,	r13	;
    bde8:	8a 4c 00 00 	mov	r12,	0(r10)	;
    bdec:	8a 4f 02 00 	mov	r15,	2(r10)	;
    bdf0:	8a 4e 04 00 	mov	r14,	4(r10)	;
    bdf4:	0d 58       	add	r8,	r13	;
    bdf6:	8a 4d 06 00 	mov	r13,	6(r10)	;

	MPY_setOperandTwo16Bit(ophi);
    bdfa:	0c 47       	mov	r7,	r12	;
    bdfc:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    be00:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 16;
    be04:	0f 43       	clr	r15		;
    be06:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    be0a:	00 00 
    be0c:	0e 4f       	mov	r15,	r14	;
    be0e:	b0 12 14 cd 	call	#52500		;#0xcd14
    be12:	0b 4d       	mov	r13,	r11	;
    be14:	05 4e       	mov	r14,	r5	;
    be16:	06 4c       	mov	r12,	r6	;
    be18:	06 5c       	add	r12,	r6	;
    be1a:	18 43       	mov	#1,	r8	;r3 As==01
    be1c:	06 9c       	cmp	r12,	r6	;
    be1e:	01 28       	jnc	$+4      	;abs 0xbe22
    be20:	08 43       	clr	r8		;
    be22:	0d 5d       	rla	r13		;
    be24:	19 43       	mov	#1,	r9	;r3 As==01
    be26:	0d 9b       	cmp	r11,	r13	;
    be28:	01 28       	jnc	$+4      	;abs 0xbe2c
    be2a:	09 43       	clr	r9		;
    be2c:	08 5d       	add	r13,	r8	;
    be2e:	1c 43       	mov	#1,	r12	;r3 As==01
    be30:	08 9d       	cmp	r13,	r8	;
    be32:	01 28       	jnc	$+4      	;abs 0xbe36
    be34:	0c 43       	clr	r12		;
    be36:	09 dc       	bis	r12,	r9	;
    be38:	0e 5e       	rla	r14		;
    be3a:	1c 43       	mov	#1,	r12	;r3 As==01
    be3c:	0e 95       	cmp	r5,	r14	;
    be3e:	01 28       	jnc	$+4      	;abs 0xbe42
    be40:	0c 43       	clr	r12		;
    be42:	09 5e       	add	r14,	r9	;
    be44:	1d 43       	mov	#1,	r13	;r3 As==01
    be46:	09 9e       	cmp	r14,	r9	;
    be48:	01 28       	jnc	$+4      	;abs 0xbe4c
    be4a:	0d 43       	clr	r13		;
    be4c:	0c dd       	bis	r13,	r12	;
    be4e:	0f 5f       	rla	r15		;
    be50:	0f 5c       	add	r12,	r15	;
	*z += (uint64_t) sum << 16;
    be52:	25 4a       	mov	@r10,	r5	;
    be54:	1e 4a 02 00 	mov	2(r10),	r14	;
    be58:	1d 4a 04 00 	mov	4(r10),	r13	;
    be5c:	1b 4a 06 00 	mov	6(r10),	r11	;
    be60:	06 55       	add	r5,	r6	;
    be62:	1c 43       	mov	#1,	r12	;r3 As==01
    be64:	06 95       	cmp	r5,	r6	;
    be66:	01 28       	jnc	$+4      	;abs 0xbe6a
    be68:	0c 43       	clr	r12		;
    be6a:	08 5e       	add	r14,	r8	;
    be6c:	15 43       	mov	#1,	r5	;r3 As==01
    be6e:	08 9e       	cmp	r14,	r8	;
    be70:	01 28       	jnc	$+4      	;abs 0xbe74
    be72:	05 43       	clr	r5		;
    be74:	0c 58       	add	r8,	r12	;
    be76:	1e 43       	mov	#1,	r14	;r3 As==01
    be78:	0c 98       	cmp	r8,	r12	;
    be7a:	01 28       	jnc	$+4      	;abs 0xbe7e
    be7c:	0e 43       	clr	r14		;
    be7e:	05 de       	bis	r14,	r5	;
    be80:	09 5d       	add	r13,	r9	;
    be82:	1e 43       	mov	#1,	r14	;r3 As==01
    be84:	09 9d       	cmp	r13,	r9	;
    be86:	01 28       	jnc	$+4      	;abs 0xbe8a
    be88:	0e 43       	clr	r14		;
    be8a:	05 59       	add	r9,	r5	;
    be8c:	1d 43       	mov	#1,	r13	;r3 As==01
    be8e:	05 99       	cmp	r9,	r5	;
    be90:	01 28       	jnc	$+4      	;abs 0xbe94
    be92:	0d 43       	clr	r13		;
    be94:	0e dd       	bis	r13,	r14	;
    be96:	0f 5b       	add	r11,	r15	;
    be98:	8a 46 00 00 	mov	r6,	0(r10)	;
    be9c:	8a 4c 02 00 	mov	r12,	2(r10)	;
    bea0:	8a 45 04 00 	mov	r5,	4(r10)	;
    bea4:	0e 5f       	add	r15,	r14	;
    bea6:	8a 4e 06 00 	mov	r14,	6(r10)	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, ophi);
    beaa:	4c 43       	clr.b	r12		;
    beac:	0d 47       	mov	r7,	r13	;
    beae:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(ophi);
    beb2:	0c 47       	mov	r7,	r12	;
    beb4:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    beb8:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 32;
    bebc:	0f 43       	clr	r15		;
    bebe:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    bec2:	00 00 
    bec4:	0e 4f       	mov	r15,	r14	;
    bec6:	b0 12 14 cd 	call	#52500		;#0xcd14
    beca:	25 4a       	mov	@r10,	r5	;
    becc:	16 4a 02 00 	mov	2(r10),	r6	;
    bed0:	18 4a 04 00 	mov	4(r10),	r8	;
    bed4:	1b 4a 06 00 	mov	6(r10),	r11	;
    bed8:	0c 55       	add	r5,	r12	;
    beda:	19 43       	mov	#1,	r9	;r3 As==01
    bedc:	0c 95       	cmp	r5,	r12	;
    bede:	01 28       	jnc	$+4      	;abs 0xbee2
    bee0:	09 43       	clr	r9		;
    bee2:	0d 56       	add	r6,	r13	;
    bee4:	15 43       	mov	#1,	r5	;r3 As==01
    bee6:	0d 96       	cmp	r6,	r13	;
    bee8:	01 28       	jnc	$+4      	;abs 0xbeec
    beea:	05 43       	clr	r5		;
    beec:	09 5d       	add	r13,	r9	;
    beee:	16 43       	mov	#1,	r6	;r3 As==01
    bef0:	09 9d       	cmp	r13,	r9	;
    bef2:	01 28       	jnc	$+4      	;abs 0xbef6
    bef4:	06 43       	clr	r6		;
    bef6:	05 d6       	bis	r6,	r5	;
    bef8:	0e 58       	add	r8,	r14	;
    befa:	1d 43       	mov	#1,	r13	;r3 As==01
    befc:	0e 98       	cmp	r8,	r14	;
    befe:	01 28       	jnc	$+4      	;abs 0xbf02
    bf00:	0d 43       	clr	r13		;
    bf02:	05 5e       	add	r14,	r5	;
    bf04:	18 43       	mov	#1,	r8	;r3 As==01
    bf06:	05 9e       	cmp	r14,	r5	;
    bf08:	01 28       	jnc	$+4      	;abs 0xbf0c
    bf0a:	08 43       	clr	r8		;
    bf0c:	0d d8       	bis	r8,	r13	;
    bf0e:	0f 5b       	add	r11,	r15	;
    bf10:	8a 4c 00 00 	mov	r12,	0(r10)	;
    bf14:	8a 49 02 00 	mov	r9,	2(r10)	;
    bf18:	8a 45 04 00 	mov	r5,	4(r10)	;
    bf1c:	0d 5f       	add	r15,	r13	;
    bf1e:	8a 4d 06 00 	mov	r13,	6(r10)	;

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
	mac64_16_24_mpy(sensor_dot_products->P_active, V_sample, I_sample);
    bf22:	0c 44       	mov	r4,	r12	;
    bf24:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    bf28:	b0 12 14 d3 	call	#54036		;#0xd314
    bf2c:	3c 50 3a 00 	add	#58,	r12	;#0x003a
    bf30:	05 4c       	mov	r12,	r5	;
    bf32:	35 50 88 04 	add	#1160,	r5	;#0x0488
	if(y < 0) y = -y;

	oplo = x;
	ophi = y >> 16;
	//MSB
	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    bf36:	4c 43       	clr.b	r12		;
    bf38:	1d 41 04 00 	mov	4(r1),	r13	;
    bf3c:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(ophi);
    bf40:	36 40 50 ad 	mov	#44368,	r6	;#0xad50
    bf44:	0c 47       	mov	r7,	r12	;
    bf46:	86 12       	call	r6		;
	result = (uint64_t)MPY_getResult() << 16;
    bf48:	37 40 56 ad 	mov	#44374,	r7	;#0xad56
    bf4c:	87 12       	call	r7		;
    bf4e:	0f 43       	clr	r15		;
    bf50:	3a 40 14 cd 	mov	#52500,	r10	;#0xcd14
    bf54:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    bf58:	00 00 
    bf5a:	0e 4f       	mov	r15,	r14	;
    bf5c:	8a 12       	call	r10		;
	result <<= 16;
    bf5e:	8a 12       	call	r10		;
    bf60:	08 4c       	mov	r12,	r8	;
    bf62:	09 4d       	mov	r13,	r9	;
    bf64:	0a 4e       	mov	r14,	r10	;
    bf66:	81 4f 04 00 	mov	r15,	4(r1)	;
    bf6a:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    bf6e:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c

	//LSB
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
    bf72:	1c 41 06 00 	mov	6(r1),	r12	;
    bf76:	86 12       	call	r6		;
	result += MPY_getResult();
    bf78:	87 12       	call	r7		;
    bf7a:	07 48       	mov	r8,	r7	;
    bf7c:	07 5c       	add	r12,	r7	;
    bf7e:	1c 43       	mov	#1,	r12	;r3 As==01
    bf80:	07 98       	cmp	r8,	r7	;
    bf82:	01 28       	jnc	$+4      	;abs 0xbf86
    bf84:	0c 43       	clr	r12		;
    bf86:	0d 59       	add	r9,	r13	;
    bf88:	19 43       	mov	#1,	r9	;r3 As==01
    bf8a:	1d 91 0a 00 	cmp	10(r1),	r13	;0x0000a
    bf8e:	01 28       	jnc	$+4      	;abs 0xbf92
    bf90:	09 43       	clr	r9		;
    bf92:	08 4c       	mov	r12,	r8	;
    bf94:	08 5d       	add	r13,	r8	;
    bf96:	1c 43       	mov	#1,	r12	;r3 As==01
    bf98:	08 9d       	cmp	r13,	r8	;
    bf9a:	01 28       	jnc	$+4      	;abs 0xbf9e
    bf9c:	0c 43       	clr	r12		;
    bf9e:	09 dc       	bis	r12,	r9	;
    bfa0:	1d 43       	mov	#1,	r13	;r3 As==01
    bfa2:	1a 91 0c 00 	cmp	12(r1),	r10	;0x0000c
    bfa6:	01 28       	jnc	$+4      	;abs 0xbfaa
    bfa8:	0d 43       	clr	r13		;
    bfaa:	09 5a       	add	r10,	r9	;
    bfac:	1c 43       	mov	#1,	r12	;r3 As==01
    bfae:	09 9a       	cmp	r10,	r9	;
    bfb0:	01 28       	jnc	$+4      	;abs 0xbfb4
    bfb2:	0c 43       	clr	r12		;
    bfb4:	0d dc       	bis	r12,	r13	;
    bfb6:	1d 51 04 00 	add	4(r1),	r13	;
    bfba:	81 4d 04 00 	mov	r13,	4(r1)	;
    bfbe:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    bfc2:	2a 45       	mov	@r5,	r10	;
    bfc4:	91 45 02 00 	mov	2(r5),	6(r1)	;
    bfc8:	06 00 
    bfca:	16 45 04 00 	mov	4(r5),	r6	;
    bfce:	91 45 06 00 	mov	6(r5),	10(r1)	; 0x000a
    bfd2:	0a 00 
	sum = MPY_getResult();
	*z += (uint64_t) sum << 32;
}

static __inline__ void mac64_16_24_mpy(register int64_t *z, register int16_t x, register int32_t y){
	int sign = (x ^ y) < 0;	// 0 = positive, 1 = negative
    bfd4:	1f 41 02 00 	mov	2(r1),	r15	;
    bfd8:	0c 4f       	mov	r15,	r12	;
    bfda:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    bfde:	0d 7d       	subc	r13,	r13	;
    bfe0:	3d e3       	inv	r13		;
    bfe2:	1c 41 08 00 	mov	8(r1),	r12	;
    bfe6:	0c ed       	xor	r13,	r12	;
    bfe8:	b0 12 60 d2 	call	#53856		;#0xd260
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
	result += MPY_getResult();

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    bfec:	0d 43       	clr	r13		;
    bfee:	0d 9c       	cmp	r12,	r13	;
    bff0:	27 34       	jge	$+80     	;abs 0xc040
    bff2:	0b 4d       	mov	r13,	r11	;
    bff4:	0c 4d       	mov	r13,	r12	;
    bff6:	0c 87       	sub	r7,	r12	;
    bff8:	1f 43       	mov	#1,	r15	;r3 As==01
    bffa:	0c 9d       	cmp	r13,	r12	;
    bffc:	01 20       	jnz	$+4      	;abs 0xc000
    bffe:	0f 4d       	mov	r13,	r15	;
    c000:	0e 4d       	mov	r13,	r14	;
    c002:	1e 81 0c 00 	sub	12(r1),	r14	;0x0000c
    c006:	17 43       	mov	#1,	r7	;r3 As==01
    c008:	0d 9e       	cmp	r14,	r13	;
    c00a:	01 28       	jnc	$+4      	;abs 0xc00e
    c00c:	07 43       	clr	r7		;
    c00e:	08 4e       	mov	r14,	r8	;
    c010:	08 8f       	sub	r15,	r8	;
    c012:	1f 43       	mov	#1,	r15	;r3 As==01
    c014:	0e 98       	cmp	r8,	r14	;
    c016:	01 28       	jnc	$+4      	;abs 0xc01a
    c018:	0f 43       	clr	r15		;
    c01a:	07 df       	bis	r15,	r7	;
    c01c:	0e 4d       	mov	r13,	r14	;
    c01e:	0e 89       	sub	r9,	r14	;
    c020:	1f 43       	mov	#1,	r15	;r3 As==01
    c022:	0b 9e       	cmp	r14,	r11	;
    c024:	01 28       	jnc	$+4      	;abs 0xc028
    c026:	0f 43       	clr	r15		;
    c028:	09 4e       	mov	r14,	r9	;
    c02a:	09 87       	sub	r7,	r9	;
    c02c:	17 43       	mov	#1,	r7	;r3 As==01
    c02e:	0e 99       	cmp	r9,	r14	;
    c030:	01 28       	jnc	$+4      	;abs 0xc034
    c032:	07 43       	clr	r7		;
    c034:	0f d7       	bis	r7,	r15	;
    c036:	1d 81 04 00 	sub	4(r1),	r13	;
    c03a:	0d 8f       	sub	r15,	r13	;
    c03c:	30 40 46 c0 	br	#0xc046		;
    c040:	0c 47       	mov	r7,	r12	;
    c042:	1d 41 04 00 	mov	4(r1),	r13	;
    c046:	0c 5a       	add	r10,	r12	;
    c048:	1e 43       	mov	#1,	r14	;r3 As==01
    c04a:	0c 9a       	cmp	r10,	r12	;
    c04c:	01 28       	jnc	$+4      	;abs 0xc050
    c04e:	0e 43       	clr	r14		;
    c050:	18 51 06 00 	add	6(r1),	r8	;
    c054:	1f 43       	mov	#1,	r15	;r3 As==01
    c056:	18 91 06 00 	cmp	6(r1),	r8	;
    c05a:	01 28       	jnc	$+4      	;abs 0xc05e
    c05c:	0f 43       	clr	r15		;
    c05e:	0e 58       	add	r8,	r14	;
    c060:	1a 43       	mov	#1,	r10	;r3 As==01
    c062:	0e 98       	cmp	r8,	r14	;
    c064:	01 28       	jnc	$+4      	;abs 0xc068
    c066:	0a 43       	clr	r10		;
    c068:	0f da       	bis	r10,	r15	;
    c06a:	09 56       	add	r6,	r9	;
    c06c:	1a 43       	mov	#1,	r10	;r3 As==01
    c06e:	09 96       	cmp	r6,	r9	;
    c070:	01 28       	jnc	$+4      	;abs 0xc074
    c072:	0a 43       	clr	r10		;
    c074:	0f 59       	add	r9,	r15	;
    c076:	18 43       	mov	#1,	r8	;r3 As==01
    c078:	0f 99       	cmp	r9,	r15	;
    c07a:	01 28       	jnc	$+4      	;abs 0xc07e
    c07c:	08 43       	clr	r8		;
    c07e:	0a d8       	bis	r8,	r10	;
    c080:	1d 51 0a 00 	add	10(r1),	r13	;0x0000a
    c084:	85 4c 00 00 	mov	r12,	0(r5)	;
    c088:	85 4e 02 00 	mov	r14,	2(r5)	;
    c08c:	85 4f 04 00 	mov	r15,	4(r5)	;
    c090:	0a 5d       	add	r13,	r10	;
    c092:	85 4a 06 00 	mov	r10,	6(r5)	;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
	mac64_16_24_mpy(sensor_dot_products->P_active, V_sample, I_sample);

	phase_dot_products->sample_count++;
    c096:	39 40 88 04 	mov	#1160,	r9	;#0x0488
    c09a:	0c 44       	mov	r4,	r12	;
    c09c:	0c 54       	add	r4,	r12	;
    c09e:	0c 5c       	rla	r12		;
    c0a0:	0c 54       	add	r4,	r12	;
    c0a2:	0c 5c       	rla	r12		;
    c0a4:	0c 59       	add	r9,	r12	;
    c0a6:	9c 53 20 00 	inc	32(r12)		;
	sensor_dot_products->sample_count++;
    c0aa:	38 40 14 d3 	mov	#54036,	r8	;#0xd314
    c0ae:	0c 44       	mov	r4,	r12	;
    c0b0:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    c0b4:	88 12       	call	r8		;
    c0b6:	0c 59       	add	r9,	r12	;
    c0b8:	0a 4c       	mov	r12,	r10	;
    c0ba:	3a 50 52 00 	add	#82,	r10	;#0x0052
    c0be:	9a 53 00 00 	inc	0(r10)		;




    //metrology.V_history_index = (metrology.V_history_index + 1) & V_HISTORY_MASK;
    metrology.voltage_period.cycle_samples += 256;
    c0c2:	17 49 7c 00 	mov	124(r9),r7	;0x0007c
    c0c6:	05 47       	mov	r7,	r5	;
    c0c8:	35 50 00 01 	add	#256,	r5	;#0x0100
    c0cc:	89 45 7c 00 	mov	r5,	124(r9)	; 0x007c
	if (abs32(V_corrected - metrology.last_V_sample) <= metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
    c0d0:	1a 41 02 00 	mov	2(r1),	r10	;
    c0d4:	1a 89 84 00 	sub	132(r9),r10	;0x00084
    c0d8:	16 49 82 00 	mov	130(r9),r6	;0x00082
    c0dc:	08 4a       	mov	r10,	r8	;
    c0de:	38 b0 00 80 	bit	#32768,	r8	;#0x8000
    c0e2:	09 79       	subc	r9,	r9	;
    c0e4:	39 e3       	inv	r9		;
	status |= PHASE_STATUS_NEW_LOG;
}

static __inline__ int32_t abs32(int32_t x)
{
    return (x < 0)  ?  -x  :  x;
    c0e6:	09 93       	cmp	#0,	r9	;r3 As==00
    c0e8:	08 34       	jge	$+18     	;abs 0xc0fa
    c0ea:	0c 43       	clr	r12		;
    c0ec:	0d 43       	clr	r13		;
    c0ee:	0e 4c       	mov	r12,	r14	;
    c0f0:	0f 4d       	mov	r13,	r15	;
    c0f2:	0e 88       	sub	r8,	r14	;
    c0f4:	0f 79       	subc	r9,	r15	;
    c0f6:	08 4e       	mov	r14,	r8	;
    c0f8:	09 4f       	mov	r15,	r9	;



    //metrology.V_history_index = (metrology.V_history_index + 1) & V_HISTORY_MASK;
    metrology.voltage_period.cycle_samples += 256;
	if (abs32(V_corrected - metrology.last_V_sample) <= metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
    c0fa:	0c 46       	mov	r6,	r12	;
    c0fc:	3d 40 a0 0f 	mov	#4000,	r13	;#0x0fa0
    c100:	b0 12 14 d3 	call	#54036		;#0xd314
    c104:	0e 4c       	mov	r12,	r14	;
    c106:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    c10a:	0f 7f       	subc	r15,	r15	;
    c10c:	3f e3       	inv	r15		;
    c10e:	0f 99       	cmp	r9,	r15	;
    c110:	be 38       	jl	$+382    	;abs 0xc28e
    c112:	09 9f       	cmp	r15,	r9	;
    c114:	02 20       	jnz	$+6      	;abs 0xc11a
    c116:	0c 98       	cmp	r8,	r12	;
    c118:	ba 28       	jnc	$+374    	;abs 0xc28e
	{
		/* This doesn't look like a spike - do mains cycle detection, and
           estimate the precise mains period */
		if(V_corrected < 0){
    c11a:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    c11e:	19 34       	jge	$+52     	;abs 0xc152
			/* We just crossed from positive to negative */
			/* Log the sign of the signal */
			status &= ~PHASE_STATUS_V_POS;
    c120:	a2 c3 10 05 	bic	#2,	&0x0510	;r3 As==10
                    loggers |= 1;
			}
            /* Log the sign of the signal */
            status |= PHASE_STATUS_V_POS;
		}
        metrology.since_last = 0;
    c124:	3d 40 88 04 	mov	#1160,	r13	;#0x0488
        metrology.last_V_sample = V_corrected;
    c128:	9d 41 02 00 	mov	2(r1),	132(r13); 0x0084
    c12c:	84 00 
	}
	metrology.since_last++;
    c12e:	9d 43 82 00 	mov	#1,	130(r13);r3 As==01, 0x0082

    if (phase_dot_products->sample_count >= samples_per_second + 2*SAMPLE_RATE/MAINS_NOMINAL_FREQUENCY)
    c132:	0c 44       	mov	r4,	r12	;
    c134:	0c 54       	add	r4,	r12	;
    c136:	0c 5c       	rla	r12		;
    c138:	0c 54       	add	r4,	r12	;
    c13a:	0c 5c       	rla	r12		;
    c13c:	0c 5d       	add	r13,	r12	;
    c13e:	1d 42 18 02 	mov	&0x0218,r13	;0x0218
    c142:	3d 50 a0 00 	add	#160,	r13	;#0x00a0
    c146:	8c 9d 20 00 	cmp	r13,	32(r12)	; 0x0020
    c14a:	92 34       	jge	$+294    	;abs 0xc270
int16_t V_History_SampleCount = 0;
int16_t V_History_break = 9999;

static __inline__ int per_sample_dsp(void)
{
	int kick = 0;
    c14c:	0c 43       	clr	r12		;
    c14e:	30 40 b8 c2 	br	#0xc2b8		;
			/* Log the sign of the signal */
			status &= ~PHASE_STATUS_V_POS;
		}
		else{
			/* We just crossed from negative to positive */
			if (!(status & PHASE_STATUS_V_POS))
    c152:	e2 b3 10 05 	bit.b	#2,	&0x0510	;r3 As==10
    c156:	73 20       	jnz	$+232    	;abs 0xc23e
			{
				V_History_break = V_History_SampleCount + 24;
    c158:	1f 42 0a 02 	mov	&0x020a,r15	;0x020a
    c15c:	3f 50 18 00 	add	#24,	r15	;#0x0018
    c160:	82 4f 08 02 	mov	r15,	&0x0208	;
				/* The mains should be <40Hz or >70Hz to fail this test! */
				if (256*SAMPLES_PER_10_SECONDS/700 <= metrology.voltage_period.cycle_samples
						&&
    c164:	37 50 dc c7 	add	#51164,	r7	;#0xc7dc
			/* We just crossed from negative to positive */
			if (!(status & PHASE_STATUS_V_POS))
			{
				V_History_break = V_History_SampleCount + 24;
				/* The mains should be <40Hz or >70Hz to fail this test! */
				if (256*SAMPLES_PER_10_SECONDS/700 <= metrology.voltage_period.cycle_samples
    c168:	3c 40 dc 2a 	mov	#10972,	r12	;#0x2adc
    c16c:	0c 97       	cmp	r7,	r12	;
    c16e:	55 28       	jnc	$+172    	;abs 0xc21a
    c170:	3c 42       	mov	#8,	r12	;r2 As==11
    c172:	07 43       	clr	r7		;
    c174:	0e 47       	mov	r7,	r14	;
    c176:	1f 41 02 00 	mov	2(r1),	r15	;
					//z = V_corrected - last_V_sample;
					x = 0;
					y = 0;
					for (k = 0;  k < 8;  k++)
					{
						y <<= 1;
    c17a:	07 57       	rla	r7		;
						z >>= 1;
    c17c:	0a 11       	rra	r10		;
						x += z;
    c17e:	0d 4e       	mov	r14,	r13	;
    c180:	0d 5a       	add	r10,	r13	;
						if (x > V_corrected)
    c182:	0f 9d       	cmp	r13,	r15	;
    c184:	02 38       	jl	$+6      	;abs 0xc18a
						//if (x > V_corrected)
							x -= z;
						else
							y |= 1;
    c186:	17 d3       	bis	#1,	r7	;r3 As==01
					y = 0;
					for (k = 0;  k < 8;  k++)
					{
						y <<= 1;
						z >>= 1;
						x += z;
    c188:	0e 4d       	mov	r13,	r14	;
    c18a:	3c 53       	add	#-1,	r12	;r3 As==11
					/* Interpolate the zero crossing by successive approx. Its faster than just dividing. */
					z = V_corrected - metrology.last_V_sample;
					//z = V_corrected - last_V_sample;
					x = 0;
					y = 0;
					for (k = 0;  k < 8;  k++)
    c18c:	0c 93       	cmp	#0,	r12	;r3 As==00
    c18e:	f5 23       	jnz	$-20     	;abs 0xc17a
    c190:	0c 47       	mov	r7,	r12	;
						else
							y |= 1;
					}
					/* Now we need to allow for skipped samples, due to spike detection */
					z = y;
					while (metrology.since_last > 1)
    c192:	1d 42 0a 05 	mov	&0x050a,r13	;0x050a
    c196:	1e 43       	mov	#1,	r14	;r3 As==01
    c198:	0e 9d       	cmp	r13,	r14	;
    c19a:	0b 34       	jge	$+24     	;abs 0xc1b2
    c19c:	0e 4d       	mov	r13,	r14	;
					{
						z += y;
						metrology.since_last--;
    c19e:	3e 53       	add	#-1,	r14	;r3 As==11
						else
							y |= 1;
					}
					/* Now we need to allow for skipped samples, due to spike detection */
					z = y;
					while (metrology.since_last > 1)
    c1a0:	1e 93       	cmp	#1,	r14	;r3 As==01
    c1a2:	fd 23       	jnz	$-4      	;abs 0xc19e
    c1a4:	07 4c       	mov	r12,	r7	;
    c1a6:	07 5c       	add	r12,	r7	;
    c1a8:	3d 50 fe ff 	add	#65534,	r13	;#0xfffe
    c1ac:	b0 12 14 d3 	call	#54036		;#0xd314
    c1b0:	07 5c       	add	r12,	r7	;
					}
					/* z is now the fraction of a sample interval between the zero
            		   crossing and the current sample, in units of 1/256 of a sample */
				    /* A lightly damped single pole filter should now be enough to remove noise and get a
				       stable value for the frequency */
					metrology.voltage_period.period += ((int32_t) (metrology.voltage_period.cycle_samples - z) << 12) - (metrology.voltage_period.period >> 4);
    c1b2:	3a 40 88 04 	mov	#1160,	r10	;#0x0488
    c1b6:	18 4a 7e 00 	mov	126(r10),r8	;0x0007e
    c1ba:	19 4a 80 00 	mov	128(r10),r9	;0x00080
    c1be:	0c 48       	mov	r8,	r12	;
    c1c0:	0d 49       	mov	r9,	r13	;
    c1c2:	b0 12 ec d2 	call	#53996		;#0xd2ec
    c1c6:	08 8c       	sub	r12,	r8	;
    c1c8:	09 7d       	subc	r13,	r9	;
    c1ca:	0d 43       	clr	r13		;
    c1cc:	0e 4d       	mov	r13,	r14	;
    c1ce:	0d 45       	mov	r5,	r13	;
    c1d0:	0d 87       	sub	r7,	r13	;
    c1d2:	0c 4d       	mov	r13,	r12	;
    c1d4:	0c 5d       	add	r13,	r12	;
    c1d6:	0d 4e       	mov	r14,	r13	;
    c1d8:	0d 6e       	addc	r14,	r13	;
    c1da:	0c 5c       	rla	r12		;
    c1dc:	0d 6d       	rlc	r13		;
    c1de:	0c 5c       	rla	r12		;
    c1e0:	0d 6d       	rlc	r13		;
    c1e2:	0c 5c       	rla	r12		;
    c1e4:	0d 6d       	rlc	r13		;
    c1e6:	0c 5c       	rla	r12		;
    c1e8:	0d 6d       	rlc	r13		;
    c1ea:	0c 5c       	rla	r12		;
    c1ec:	0d 6d       	rlc	r13		;
    c1ee:	0c 5c       	rla	r12		;
    c1f0:	0d 6d       	rlc	r13		;
    c1f2:	0c 5c       	rla	r12		;
    c1f4:	0d 6d       	rlc	r13		;
    c1f6:	0c 5c       	rla	r12		;
    c1f8:	0d 6d       	rlc	r13		;
    c1fa:	0c 5c       	rla	r12		;
    c1fc:	0d 6d       	rlc	r13		;
    c1fe:	0c 5c       	rla	r12		;
    c200:	0d 6d       	rlc	r13		;
    c202:	0c 5c       	rla	r12		;
    c204:	0d 6d       	rlc	r13		;
    c206:	0c 58       	add	r8,	r12	;
    c208:	8a 4c 7e 00 	mov	r12,	126(r10); 0x007e
    c20c:	0d 69       	addc	r9,	r13	;
    c20e:	8a 4d 80 00 	mov	r13,	128(r10); 0x0080
					/* Start the next cycle with the residual fraction of a sample */
					metrology.voltage_period.cycle_samples = z;
    c212:	8a 47 7c 00 	mov	r7,	124(r10); 0x007c
    c216:	30 40 1e c2 	br	#0xc21e		;
				}
				else
				{
					metrology.voltage_period.cycle_samples = 0;
    c21a:	82 43 04 05 	mov	#0,	&0x0504	;r3 As==00
				}

                if (phase_dot_products->sample_count >= samples_per_second)
    c21e:	0c 44       	mov	r4,	r12	;
    c220:	0c 54       	add	r4,	r12	;
    c222:	0c 5c       	rla	r12		;
    c224:	0c 54       	add	r4,	r12	;
    c226:	0c 5c       	rla	r12		;
    c228:	3c 50 88 04 	add	#1160,	r12	;#0x0488
    c22c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c22e:	9c 92 18 02 	cmp	&0x0218,32(r12)	;0x0218, 0x0020
    c232:	20 00 
    c234:	01 34       	jge	$+4      	;abs 0xc238
    c236:	4e 43       	clr.b	r14		;
	current_sample_t I_corrected = adc_i_buffer;
    int x, y, z, k;
    int dp;
	struct phase_dot_prod_set_s* phase_dot_products;
	struct current_sensor_dot_prod_set_s *sensor_dot_products;
	int8_t loggers = 0;
    c238:	8e 11       	sxt	r14		;
    c23a:	30 40 40 c2 	br	#0xc240		;
    c23e:	0e 43       	clr	r14		;

                if (phase_dot_products->sample_count >= samples_per_second)
                    loggers |= 1;
			}
            /* Log the sign of the signal */
            status |= PHASE_STATUS_V_POS;
    c240:	a2 d3 10 05 	bis	#2,	&0x0510	;r3 As==10
		}
        metrology.since_last = 0;
    c244:	3d 40 88 04 	mov	#1160,	r13	;#0x0488
        metrology.last_V_sample = V_corrected;
    c248:	9d 41 02 00 	mov	2(r1),	132(r13); 0x0084
    c24c:	84 00 
	}
	metrology.since_last++;
    c24e:	9d 43 82 00 	mov	#1,	130(r13);r3 As==01, 0x0082

    if (phase_dot_products->sample_count >= samples_per_second + 2*SAMPLE_RATE/MAINS_NOMINAL_FREQUENCY)
    c252:	0c 44       	mov	r4,	r12	;
    c254:	0c 54       	add	r4,	r12	;
    c256:	0c 5c       	rla	r12		;
    c258:	0c 54       	add	r4,	r12	;
    c25a:	0c 5c       	rla	r12		;
    c25c:	0c 5d       	add	r13,	r12	;
    c25e:	1d 42 18 02 	mov	&0x0218,r13	;0x0218
    c262:	3d 50 a0 00 	add	#160,	r13	;#0x00a0
    c266:	8c 9d 20 00 	cmp	r13,	32(r12)	; 0x0020
    c26a:	02 34       	jge	$+6      	;abs 0xc270
        /* We don't seem to be detecting the end of a mains cycle, so force
           the end of processing block condition. */
        loggers |= 1;
    }

    if (loggers)
    c26c:	0e 93       	cmp	#0,	r14	;r3 As==00
    c26e:	09 24       	jz	$+20     	;abs 0xc282
}

static void __inline__ log_parameters(void){

	/* Tell the foreground there are things to process, and swap the dot product sets. */
	metrology.dp_set ^= 1;
    c270:	3c 40 88 04 	mov	#1160,	r12	;#0x0488
    c274:	dc e3 87 00 	xor.b	#1,	135(r12);r3 As==01, 0x0087
	status |= PHASE_STATUS_NEW_LOG;
    c278:	92 d3 10 05 	bis	#1,	&0x0510	;r3 As==01

    if (loggers)
    {
        /* There are one or more phases to be logged */
        log_parameters();
        kick = 1;
    c27c:	1c 43       	mov	#1,	r12	;r3 As==01
    c27e:	30 40 b8 c2 	br	#0xc2b8		;
int16_t V_History_SampleCount = 0;
int16_t V_History_break = 9999;

static __inline__ int per_sample_dsp(void)
{
	int kick = 0;
    c282:	0c 43       	clr	r12		;
    c284:	30 40 b8 c2 	br	#0xc2b8		;
    c288:	0c 43       	clr	r12		;
    c28a:	30 40 b8 c2 	br	#0xc2b8		;
            status |= PHASE_STATUS_V_POS;
		}
        metrology.since_last = 0;
        metrology.last_V_sample = V_corrected;
	}
	metrology.since_last++;
    c28e:	3e 40 88 04 	mov	#1160,	r14	;#0x0488
    c292:	16 53       	inc	r6		;
    c294:	8e 46 82 00 	mov	r6,	130(r14); 0x0082

    if (phase_dot_products->sample_count >= samples_per_second + 2*SAMPLE_RATE/MAINS_NOMINAL_FREQUENCY)
    c298:	0d 44       	mov	r4,	r13	;
    c29a:	0d 54       	add	r4,	r13	;
    c29c:	0d 5d       	rla	r13		;
    c29e:	0c 4d       	mov	r13,	r12	;
    c2a0:	0c 54       	add	r4,	r12	;
    c2a2:	0c 5c       	rla	r12		;
    c2a4:	0c 5e       	add	r14,	r12	;
    c2a6:	1d 42 18 02 	mov	&0x0218,r13	;0x0218
    c2aa:	3d 50 a0 00 	add	#160,	r13	;#0x00a0
    c2ae:	8c 9d 20 00 	cmp	r13,	32(r12)	; 0x0020
    c2b2:	ea 3b       	jl	$-42     	;abs 0xc288
    c2b4:	30 40 70 c2 	br	#0xc270		;
        /* There are one or more phases to be logged */
        log_parameters();
        kick = 1;
    }
    return kick;
}
    c2b8:	31 50 0e 00 	add	#14,	r1	;#0x000e
    c2bc:	30 40 68 d1 	br	#0xd168		;

0000c2c0 <ADC16_0>:

static __inline__ int16_t ADC16_0(void)
{
	return SD24MEM0;
}
    c2c0:	1c 42 10 01 	mov	&0x0110,r12	;0x0110
    c2c4:	30 41       	ret			

0000c2c6 <ADC32_1>:

static __inline__ int32_t ADC32_1(void)
{
    sh_lo_t val;

    SD24CCTL1 &= ~SD24LSBACC;
    c2c6:	b2 f0 bf ff 	and	#65471,	&0x0104	;#0xffbf
    c2ca:	04 01 
    val.by16[1] = (int16_t) SD24MEM1 >> 8;
    c2cc:	1c 42 12 01 	mov	&0x0112,r12	;0x0112
    c2d0:	b0 12 fa d1 	call	#53754		;#0xd1fa
    c2d4:	0d 4c       	mov	r12,	r13	;
    SD24CCTL1 |= SD24LSBACC;
    c2d6:	b2 d0 40 00 	bis	#64,	&0x0104	;#0x0040
    c2da:	04 01 
#if (OSR_FILTER == 256)
    val.by16[0] = (int16_t) SD24MEM1;
#elif (OSR_FILTER == 128)
    val.by16[0] = (int16_t) SD24MEM1 << 3;
    c2dc:	1e 42 12 01 	mov	&0x0112,r14	;0x0112
    c2e0:	0e 5e       	rla	r14		;
    c2e2:	0c 4e       	mov	r14,	r12	;
    c2e4:	0c 5e       	add	r14,	r12	;
#else
#error UNSUPPORTED OSR VALUE
#endif
    return val.by32;
}
    c2e6:	0c 5c       	rla	r12		;
    c2e8:	30 41       	ret			

0000c2ea <SD24_ISR>:

void __attribute__ ((interrupt(SD24_VECTOR))) SD24_ISR(void){
    c2ea:	0f 12       	push	r15		;
    c2ec:	0e 12       	push	r14		;
    c2ee:	0d 12       	push	r13		;
    c2f0:	0c 12       	push	r12		;
    c2f2:	0b 12       	push	r11		;
    c2f4:	0a 12       	push	r10		;
    c2f6:	09 12       	push	r9		;
    c2f8:	08 12       	push	r8		;
    c2fa:	07 12       	push	r7		;
    c2fc:	06 12       	push	r6		;
    c2fe:	05 12       	push	r5		;
    c300:	04 12       	push	r4		;
    c302:	31 80 0e 00 	sub	#14,	r1	;#0x000e
	switch(__even_in_range(SD24IV,SD24IV_SD24MEM3))
    c306:	1c 42 f0 01 	mov	&0x01f0,r12	;0x01f0
    c30a:	3c 90 06 00 	cmp	#6,	r12	;
    c30e:	02 24       	jz	$+6      	;abs 0xc314
    c310:	30 40 24 c9 	br	#0xc924		;
	case SD24IV_NONE: break;
	case SD24IV_SD24OVIFG: break;
	case SD24IV_SD24MEM0: break;
	case SD24IV_SD24MEM1:

		adc_v_buffer = ADC16_0();
    c314:	92 42 10 01 	mov	&0x0110,&0x0426	;0x0110
    c318:	26 04 

static __inline__ int32_t ADC32_1(void)
{
    sh_lo_t val;

    SD24CCTL1 &= ~SD24LSBACC;
    c31a:	b2 f0 bf ff 	and	#65471,	&0x0104	;#0xffbf
    c31e:	04 01 
    val.by16[1] = (int16_t) SD24MEM1 >> 8;
    c320:	1c 42 12 01 	mov	&0x0112,r12	;0x0112
    c324:	b0 12 fa d1 	call	#53754		;#0xd1fa
    SD24CCTL1 |= SD24LSBACC;
    c328:	b2 d0 40 00 	bis	#64,	&0x0104	;#0x0040
    c32c:	04 01 
#if (OSR_FILTER == 256)
    val.by16[0] = (int16_t) SD24MEM1;
#elif (OSR_FILTER == 128)
    val.by16[0] = (int16_t) SD24MEM1 << 3;
    c32e:	1d 42 12 01 	mov	&0x0112,r13	;0x0112
    c332:	0d 5d       	rla	r13		;
    c334:	0d 5d       	rla	r13		;
	case SD24IV_SD24OVIFG: break;
	case SD24IV_SD24MEM0: break;
	case SD24IV_SD24MEM1:

		adc_v_buffer = ADC16_0();
		adc_i_buffer = ADC32_1();
    c336:	0d 5d       	rla	r13		;
    c338:	82 4d 22 04 	mov	r13,	&0x0422	;
    c33c:	82 4c 24 04 	mov	r12,	&0x0424	;

		GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN2);
    c340:	6c 43       	mov.b	#2,	r12	;r3 As==10
    c342:	2d 42       	mov	#4,	r13	;r2 As==10
    c344:	b0 12 c8 ab 	call	#43976		;#0xabc8
int16_t V_History_break = 9999;

static __inline__ int per_sample_dsp(void)
{
	int kick = 0;
	voltage_sample_t V_sample = adc_v_buffer;
    c348:	91 42 26 04 	mov	&0x0426,2(r1)	;0x0426
    c34c:	02 00 
	voltage_sample_t V_corrected;
	current_sample_t I_sample;
	current_sample_t I_corrected = adc_i_buffer;
    c34e:	17 42 22 04 	mov	&0x0422,r7	;0x0422
    c352:	91 42 24 04 	mov	&0x0424,8(r1)	;0x0424
    c356:	08 00 
	struct phase_dot_prod_set_s* phase_dot_products;
	struct current_sensor_dot_prod_set_s *sensor_dot_products;
	int8_t loggers = 0;

	//Use the set of data that the frontend is NOT using
	dp = metrology.dp_set ^ 1;
    c358:	5c 42 0f 05 	mov.b	&0x050f,r12	;0x050f
    c35c:	5c e3       	xor.b	#1,	r12	;r3 As==01
    c35e:	44 4c       	mov.b	r12,	r4	;
    c360:	84 11       	sxt	r4		;
	phase_dot_products = &metrology.dot_prod[dp];
	sensor_dot_products = &metrology.current.dot_prod[dp];

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
    c362:	0a 44       	mov	r4,	r10	;
    c364:	0a 54       	add	r4,	r10	;
    c366:	0a 5a       	rla	r10		;
    c368:	0a 54       	add	r4,	r10	;
    c36a:	0a 5a       	rla	r10		;
    c36c:	3a 50 18 00 	add	#24,	r10	;#0x0018
    c370:	3a 50 88 04 	add	#1160,	r10	;#0x0488
    c374:	19 41 02 00 	mov	2(r1),	r9	;
    c378:	09 93       	cmp	#0,	r9	;r3 As==00
    c37a:	03 34       	jge	$+8      	;abs 0xc382
    c37c:	0c 43       	clr	r12		;
    c37e:	0c 89       	sub	r9,	r12	;
    c380:	09 4c       	mov	r12,	r9	;
//x and accumulate in z
static __inline__ void sqac48_16_mpy(register uint64_t* z, register int16_t x)// __attribute__((always_inline))
{
	if(x < 0) x = -x;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, x);
    c382:	81 49 04 00 	mov	r9,	4(r1)	;
    c386:	4c 43       	clr.b	r12		;
    c388:	0d 49       	mov	r9,	r13	;
    c38a:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(x);
    c38e:	0c 49       	mov	r9,	r12	;
    c390:	b0 12 50 ad 	call	#44368		;#0xad50

	*z += MPY_getResult();
    c394:	b0 12 56 ad 	call	#44374		;#0xad56
    c398:	29 4a       	mov	@r10,	r9	;
    c39a:	16 4a 02 00 	mov	2(r10),	r6	;
    c39e:	1e 4a 04 00 	mov	4(r10),	r14	;
    c3a2:	18 4a 06 00 	mov	6(r10),	r8	;
    c3a6:	0c 59       	add	r9,	r12	;
    c3a8:	1f 43       	mov	#1,	r15	;r3 As==01
    c3aa:	0c 99       	cmp	r9,	r12	;
    c3ac:	01 28       	jnc	$+4      	;abs 0xc3b0
    c3ae:	0f 43       	clr	r15		;
    c3b0:	0d 56       	add	r6,	r13	;
    c3b2:	19 43       	mov	#1,	r9	;r3 As==01
    c3b4:	0d 96       	cmp	r6,	r13	;
    c3b6:	01 28       	jnc	$+4      	;abs 0xc3ba
    c3b8:	09 43       	clr	r9		;
    c3ba:	0f 5d       	add	r13,	r15	;
    c3bc:	16 43       	mov	#1,	r6	;r3 As==01
    c3be:	0f 9d       	cmp	r13,	r15	;
    c3c0:	01 28       	jnc	$+4      	;abs 0xc3c4
    c3c2:	06 43       	clr	r6		;
    c3c4:	09 d6       	bis	r6,	r9	;
    c3c6:	06 4e       	mov	r14,	r6	;
    c3c8:	1d 43       	mov	#1,	r13	;r3 As==01
    c3ca:	0e 9e       	cmp	r14,	r14	;
    c3cc:	01 28       	jnc	$+4      	;abs 0xc3d0
    c3ce:	0d 43       	clr	r13		;
    c3d0:	0e 59       	add	r9,	r14	;
    c3d2:	19 43       	mov	#1,	r9	;r3 As==01
    c3d4:	0e 96       	cmp	r6,	r14	;
    c3d6:	01 28       	jnc	$+4      	;abs 0xc3da
    c3d8:	09 43       	clr	r9		;
    c3da:	0d d9       	bis	r9,	r13	;
    c3dc:	8a 4c 00 00 	mov	r12,	0(r10)	;
    c3e0:	8a 4f 02 00 	mov	r15,	2(r10)	;
    c3e4:	8a 4e 04 00 	mov	r14,	4(r10)	;
    c3e8:	0d 58       	add	r8,	r13	;
    c3ea:	8a 4d 06 00 	mov	r13,	6(r10)	;
	sensor_dot_products = &metrology.current.dot_prod[dp];

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
    c3ee:	0c 44       	mov	r4,	r12	;
    c3f0:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    c3f4:	b0 12 14 d3 	call	#54036		;#0xd314
    c3f8:	3c 50 4a 00 	add	#74,	r12	;#0x004a
    c3fc:	0a 4c       	mov	r12,	r10	;
    c3fe:	3a 50 88 04 	add	#1160,	r10	;#0x0488
    c402:	08 47       	mov	r7,	r8	;
    c404:	19 41 08 00 	mov	8(r1),	r9	;
    c408:	09 93       	cmp	#0,	r9	;r3 As==00
    c40a:	08 34       	jge	$+18     	;abs 0xc41c
    c40c:	0c 43       	clr	r12		;
    c40e:	0d 43       	clr	r13		;
    c410:	0e 4c       	mov	r12,	r14	;
    c412:	0f 4d       	mov	r13,	r15	;
    c414:	0e 88       	sub	r8,	r14	;
    c416:	0f 79       	subc	r9,	r15	;
    c418:	08 4e       	mov	r14,	r8	;
    c41a:	09 4f       	mov	r15,	r9	;
    c41c:	0d 49       	mov	r9,	r13	;
	uint32_t sum;

	if(x < 0) x = -x;

	/* Simplified multiplication */
	oplo = x;
    c41e:	81 48 06 00 	mov	r8,	6(r1)	;
	ophi = x >> 16;
    c422:	0c 48       	mov	r8,	r12	;
    c424:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    c428:	b0 12 5a d2 	call	#53850		;#0xd25a
    c42c:	07 4c       	mov	r12,	r7	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    c42e:	4c 43       	clr.b	r12		;
    c430:	0d 48       	mov	r8,	r13	;
    c432:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(oplo);
    c436:	0c 48       	mov	r8,	r12	;
    c438:	b0 12 50 ad 	call	#44368		;#0xad50
	*z += MPY_getResult();
    c43c:	b0 12 56 ad 	call	#44374		;#0xad56
    c440:	29 4a       	mov	@r10,	r9	;
    c442:	16 4a 02 00 	mov	2(r10),	r6	;
    c446:	1e 4a 04 00 	mov	4(r10),	r14	;
    c44a:	18 4a 06 00 	mov	6(r10),	r8	;
    c44e:	0c 59       	add	r9,	r12	;
    c450:	1f 43       	mov	#1,	r15	;r3 As==01
    c452:	0c 99       	cmp	r9,	r12	;
    c454:	01 28       	jnc	$+4      	;abs 0xc458
    c456:	0f 43       	clr	r15		;
    c458:	0d 56       	add	r6,	r13	;
    c45a:	19 43       	mov	#1,	r9	;r3 As==01
    c45c:	0d 96       	cmp	r6,	r13	;
    c45e:	01 28       	jnc	$+4      	;abs 0xc462
    c460:	09 43       	clr	r9		;
    c462:	0f 5d       	add	r13,	r15	;
    c464:	16 43       	mov	#1,	r6	;r3 As==01
    c466:	0f 9d       	cmp	r13,	r15	;
    c468:	01 28       	jnc	$+4      	;abs 0xc46c
    c46a:	06 43       	clr	r6		;
    c46c:	09 d6       	bis	r6,	r9	;
    c46e:	06 4e       	mov	r14,	r6	;
    c470:	1d 43       	mov	#1,	r13	;r3 As==01
    c472:	0e 9e       	cmp	r14,	r14	;
    c474:	01 28       	jnc	$+4      	;abs 0xc478
    c476:	0d 43       	clr	r13		;
    c478:	0e 59       	add	r9,	r14	;
    c47a:	19 43       	mov	#1,	r9	;r3 As==01
    c47c:	0e 96       	cmp	r6,	r14	;
    c47e:	01 28       	jnc	$+4      	;abs 0xc482
    c480:	09 43       	clr	r9		;
    c482:	0d d9       	bis	r9,	r13	;
    c484:	8a 4c 00 00 	mov	r12,	0(r10)	;
    c488:	8a 4f 02 00 	mov	r15,	2(r10)	;
    c48c:	8a 4e 04 00 	mov	r14,	4(r10)	;
    c490:	0d 58       	add	r8,	r13	;
    c492:	8a 4d 06 00 	mov	r13,	6(r10)	;

	MPY_setOperandTwo16Bit(ophi);
    c496:	0c 47       	mov	r7,	r12	;
    c498:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    c49c:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 16;
    c4a0:	0f 43       	clr	r15		;
    c4a2:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    c4a6:	00 00 
    c4a8:	0e 4f       	mov	r15,	r14	;
    c4aa:	b0 12 14 cd 	call	#52500		;#0xcd14
    c4ae:	0b 4d       	mov	r13,	r11	;
    c4b0:	05 4e       	mov	r14,	r5	;
    c4b2:	06 4c       	mov	r12,	r6	;
    c4b4:	06 5c       	add	r12,	r6	;
    c4b6:	18 43       	mov	#1,	r8	;r3 As==01
    c4b8:	06 9c       	cmp	r12,	r6	;
    c4ba:	01 28       	jnc	$+4      	;abs 0xc4be
    c4bc:	08 43       	clr	r8		;
    c4be:	0d 5d       	rla	r13		;
    c4c0:	19 43       	mov	#1,	r9	;r3 As==01
    c4c2:	0d 9b       	cmp	r11,	r13	;
    c4c4:	01 28       	jnc	$+4      	;abs 0xc4c8
    c4c6:	09 43       	clr	r9		;
    c4c8:	08 5d       	add	r13,	r8	;
    c4ca:	1c 43       	mov	#1,	r12	;r3 As==01
    c4cc:	08 9d       	cmp	r13,	r8	;
    c4ce:	01 28       	jnc	$+4      	;abs 0xc4d2
    c4d0:	0c 43       	clr	r12		;
    c4d2:	09 dc       	bis	r12,	r9	;
    c4d4:	0e 5e       	rla	r14		;
    c4d6:	1c 43       	mov	#1,	r12	;r3 As==01
    c4d8:	0e 95       	cmp	r5,	r14	;
    c4da:	01 28       	jnc	$+4      	;abs 0xc4de
    c4dc:	0c 43       	clr	r12		;
    c4de:	09 5e       	add	r14,	r9	;
    c4e0:	1d 43       	mov	#1,	r13	;r3 As==01
    c4e2:	09 9e       	cmp	r14,	r9	;
    c4e4:	01 28       	jnc	$+4      	;abs 0xc4e8
    c4e6:	0d 43       	clr	r13		;
    c4e8:	0c dd       	bis	r13,	r12	;
    c4ea:	0f 5f       	rla	r15		;
    c4ec:	0f 5c       	add	r12,	r15	;
	*z += (uint64_t) sum << 16;
    c4ee:	25 4a       	mov	@r10,	r5	;
    c4f0:	1e 4a 02 00 	mov	2(r10),	r14	;
    c4f4:	1d 4a 04 00 	mov	4(r10),	r13	;
    c4f8:	1b 4a 06 00 	mov	6(r10),	r11	;
    c4fc:	06 55       	add	r5,	r6	;
    c4fe:	1c 43       	mov	#1,	r12	;r3 As==01
    c500:	06 95       	cmp	r5,	r6	;
    c502:	01 28       	jnc	$+4      	;abs 0xc506
    c504:	0c 43       	clr	r12		;
    c506:	08 5e       	add	r14,	r8	;
    c508:	15 43       	mov	#1,	r5	;r3 As==01
    c50a:	08 9e       	cmp	r14,	r8	;
    c50c:	01 28       	jnc	$+4      	;abs 0xc510
    c50e:	05 43       	clr	r5		;
    c510:	0c 58       	add	r8,	r12	;
    c512:	1e 43       	mov	#1,	r14	;r3 As==01
    c514:	0c 98       	cmp	r8,	r12	;
    c516:	01 28       	jnc	$+4      	;abs 0xc51a
    c518:	0e 43       	clr	r14		;
    c51a:	05 de       	bis	r14,	r5	;
    c51c:	09 5d       	add	r13,	r9	;
    c51e:	1e 43       	mov	#1,	r14	;r3 As==01
    c520:	09 9d       	cmp	r13,	r9	;
    c522:	01 28       	jnc	$+4      	;abs 0xc526
    c524:	0e 43       	clr	r14		;
    c526:	05 59       	add	r9,	r5	;
    c528:	1d 43       	mov	#1,	r13	;r3 As==01
    c52a:	05 99       	cmp	r9,	r5	;
    c52c:	01 28       	jnc	$+4      	;abs 0xc530
    c52e:	0d 43       	clr	r13		;
    c530:	0e dd       	bis	r13,	r14	;
    c532:	0f 5b       	add	r11,	r15	;
    c534:	8a 46 00 00 	mov	r6,	0(r10)	;
    c538:	8a 4c 02 00 	mov	r12,	2(r10)	;
    c53c:	8a 45 04 00 	mov	r5,	4(r10)	;
    c540:	0e 5f       	add	r15,	r14	;
    c542:	8a 4e 06 00 	mov	r14,	6(r10)	;

	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, ophi);
    c546:	4c 43       	clr.b	r12		;
    c548:	0d 47       	mov	r7,	r13	;
    c54a:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(ophi);
    c54e:	0c 47       	mov	r7,	r12	;
    c550:	b0 12 50 ad 	call	#44368		;#0xad50
	sum = MPY_getResult();
    c554:	b0 12 56 ad 	call	#44374		;#0xad56
	*z += (uint64_t) sum << 32;
    c558:	0f 43       	clr	r15		;
    c55a:	b1 40 20 00 	mov	#32,	0(r1)	;#0x0020
    c55e:	00 00 
    c560:	0e 4f       	mov	r15,	r14	;
    c562:	b0 12 14 cd 	call	#52500		;#0xcd14
    c566:	25 4a       	mov	@r10,	r5	;
    c568:	16 4a 02 00 	mov	2(r10),	r6	;
    c56c:	18 4a 04 00 	mov	4(r10),	r8	;
    c570:	1b 4a 06 00 	mov	6(r10),	r11	;
    c574:	0c 55       	add	r5,	r12	;
    c576:	19 43       	mov	#1,	r9	;r3 As==01
    c578:	0c 95       	cmp	r5,	r12	;
    c57a:	01 28       	jnc	$+4      	;abs 0xc57e
    c57c:	09 43       	clr	r9		;
    c57e:	0d 56       	add	r6,	r13	;
    c580:	15 43       	mov	#1,	r5	;r3 As==01
    c582:	0d 96       	cmp	r6,	r13	;
    c584:	01 28       	jnc	$+4      	;abs 0xc588
    c586:	05 43       	clr	r5		;
    c588:	09 5d       	add	r13,	r9	;
    c58a:	16 43       	mov	#1,	r6	;r3 As==01
    c58c:	09 9d       	cmp	r13,	r9	;
    c58e:	01 28       	jnc	$+4      	;abs 0xc592
    c590:	06 43       	clr	r6		;
    c592:	05 d6       	bis	r6,	r5	;
    c594:	0e 58       	add	r8,	r14	;
    c596:	1d 43       	mov	#1,	r13	;r3 As==01
    c598:	0e 98       	cmp	r8,	r14	;
    c59a:	01 28       	jnc	$+4      	;abs 0xc59e
    c59c:	0d 43       	clr	r13		;
    c59e:	05 5e       	add	r14,	r5	;
    c5a0:	18 43       	mov	#1,	r8	;r3 As==01
    c5a2:	05 9e       	cmp	r14,	r5	;
    c5a4:	01 28       	jnc	$+4      	;abs 0xc5a8
    c5a6:	08 43       	clr	r8		;
    c5a8:	0d d8       	bis	r8,	r13	;
    c5aa:	0f 5b       	add	r11,	r15	;
    c5ac:	8a 4c 00 00 	mov	r12,	0(r10)	;
    c5b0:	8a 49 02 00 	mov	r9,	2(r10)	;
    c5b4:	8a 45 04 00 	mov	r5,	4(r10)	;
    c5b8:	0d 5f       	add	r15,	r13	;
    c5ba:	8a 4d 06 00 	mov	r13,	6(r10)	;

	V_corrected = V_sample;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
	mac64_16_24_mpy(sensor_dot_products->P_active, V_sample, I_sample);
    c5be:	0c 44       	mov	r4,	r12	;
    c5c0:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    c5c4:	b0 12 14 d3 	call	#54036		;#0xd314
    c5c8:	3c 50 3a 00 	add	#58,	r12	;#0x003a
    c5cc:	05 4c       	mov	r12,	r5	;
    c5ce:	35 50 88 04 	add	#1160,	r5	;#0x0488
	if(y < 0) y = -y;

	oplo = x;
	ophi = y >> 16;
	//MSB
	MPY_setOperandOne16Bit(MPY_MULTIPLY_UNSIGNED, oplo);
    c5d2:	4c 43       	clr.b	r12		;
    c5d4:	1d 41 04 00 	mov	4(r1),	r13	;
    c5d8:	b0 12 40 ad 	call	#44352		;#0xad40
	MPY_setOperandTwo16Bit(ophi);
    c5dc:	36 40 50 ad 	mov	#44368,	r6	;#0xad50
    c5e0:	0c 47       	mov	r7,	r12	;
    c5e2:	86 12       	call	r6		;
	result = (uint64_t)MPY_getResult() << 16;
    c5e4:	37 40 56 ad 	mov	#44374,	r7	;#0xad56
    c5e8:	87 12       	call	r7		;
    c5ea:	0f 43       	clr	r15		;
    c5ec:	3a 40 14 cd 	mov	#52500,	r10	;#0xcd14
    c5f0:	b1 40 10 00 	mov	#16,	0(r1)	;#0x0010
    c5f4:	00 00 
    c5f6:	0e 4f       	mov	r15,	r14	;
    c5f8:	8a 12       	call	r10		;
	result <<= 16;
    c5fa:	8a 12       	call	r10		;
    c5fc:	08 4c       	mov	r12,	r8	;
    c5fe:	09 4d       	mov	r13,	r9	;
    c600:	0a 4e       	mov	r14,	r10	;
    c602:	81 4f 04 00 	mov	r15,	4(r1)	;
    c606:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a
    c60a:	81 4e 0c 00 	mov	r14,	12(r1)	; 0x000c

	//LSB
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
    c60e:	1c 41 06 00 	mov	6(r1),	r12	;
    c612:	86 12       	call	r6		;
	result += MPY_getResult();
    c614:	87 12       	call	r7		;
    c616:	07 48       	mov	r8,	r7	;
    c618:	07 5c       	add	r12,	r7	;
    c61a:	1c 43       	mov	#1,	r12	;r3 As==01
    c61c:	07 98       	cmp	r8,	r7	;
    c61e:	01 28       	jnc	$+4      	;abs 0xc622
    c620:	0c 43       	clr	r12		;
    c622:	0d 59       	add	r9,	r13	;
    c624:	19 43       	mov	#1,	r9	;r3 As==01
    c626:	1d 91 0a 00 	cmp	10(r1),	r13	;0x0000a
    c62a:	01 28       	jnc	$+4      	;abs 0xc62e
    c62c:	09 43       	clr	r9		;
    c62e:	08 4c       	mov	r12,	r8	;
    c630:	08 5d       	add	r13,	r8	;
    c632:	1c 43       	mov	#1,	r12	;r3 As==01
    c634:	08 9d       	cmp	r13,	r8	;
    c636:	01 28       	jnc	$+4      	;abs 0xc63a
    c638:	0c 43       	clr	r12		;
    c63a:	09 dc       	bis	r12,	r9	;
    c63c:	1d 43       	mov	#1,	r13	;r3 As==01
    c63e:	1a 91 0c 00 	cmp	12(r1),	r10	;0x0000c
    c642:	01 28       	jnc	$+4      	;abs 0xc646
    c644:	0d 43       	clr	r13		;
    c646:	09 5a       	add	r10,	r9	;
    c648:	1c 43       	mov	#1,	r12	;r3 As==01
    c64a:	09 9a       	cmp	r10,	r9	;
    c64c:	01 28       	jnc	$+4      	;abs 0xc650
    c64e:	0c 43       	clr	r12		;
    c650:	0d dc       	bis	r12,	r13	;
    c652:	1d 51 04 00 	add	4(r1),	r13	;
    c656:	81 4d 04 00 	mov	r13,	4(r1)	;
    c65a:	81 48 0c 00 	mov	r8,	12(r1)	; 0x000c

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    c65e:	2a 45       	mov	@r5,	r10	;
    c660:	91 45 02 00 	mov	2(r5),	6(r1)	;
    c664:	06 00 
    c666:	16 45 04 00 	mov	4(r5),	r6	;
    c66a:	91 45 06 00 	mov	6(r5),	10(r1)	; 0x000a
    c66e:	0a 00 
	sum = MPY_getResult();
	*z += (uint64_t) sum << 32;
}

static __inline__ void mac64_16_24_mpy(register int64_t *z, register int16_t x, register int32_t y){
	int sign = (x ^ y) < 0;	// 0 = positive, 1 = negative
    c670:	1f 41 02 00 	mov	2(r1),	r15	;
    c674:	0c 4f       	mov	r15,	r12	;
    c676:	3c b0 00 80 	bit	#32768,	r12	;#0x8000
    c67a:	0d 7d       	subc	r13,	r13	;
    c67c:	3d e3       	inv	r13		;
    c67e:	1c 41 08 00 	mov	8(r1),	r12	;
    c682:	0c ed       	xor	r13,	r12	;
    c684:	b0 12 60 d2 	call	#53856		;#0xd260
	ophi = y;
	MPY_setOperandTwo16Bit(ophi);
	result += MPY_getResult();

	//Apply sign to result
	*z += sign > 0 ? -result : result;
    c688:	0d 43       	clr	r13		;
    c68a:	0d 9c       	cmp	r12,	r13	;
    c68c:	27 34       	jge	$+80     	;abs 0xc6dc
    c68e:	0b 4d       	mov	r13,	r11	;
    c690:	0c 4d       	mov	r13,	r12	;
    c692:	0c 87       	sub	r7,	r12	;
    c694:	1f 43       	mov	#1,	r15	;r3 As==01
    c696:	0c 9d       	cmp	r13,	r12	;
    c698:	01 20       	jnz	$+4      	;abs 0xc69c
    c69a:	0f 4d       	mov	r13,	r15	;
    c69c:	0e 4d       	mov	r13,	r14	;
    c69e:	1e 81 0c 00 	sub	12(r1),	r14	;0x0000c
    c6a2:	17 43       	mov	#1,	r7	;r3 As==01
    c6a4:	0d 9e       	cmp	r14,	r13	;
    c6a6:	01 28       	jnc	$+4      	;abs 0xc6aa
    c6a8:	07 43       	clr	r7		;
    c6aa:	08 4e       	mov	r14,	r8	;
    c6ac:	08 8f       	sub	r15,	r8	;
    c6ae:	1f 43       	mov	#1,	r15	;r3 As==01
    c6b0:	0e 98       	cmp	r8,	r14	;
    c6b2:	01 28       	jnc	$+4      	;abs 0xc6b6
    c6b4:	0f 43       	clr	r15		;
    c6b6:	07 df       	bis	r15,	r7	;
    c6b8:	0e 4d       	mov	r13,	r14	;
    c6ba:	0e 89       	sub	r9,	r14	;
    c6bc:	1f 43       	mov	#1,	r15	;r3 As==01
    c6be:	0b 9e       	cmp	r14,	r11	;
    c6c0:	01 28       	jnc	$+4      	;abs 0xc6c4
    c6c2:	0f 43       	clr	r15		;
    c6c4:	09 4e       	mov	r14,	r9	;
    c6c6:	09 87       	sub	r7,	r9	;
    c6c8:	17 43       	mov	#1,	r7	;r3 As==01
    c6ca:	0e 99       	cmp	r9,	r14	;
    c6cc:	01 28       	jnc	$+4      	;abs 0xc6d0
    c6ce:	07 43       	clr	r7		;
    c6d0:	0f d7       	bis	r7,	r15	;
    c6d2:	1d 81 04 00 	sub	4(r1),	r13	;
    c6d6:	0d 8f       	sub	r15,	r13	;
    c6d8:	30 40 e2 c6 	br	#0xc6e2		;
    c6dc:	0c 47       	mov	r7,	r12	;
    c6de:	1d 41 04 00 	mov	4(r1),	r13	;
    c6e2:	0c 5a       	add	r10,	r12	;
    c6e4:	1e 43       	mov	#1,	r14	;r3 As==01
    c6e6:	0c 9a       	cmp	r10,	r12	;
    c6e8:	01 28       	jnc	$+4      	;abs 0xc6ec
    c6ea:	0e 43       	clr	r14		;
    c6ec:	18 51 06 00 	add	6(r1),	r8	;
    c6f0:	1f 43       	mov	#1,	r15	;r3 As==01
    c6f2:	18 91 06 00 	cmp	6(r1),	r8	;
    c6f6:	01 28       	jnc	$+4      	;abs 0xc6fa
    c6f8:	0f 43       	clr	r15		;
    c6fa:	0e 58       	add	r8,	r14	;
    c6fc:	1a 43       	mov	#1,	r10	;r3 As==01
    c6fe:	0e 98       	cmp	r8,	r14	;
    c700:	01 28       	jnc	$+4      	;abs 0xc704
    c702:	0a 43       	clr	r10		;
    c704:	0f da       	bis	r10,	r15	;
    c706:	09 56       	add	r6,	r9	;
    c708:	1a 43       	mov	#1,	r10	;r3 As==01
    c70a:	09 96       	cmp	r6,	r9	;
    c70c:	01 28       	jnc	$+4      	;abs 0xc710
    c70e:	0a 43       	clr	r10		;
    c710:	0f 59       	add	r9,	r15	;
    c712:	18 43       	mov	#1,	r8	;r3 As==01
    c714:	0f 99       	cmp	r9,	r15	;
    c716:	01 28       	jnc	$+4      	;abs 0xc71a
    c718:	08 43       	clr	r8		;
    c71a:	0a d8       	bis	r8,	r10	;
    c71c:	1d 51 0a 00 	add	10(r1),	r13	;0x0000a
    c720:	85 4c 00 00 	mov	r12,	0(r5)	;
    c724:	85 4e 02 00 	mov	r14,	2(r5)	;
    c728:	85 4f 04 00 	mov	r15,	4(r5)	;
    c72c:	0a 5d       	add	r13,	r10	;
    c72e:	85 4a 06 00 	mov	r10,	6(r5)	;
	I_sample = I_corrected;
	sqac48_16_mpy(phase_dot_products->V_sq, V_sample);	//Accumulate the square product
	sqac64_24_mpy(sensor_dot_products->I_sq, I_sample);
	mac64_16_24_mpy(sensor_dot_products->P_active, V_sample, I_sample);

	phase_dot_products->sample_count++;
    c732:	39 40 88 04 	mov	#1160,	r9	;#0x0488
    c736:	0c 44       	mov	r4,	r12	;
    c738:	0c 54       	add	r4,	r12	;
    c73a:	0c 5c       	rla	r12		;
    c73c:	0c 54       	add	r4,	r12	;
    c73e:	0c 5c       	rla	r12		;
    c740:	0c 59       	add	r9,	r12	;
    c742:	9c 53 20 00 	inc	32(r12)		;
	sensor_dot_products->sample_count++;
    c746:	38 40 14 d3 	mov	#54036,	r8	;#0xd314
    c74a:	0c 44       	mov	r4,	r12	;
    c74c:	3d 40 1a 00 	mov	#26,	r13	;#0x001a
    c750:	88 12       	call	r8		;
    c752:	0c 59       	add	r9,	r12	;
    c754:	0a 4c       	mov	r12,	r10	;
    c756:	3a 50 52 00 	add	#82,	r10	;#0x0052
    c75a:	9a 53 00 00 	inc	0(r10)		;




    //metrology.V_history_index = (metrology.V_history_index + 1) & V_HISTORY_MASK;
    metrology.voltage_period.cycle_samples += 256;
    c75e:	17 49 7c 00 	mov	124(r9),r7	;0x0007c
    c762:	0a 47       	mov	r7,	r10	;
    c764:	3a 50 00 01 	add	#256,	r10	;#0x0100
    c768:	89 4a 7c 00 	mov	r10,	124(r9)	; 0x007c
	if (abs32(V_corrected - metrology.last_V_sample) <= metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
    c76c:	16 41 02 00 	mov	2(r1),	r6	;
    c770:	16 89 84 00 	sub	132(r9),r6	;0x00084
    c774:	08 46       	mov	r6,	r8	;
    c776:	38 b0 00 80 	bit	#32768,	r8	;#0x8000
    c77a:	09 79       	subc	r9,	r9	;
    c77c:	39 e3       	inv	r9		;
	status |= PHASE_STATUS_NEW_LOG;
}

static __inline__ int32_t abs32(int32_t x)
{
    return (x < 0)  ?  -x  :  x;
    c77e:	09 93       	cmp	#0,	r9	;r3 As==00
    c780:	08 34       	jge	$+18     	;abs 0xc792
    c782:	0c 43       	clr	r12		;
    c784:	0d 43       	clr	r13		;
    c786:	0e 4c       	mov	r12,	r14	;
    c788:	0f 4d       	mov	r13,	r15	;
    c78a:	0e 88       	sub	r8,	r14	;
    c78c:	0f 79       	subc	r9,	r15	;
    c78e:	08 4e       	mov	r14,	r8	;
    c790:	09 4f       	mov	r15,	r9	;



    //metrology.V_history_index = (metrology.V_history_index + 1) & V_HISTORY_MASK;
    metrology.voltage_period.cycle_samples += 256;
	if (abs32(V_corrected - metrology.last_V_sample) <= metrology.since_last*MAX_PER_SAMPLE_VOLTAGE_SLEW)
    c792:	1c 42 0a 05 	mov	&0x050a,r12	;0x050a
    c796:	3d 40 a0 0f 	mov	#4000,	r13	;#0x0fa0
    c79a:	b0 12 14 d3 	call	#54036		;#0xd314
    c79e:	0e 4c       	mov	r12,	r14	;
    c7a0:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    c7a4:	0f 7f       	subc	r15,	r15	;
    c7a6:	3f e3       	inv	r15		;
    c7a8:	0f 99       	cmp	r9,	r15	;
    c7aa:	aa 38       	jl	$+342    	;abs 0xc900
    c7ac:	09 9f       	cmp	r15,	r9	;
    c7ae:	02 20       	jnz	$+6      	;abs 0xc7b4
    c7b0:	0c 98       	cmp	r8,	r12	;
    c7b2:	a6 28       	jnc	$+334    	;abs 0xc900
	{
		/* This doesn't look like a spike - do mains cycle detection, and
           estimate the precise mains period */
		if(V_corrected < 0){
    c7b4:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    c7b8:	05 34       	jge	$+12     	;abs 0xc7c4
			/* We just crossed from positive to negative */
			/* Log the sign of the signal */
			status &= ~PHASE_STATUS_V_POS;
    c7ba:	a2 c3 10 05 	bic	#2,	&0x0510	;r3 As==10
	current_sample_t I_corrected = adc_i_buffer;
    int x, y, z, k;
    int dp;
	struct phase_dot_prod_set_s* phase_dot_products;
	struct current_sensor_dot_prod_set_s *sensor_dot_products;
	int8_t loggers = 0;
    c7be:	0e 43       	clr	r14		;
    c7c0:	30 40 b6 c8 	br	#0xc8b6		;
			/* Log the sign of the signal */
			status &= ~PHASE_STATUS_V_POS;
		}
		else{
			/* We just crossed from negative to positive */
			if (!(status & PHASE_STATUS_V_POS))
    c7c4:	e2 b3 10 05 	bit.b	#2,	&0x0510	;r3 As==10
    c7c8:	73 20       	jnz	$+232    	;abs 0xc8b0
			{
				V_History_break = V_History_SampleCount + 24;
    c7ca:	1f 42 0a 02 	mov	&0x020a,r15	;0x020a
    c7ce:	3f 50 18 00 	add	#24,	r15	;#0x0018
    c7d2:	82 4f 08 02 	mov	r15,	&0x0208	;
				/* The mains should be <40Hz or >70Hz to fail this test! */
				if (256*SAMPLES_PER_10_SECONDS/700 <= metrology.voltage_period.cycle_samples
						&&
    c7d6:	37 50 dc c7 	add	#51164,	r7	;#0xc7dc
			/* We just crossed from negative to positive */
			if (!(status & PHASE_STATUS_V_POS))
			{
				V_History_break = V_History_SampleCount + 24;
				/* The mains should be <40Hz or >70Hz to fail this test! */
				if (256*SAMPLES_PER_10_SECONDS/700 <= metrology.voltage_period.cycle_samples
    c7da:	3c 40 dc 2a 	mov	#10972,	r12	;#0x2adc
    c7de:	0c 97       	cmp	r7,	r12	;
    c7e0:	55 28       	jnc	$+172    	;abs 0xc88c
    c7e2:	3c 42       	mov	#8,	r12	;r2 As==11
    c7e4:	0e 43       	clr	r14		;
    c7e6:	07 4e       	mov	r14,	r7	;
    c7e8:	1f 41 02 00 	mov	2(r1),	r15	;
					//z = V_corrected - last_V_sample;
					x = 0;
					y = 0;
					for (k = 0;  k < 8;  k++)
					{
						y <<= 1;
    c7ec:	07 57       	rla	r7		;
						z >>= 1;
    c7ee:	06 11       	rra	r6		;
						x += z;
    c7f0:	0d 46       	mov	r6,	r13	;
    c7f2:	0d 5e       	add	r14,	r13	;
						if (x > V_corrected)
    c7f4:	0f 9d       	cmp	r13,	r15	;
    c7f6:	02 38       	jl	$+6      	;abs 0xc7fc
						//if (x > V_corrected)
							x -= z;
						else
							y |= 1;
    c7f8:	17 d3       	bis	#1,	r7	;r3 As==01
					y = 0;
					for (k = 0;  k < 8;  k++)
					{
						y <<= 1;
						z >>= 1;
						x += z;
    c7fa:	0e 4d       	mov	r13,	r14	;
    c7fc:	3c 53       	add	#-1,	r12	;r3 As==11
					/* Interpolate the zero crossing by successive approx. Its faster than just dividing. */
					z = V_corrected - metrology.last_V_sample;
					//z = V_corrected - last_V_sample;
					x = 0;
					y = 0;
					for (k = 0;  k < 8;  k++)
    c7fe:	0c 93       	cmp	#0,	r12	;r3 As==00
    c800:	f5 23       	jnz	$-20     	;abs 0xc7ec
    c802:	0c 47       	mov	r7,	r12	;
						else
							y |= 1;
					}
					/* Now we need to allow for skipped samples, due to spike detection */
					z = y;
					while (metrology.since_last > 1)
    c804:	1d 42 0a 05 	mov	&0x050a,r13	;0x050a
    c808:	1e 43       	mov	#1,	r14	;r3 As==01
    c80a:	0e 9d       	cmp	r13,	r14	;
    c80c:	0b 34       	jge	$+24     	;abs 0xc824
    c80e:	0e 4d       	mov	r13,	r14	;
					{
						z += y;
						metrology.since_last--;
    c810:	3e 53       	add	#-1,	r14	;r3 As==11
						else
							y |= 1;
					}
					/* Now we need to allow for skipped samples, due to spike detection */
					z = y;
					while (metrology.since_last > 1)
    c812:	1e 93       	cmp	#1,	r14	;r3 As==01
    c814:	fd 23       	jnz	$-4      	;abs 0xc810
    c816:	07 4c       	mov	r12,	r7	;
    c818:	07 5c       	add	r12,	r7	;
    c81a:	3d 50 fe ff 	add	#65534,	r13	;#0xfffe
    c81e:	b0 12 14 d3 	call	#54036		;#0xd314
    c822:	07 5c       	add	r12,	r7	;
					}
					/* z is now the fraction of a sample interval between the zero
            		   crossing and the current sample, in units of 1/256 of a sample */
				    /* A lightly damped single pole filter should now be enough to remove noise and get a
				       stable value for the frequency */
					metrology.voltage_period.period += ((int32_t) (metrology.voltage_period.cycle_samples - z) << 12) - (metrology.voltage_period.period >> 4);
    c824:	36 40 88 04 	mov	#1160,	r6	;#0x0488
    c828:	18 46 7e 00 	mov	126(r6),r8	;0x0007e
    c82c:	19 46 80 00 	mov	128(r6),r9	;0x00080
    c830:	0c 48       	mov	r8,	r12	;
    c832:	0d 49       	mov	r9,	r13	;
    c834:	b0 12 ec d2 	call	#53996		;#0xd2ec
    c838:	08 8c       	sub	r12,	r8	;
    c83a:	09 7d       	subc	r13,	r9	;
    c83c:	0d 43       	clr	r13		;
    c83e:	0e 4d       	mov	r13,	r14	;
    c840:	0d 4a       	mov	r10,	r13	;
    c842:	0d 87       	sub	r7,	r13	;
    c844:	0c 4d       	mov	r13,	r12	;
    c846:	0c 5d       	add	r13,	r12	;
    c848:	0d 4e       	mov	r14,	r13	;
    c84a:	0d 6e       	addc	r14,	r13	;
    c84c:	0c 5c       	rla	r12		;
    c84e:	0d 6d       	rlc	r13		;
    c850:	0c 5c       	rla	r12		;
    c852:	0d 6d       	rlc	r13		;
    c854:	0c 5c       	rla	r12		;
    c856:	0d 6d       	rlc	r13		;
    c858:	0c 5c       	rla	r12		;
    c85a:	0d 6d       	rlc	r13		;
    c85c:	0c 5c       	rla	r12		;
    c85e:	0d 6d       	rlc	r13		;
    c860:	0c 5c       	rla	r12		;
    c862:	0d 6d       	rlc	r13		;
    c864:	0c 5c       	rla	r12		;
    c866:	0d 6d       	rlc	r13		;
    c868:	0c 5c       	rla	r12		;
    c86a:	0d 6d       	rlc	r13		;
    c86c:	0c 5c       	rla	r12		;
    c86e:	0d 6d       	rlc	r13		;
    c870:	0c 5c       	rla	r12		;
    c872:	0d 6d       	rlc	r13		;
    c874:	0c 5c       	rla	r12		;
    c876:	0d 6d       	rlc	r13		;
    c878:	0c 58       	add	r8,	r12	;
    c87a:	86 4c 7e 00 	mov	r12,	126(r6)	; 0x007e
    c87e:	0d 69       	addc	r9,	r13	;
    c880:	86 4d 80 00 	mov	r13,	128(r6)	; 0x0080
					/* Start the next cycle with the residual fraction of a sample */
					metrology.voltage_period.cycle_samples = z;
    c884:	86 47 7c 00 	mov	r7,	124(r6)	; 0x007c
    c888:	30 40 90 c8 	br	#0xc890		;
				}
				else
				{
					metrology.voltage_period.cycle_samples = 0;
    c88c:	82 43 04 05 	mov	#0,	&0x0504	;r3 As==00
				}

                if (phase_dot_products->sample_count >= samples_per_second)
    c890:	0c 44       	mov	r4,	r12	;
    c892:	0c 54       	add	r4,	r12	;
    c894:	0c 5c       	rla	r12		;
    c896:	0c 54       	add	r4,	r12	;
    c898:	0c 5c       	rla	r12		;
    c89a:	3c 50 88 04 	add	#1160,	r12	;#0x0488
    c89e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    c8a0:	9c 92 18 02 	cmp	&0x0218,32(r12)	;0x0218, 0x0020
    c8a4:	20 00 
    c8a6:	01 34       	jge	$+4      	;abs 0xc8aa
    c8a8:	4e 43       	clr.b	r14		;
	current_sample_t I_corrected = adc_i_buffer;
    int x, y, z, k;
    int dp;
	struct phase_dot_prod_set_s* phase_dot_products;
	struct current_sensor_dot_prod_set_s *sensor_dot_products;
	int8_t loggers = 0;
    c8aa:	8e 11       	sxt	r14		;
    c8ac:	30 40 b2 c8 	br	#0xc8b2		;
    c8b0:	0e 43       	clr	r14		;

                if (phase_dot_products->sample_count >= samples_per_second)
                    loggers |= 1;
			}
            /* Log the sign of the signal */
            status |= PHASE_STATUS_V_POS;
    c8b2:	a2 d3 10 05 	bis	#2,	&0x0510	;r3 As==10
		}
        metrology.since_last = 0;
    c8b6:	3d 40 88 04 	mov	#1160,	r13	;#0x0488
        metrology.last_V_sample = V_corrected;
    c8ba:	9d 41 02 00 	mov	2(r1),	132(r13); 0x0084
    c8be:	84 00 
	}
	metrology.since_last++;
    c8c0:	9d 43 82 00 	mov	#1,	130(r13);r3 As==01, 0x0082

    if (phase_dot_products->sample_count >= samples_per_second + 2*SAMPLE_RATE/MAINS_NOMINAL_FREQUENCY)
    c8c4:	0c 44       	mov	r4,	r12	;
    c8c6:	0c 54       	add	r4,	r12	;
    c8c8:	0c 5c       	rla	r12		;
    c8ca:	0c 54       	add	r4,	r12	;
    c8cc:	0c 5c       	rla	r12		;
    c8ce:	0c 5d       	add	r13,	r12	;
    c8d0:	1d 42 18 02 	mov	&0x0218,r13	;0x0218
    c8d4:	3d 50 a0 00 	add	#160,	r13	;#0x00a0
    c8d8:	8c 9d 20 00 	cmp	r13,	32(r12)	; 0x0020
    c8dc:	02 34       	jge	$+6      	;abs 0xc8e2
        /* We don't seem to be detecting the end of a mains cycle, so force
           the end of processing block condition. */
        loggers |= 1;
    }

    if (loggers)
    c8de:	0e 93       	cmp	#0,	r14	;r3 As==00
    c8e0:	21 24       	jz	$+68     	;abs 0xc924
}

static void __inline__ log_parameters(void){

	/* Tell the foreground there are things to process, and swap the dot product sets. */
	metrology.dp_set ^= 1;
    c8e2:	3c 40 88 04 	mov	#1160,	r12	;#0x0488
    c8e6:	dc e3 87 00 	xor.b	#1,	135(r12);r3 As==01, 0x0087
	status |= PHASE_STATUS_NEW_LOG;
    c8ea:	92 d3 10 05 	bis	#1,	&0x0510	;r3 As==01
		adc_i_buffer = ADC32_1();

		GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN2);
		if(per_sample_dsp()){
			//New samples ready for to be calculated
			_BIC_SR_IRQ(LPM0_bits);
    c8ee:	b1 c0 10 00 	bic	#16,	38(r1)	;#0x0010, 0x0026
    c8f2:	26 00 
			GPIO_toggleOutputOnPin(GPIO_PORT_P2, GPIO_PIN2);
    c8f4:	6c 43       	mov.b	#2,	r12	;r3 As==10
    c8f6:	2d 42       	mov	#4,	r13	;r2 As==10
    c8f8:	b0 12 14 ac 	call	#44052		;#0xac14
    c8fc:	30 40 24 c9 	br	#0xc924		;
            status |= PHASE_STATUS_V_POS;
		}
        metrology.since_last = 0;
        metrology.last_V_sample = V_corrected;
	}
	metrology.since_last++;
    c900:	3e 40 88 04 	mov	#1160,	r14	;#0x0488
    c904:	9e 53 82 00 	inc	130(r14)		;

    if (phase_dot_products->sample_count >= samples_per_second + 2*SAMPLE_RATE/MAINS_NOMINAL_FREQUENCY)
    c908:	0d 44       	mov	r4,	r13	;
    c90a:	0d 54       	add	r4,	r13	;
    c90c:	0d 5d       	rla	r13		;
    c90e:	0c 4d       	mov	r13,	r12	;
    c910:	0c 54       	add	r4,	r12	;
    c912:	0c 5c       	rla	r12		;
    c914:	0c 5e       	add	r14,	r12	;
    c916:	1d 42 18 02 	mov	&0x0218,r13	;0x0218
    c91a:	3d 50 a0 00 	add	#160,	r13	;#0x00a0
    c91e:	8c 9d 20 00 	cmp	r13,	32(r12)	; 0x0020
    c922:	df 37       	jge	$-64     	;abs 0xc8e2
		break;
	case SD24IV_SD24MEM2: break;
	case SD24IV_SD24MEM3: break;
	default: break;
	}
}
    c924:	31 50 0e 00 	add	#14,	r1	;#0x000e
    c928:	34 41       	pop	r4		;
    c92a:	35 41       	pop	r5		;
    c92c:	36 41       	pop	r6		;
    c92e:	37 41       	pop	r7		;
    c930:	38 41       	pop	r8		;
    c932:	39 41       	pop	r9		;
    c934:	3a 41       	pop	r10		;
    c936:	3b 41       	pop	r11		;
    c938:	3c 41       	pop	r12		;
    c93a:	3d 41       	pop	r13		;
    c93c:	3e 41       	pop	r14		;
    c93e:	3f 41       	pop	r15		;
    c940:	00 13       	reti			

0000c942 <xtoa>:
		100, // +7
		10, // +8
		1, // +9
		};

static void xtoa(unsigned long x, const unsigned long *dp) {
    c942:	0a 12       	push	r10		;
    c944:	09 12       	push	r9		;
    c946:	08 12       	push	r8		;
    c948:	07 12       	push	r7		;
    c94a:	06 12       	push	r6		;
    c94c:	05 12       	push	r5		;
    c94e:	04 12       	push	r4		;
    c950:	08 4c       	mov	r12,	r8	;
    c952:	09 4d       	mov	r13,	r9	;
	char c;
	unsigned long d;
	if (x) {
    c954:	0c dd       	bis	r13,	r12	;
    c956:	0c 93       	cmp	#0,	r12	;r3 As==00
    c958:	38 24       	jz	$+114    	;abs 0xc9ca
		while (x < *dp)
    c95a:	1d 9e 02 00 	cmp	2(r14),	r13	;
    c95e:	05 28       	jnc	$+12     	;abs 0xc96a
    c960:	8e 9d 02 00 	cmp	r13,	2(r14)	;
    c964:	0d 20       	jnz	$+28     	;abs 0xc980
    c966:	28 9e       	cmp	@r14,	r8	;
    c968:	0b 2c       	jc	$+24     	;abs 0xc980
    c96a:	0c 49       	mov	r9,	r12	;
    c96c:	0d 48       	mov	r8,	r13	;
			++dp;
    c96e:	2e 52       	add	#4,	r14	;r2 As==10

static void xtoa(unsigned long x, const unsigned long *dp) {
	char c;
	unsigned long d;
	if (x) {
		while (x < *dp)
    c970:	1c 9e 02 00 	cmp	2(r14),	r12	;
    c974:	fc 2b       	jnc	$-6      	;abs 0xc96e
    c976:	8e 99 02 00 	cmp	r9,	2(r14)	;
    c97a:	02 20       	jnz	$+6      	;abs 0xc980
    c97c:	2d 9e       	cmp	@r14,	r13	;
    c97e:	f7 2b       	jnc	$-16     	;abs 0xc96e
    c980:	0a 4e       	mov	r14,	r10	;
			++dp;
		do {
			d = *dp++;
			c = '0';
    c982:	34 40 30 00 	mov	#48,	r4	;#0x0030
			while (x >= d)
				++c, x -= d;
			putc(c);
    c986:	35 40 44 b4 	mov	#46148,	r5	;#0xb444
	unsigned long d;
	if (x) {
		while (x < *dp)
			++dp;
		do {
			d = *dp++;
    c98a:	26 4a       	mov	@r10,	r6	;
    c98c:	17 4a 02 00 	mov	2(r10),	r7	;
			c = '0';
			while (x >= d)
    c990:	09 97       	cmp	r7,	r9	;
    c992:	13 28       	jnc	$+40     	;abs 0xc9ba
    c994:	07 99       	cmp	r9,	r7	;
    c996:	02 20       	jnz	$+6      	;abs 0xc99c
    c998:	08 96       	cmp	r6,	r8	;
    c99a:	0f 28       	jnc	$+32     	;abs 0xc9ba
    c99c:	0c 44       	mov	r4,	r12	;
    c99e:	0e 47       	mov	r7,	r14	;
				++c, x -= d;
    c9a0:	5c 53       	inc.b	r12		;
    c9a2:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    c9a6:	08 86       	sub	r6,	r8	;
    c9a8:	09 77       	subc	r7,	r9	;
		while (x < *dp)
			++dp;
		do {
			d = *dp++;
			c = '0';
			while (x >= d)
    c9aa:	09 97       	cmp	r7,	r9	;
    c9ac:	07 28       	jnc	$+16     	;abs 0xc9bc
    c9ae:	0e 99       	cmp	r9,	r14	;
    c9b0:	f7 23       	jnz	$-16     	;abs 0xc9a0
    c9b2:	08 96       	cmp	r6,	r8	;
    c9b4:	f5 2f       	jc	$-20     	;abs 0xc9a0
    c9b6:	30 40 bc c9 	br	#0xc9bc		;
	if (x) {
		while (x < *dp)
			++dp;
		do {
			d = *dp++;
			c = '0';
    c9ba:	0c 44       	mov	r4,	r12	;
			while (x >= d)
				++c, x -= d;
			putc(c);
    c9bc:	85 12       	call	r5		;
    c9be:	2a 52       	add	#4,	r10	;r2 As==10
		} while (!(d & 1));
    c9c0:	16 f3       	and	#1,	r6	;r3 As==01
    c9c2:	06 93       	cmp	#0,	r6	;r3 As==00
    c9c4:	e2 27       	jz	$-58     	;abs 0xc98a
    c9c6:	30 40 d2 c9 	br	#0xc9d2		;
	} else
		putc('0');
    c9ca:	3c 40 30 00 	mov	#48,	r12	;#0x0030
    c9ce:	b0 12 44 b4 	call	#46148		;#0xb444
}
    c9d2:	30 40 68 d1 	br	#0xd168		;

0000c9d6 <puth>:

static void puth(unsigned n) {
	static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
			'9', 'A', 'B', 'C', 'D', 'E', 'F' };
	putc(hex[n & 15]);
    c9d6:	3c f0 0f 00 	and	#15,	r12	;#0x000f
    c9da:	5c 4c 1e 82 	mov.b	-32226(r12),r12	;0xffff821e
    c9de:	b0 12 44 b4 	call	#46148		;#0xb444
}
    c9e2:	30 41       	ret			

0000c9e4 <printf>:

void printf(char *format, ...)
{
    c9e4:	0a 12       	push	r10		;
    c9e6:	09 12       	push	r9		;
    c9e8:	08 12       	push	r8		;
    c9ea:	07 12       	push	r7		;
    c9ec:	06 12       	push	r6		;
    c9ee:	05 12       	push	r5		;
    c9f0:	17 41 0e 00 	mov	14(r1),	r7	;0x0000e
	char c;
	int i;
	long n;

	va_list a;
	va_start(a, format);
    c9f4:	09 41       	mov	r1,	r9	;
    c9f6:	39 50 10 00 	add	#16,	r9	;#0x0010
				break;
				case 0: return;
				default: goto bad_fmt;
			}
		} else
			bad_fmt: putc(c);
    c9fa:	38 40 44 b4 	mov	#46148,	r8	;#0xb444
				break;
				case 'i':// 16 bit Integer
				case 'u':// 16 bit Unsigned
					i = va_arg(a, int);
					if(c == 'i' && i < 0) i = -i, putc('-');
					xtoa((unsigned)i, dv + 5);
    c9fe:	35 40 42 82 	mov	#33346,	r5	;#0x8242
	int i;
	long n;

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
    ca02:	30 40 2c cb 	br	#0xcb2c		;
		if(c == '%') {
    ca06:	3c 90 25 00 	cmp	#37,	r12	;#0x0025
    ca0a:	8b 20       	jnz	$+280    	;abs 0xcb22
			switch(c = *format++) {
    ca0c:	0a 47       	mov	r7,	r10	;
    ca0e:	2a 53       	incd	r10		;
    ca10:	5c 47 01 00 	mov.b	1(r7),	r12	;
    ca14:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    ca18:	4c 24       	jz	$+154    	;abs 0xcab2
    ca1a:	7d 40 6c 00 	mov.b	#108,	r13	;#0x006c
    ca1e:	4d 9c       	cmp.b	r12,	r13	;
    ca20:	0a 28       	jnc	$+22     	;abs 0xca36
    ca22:	3c 90 63 00 	cmp	#99,	r12	;#0x0063
    ca26:	22 24       	jz	$+70     	;abs 0xca6c
    ca28:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    ca2c:	29 24       	jz	$+84     	;abs 0xca80
    ca2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    ca30:	80 24       	jz	$+258    	;abs 0xcb32
    ca32:	30 40 28 cb 	br	#0xcb28		;
    ca36:	3c 90 73 00 	cmp	#115,	r12	;#0x0073
    ca3a:	11 24       	jz	$+36     	;abs 0xca5e
    ca3c:	7d 40 73 00 	mov.b	#115,	r13	;#0x0073
    ca40:	4d 9c       	cmp.b	r12,	r13	;
    ca42:	05 28       	jnc	$+12     	;abs 0xca4e
    ca44:	3c 90 6e 00 	cmp	#110,	r12	;#0x006e
    ca48:	34 24       	jz	$+106    	;abs 0xcab2
    ca4a:	30 40 28 cb 	br	#0xcb28		;
    ca4e:	3c 90 75 00 	cmp	#117,	r12	;#0x0075
    ca52:	16 24       	jz	$+46     	;abs 0xca80
    ca54:	3c 90 78 00 	cmp	#120,	r12	;#0x0078
    ca58:	4b 24       	jz	$+152    	;abs 0xcaf0
    ca5a:	30 40 28 cb 	br	#0xcb28		;
				case 's': // String
					puts(va_arg(a, char*));
    ca5e:	2c 49       	mov	@r9,	r12	;
    ca60:	29 53       	incd	r9		;
    ca62:	b0 12 22 b4 	call	#46114		;#0xb422

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
		if(c == '%') {
			switch(c = *format++) {
    ca66:	07 4a       	mov	r10,	r7	;
				case 's': // String
					puts(va_arg(a, char*));
					break;
    ca68:	30 40 2c cb 	br	#0xcb2c		;
				case 'c':// Char
					putc((char)va_arg(a, int));
    ca6c:	19 53       	inc	r9		;
    ca6e:	0c 49       	mov	r9,	r12	;
    ca70:	1c c3       	bic	#1,	r12	;r3 As==01
    ca72:	09 4c       	mov	r12,	r9	;
    ca74:	29 53       	incd	r9		;
    ca76:	6c 4c       	mov.b	@r12,	r12	;
    ca78:	88 12       	call	r8		;

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
		if(c == '%') {
			switch(c = *format++) {
    ca7a:	07 4a       	mov	r10,	r7	;
				case 's': // String
					puts(va_arg(a, char*));
					break;
				case 'c':// Char
					putc((char)va_arg(a, int));
				break;
    ca7c:	30 40 2c cb 	br	#0xcb2c		;
				case 'i':// 16 bit Integer
				case 'u':// 16 bit Unsigned
					i = va_arg(a, int);
    ca80:	19 53       	inc	r9		;
    ca82:	0d 49       	mov	r9,	r13	;
    ca84:	1d c3       	bic	#1,	r13	;r3 As==01
    ca86:	09 4d       	mov	r13,	r9	;
    ca88:	29 53       	incd	r9		;
    ca8a:	27 4d       	mov	@r13,	r7	;
					if(c == 'i' && i < 0) i = -i, putc('-');
    ca8c:	3c 90 69 00 	cmp	#105,	r12	;#0x0069
    ca90:	08 20       	jnz	$+18     	;abs 0xcaa2
    ca92:	07 93       	cmp	#0,	r7	;r3 As==00
    ca94:	06 34       	jge	$+14     	;abs 0xcaa2
    ca96:	0c 43       	clr	r12		;
    ca98:	0c 87       	sub	r7,	r12	;
    ca9a:	07 4c       	mov	r12,	r7	;
    ca9c:	3c 40 2d 00 	mov	#45,	r12	;#0x002d
    caa0:	88 12       	call	r8		;
					xtoa((unsigned)i, dv + 5);
    caa2:	0c 47       	mov	r7,	r12	;
    caa4:	0d 43       	clr	r13		;
    caa6:	0e 45       	mov	r5,	r14	;
    caa8:	b0 12 42 c9 	call	#51522		;#0xc942

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
		if(c == '%') {
			switch(c = *format++) {
    caac:	07 4a       	mov	r10,	r7	;
				case 'i':// 16 bit Integer
				case 'u':// 16 bit Unsigned
					i = va_arg(a, int);
					if(c == 'i' && i < 0) i = -i, putc('-');
					xtoa((unsigned)i, dv + 5);
				break;
    caae:	30 40 2c cb 	br	#0xcb2c		;
				case 'l':// 32 bit Long
				case 'n':// 32 bit uNsigned loNg
					n = va_arg(a, long);
    cab2:	19 53       	inc	r9		;
    cab4:	0d 49       	mov	r9,	r13	;
    cab6:	1d c3       	bic	#1,	r13	;r3 As==01
    cab8:	09 4d       	mov	r13,	r9	;
    caba:	29 52       	add	#4,	r9	;r2 As==10
    cabc:	26 4d       	mov	@r13,	r6	;
    cabe:	17 4d 02 00 	mov	2(r13),	r7	;
					if(c == 'l' && n < 0) n = -n, putc('-');
    cac2:	3c 90 6c 00 	cmp	#108,	r12	;#0x006c
    cac6:	0b 20       	jnz	$+24     	;abs 0xcade
    cac8:	07 93       	cmp	#0,	r7	;r3 As==00
    caca:	09 34       	jge	$+20     	;abs 0xcade
    cacc:	0c 43       	clr	r12		;
    cace:	0d 43       	clr	r13		;
    cad0:	0c 86       	sub	r6,	r12	;
    cad2:	0d 77       	subc	r7,	r13	;
    cad4:	06 4c       	mov	r12,	r6	;
    cad6:	07 4d       	mov	r13,	r7	;
    cad8:	3c 40 2d 00 	mov	#45,	r12	;#0x002d
    cadc:	88 12       	call	r8		;
					xtoa((unsigned long)n, dv);
    cade:	0c 46       	mov	r6,	r12	;
    cae0:	0d 47       	mov	r7,	r13	;
    cae2:	3e 40 2e 82 	mov	#33326,	r14	;#0x822e
    cae6:	b0 12 42 c9 	call	#51522		;#0xc942

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
		if(c == '%') {
			switch(c = *format++) {
    caea:	07 4a       	mov	r10,	r7	;
				case 'l':// 32 bit Long
				case 'n':// 32 bit uNsigned loNg
					n = va_arg(a, long);
					if(c == 'l' && n < 0) n = -n, putc('-');
					xtoa((unsigned long)n, dv);
				break;
    caec:	30 40 2c cb 	br	#0xcb2c		;
				case 'x':// 16 bit heXadecimal
					i = va_arg(a, int);
    caf0:	19 53       	inc	r9		;
    caf2:	0c 49       	mov	r9,	r12	;
    caf4:	1c c3       	bic	#1,	r12	;r3 As==01
    caf6:	09 4c       	mov	r12,	r9	;
    caf8:	29 53       	incd	r9		;
    cafa:	26 4c       	mov	@r12,	r6	;
					puth(i >> 12);
    cafc:	0c 46       	mov	r6,	r12	;
    cafe:	b0 12 f2 d1 	call	#53746		;#0xd1f2
    cb02:	37 40 d6 c9 	mov	#51670,	r7	;#0xc9d6
    cb06:	87 12       	call	r7		;
					puth(i >> 8);
    cb08:	0c 46       	mov	r6,	r12	;
    cb0a:	b0 12 fa d1 	call	#53754		;#0xd1fa
    cb0e:	87 12       	call	r7		;
					puth(i >> 4);
    cb10:	0c 46       	mov	r6,	r12	;
    cb12:	b0 12 02 d2 	call	#53762		;#0xd202
    cb16:	87 12       	call	r7		;
					puth(i);
    cb18:	0c 46       	mov	r6,	r12	;
    cb1a:	87 12       	call	r7		;

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
		if(c == '%') {
			switch(c = *format++) {
    cb1c:	07 4a       	mov	r10,	r7	;
					i = va_arg(a, int);
					puth(i >> 12);
					puth(i >> 8);
					puth(i >> 4);
					puth(i);
				break;
    cb1e:	30 40 2c cb 	br	#0xcb2c		;
	int i;
	long n;

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
    cb22:	17 53       	inc	r7		;
    cb24:	30 40 2a cb 	br	#0xcb2a		;
		if(c == '%') {
			switch(c = *format++) {
    cb28:	07 4a       	mov	r10,	r7	;
				break;
				case 0: return;
				default: goto bad_fmt;
			}
		} else
			bad_fmt: putc(c);
    cb2a:	88 12       	call	r8		;
	int i;
	long n;

	va_list a;
	va_start(a, format);
	while((c = *format++)) {
    cb2c:	6c 47       	mov.b	@r7,	r12	;
    cb2e:	0c 93       	cmp	#0,	r12	;r3 As==00
    cb30:	6a 23       	jnz	$-298    	;abs 0xca06
			}
		} else
			bad_fmt: putc(c);
	}
	va_end(a);
}
    cb32:	30 40 6a d1 	br	#0xd16a		;

0000cb36 <__mspabi_mpyll>:
    cb36:	0a 12       	push	r10		;
    cb38:	09 12       	push	r9		;
    cb3a:	08 12       	push	r8		;
    cb3c:	07 12       	push	r7		;
    cb3e:	06 12       	push	r6		;
    cb40:	05 12       	push	r5		;
    cb42:	04 12       	push	r4		;
    cb44:	31 80 1e 00 	sub	#30,	r1	;#0x001e
    cb48:	81 49 0e 00 	mov	r9,	14(r1)	; 0x000e
    cb4c:	81 4a 16 00 	mov	r10,	22(r1)	; 0x0016
    cb50:	81 4b 18 00 	mov	r11,	24(r1)	; 0x0018
    cb54:	07 4c       	mov	r12,	r7	;
    cb56:	06 4d       	mov	r13,	r6	;
    cb58:	81 4e 1a 00 	mov	r14,	26(r1)	; 0x001a
    cb5c:	81 4f 1c 00 	mov	r15,	28(r1)	; 0x001c
    cb60:	09 48       	mov	r8,	r9	;
    cb62:	81 48 10 00 	mov	r8,	16(r1)	; 0x0010
    cb66:	0c 48       	mov	r8,	r12	;
    cb68:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    cb6c:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    cb70:	b0 12 0e d3 	call	#54030		;#0xd30e
    cb74:	81 4c 02 00 	mov	r12,	2(r1)	;
    cb78:	81 4d 04 00 	mov	r13,	4(r1)	;
    cb7c:	81 47 12 00 	mov	r7,	18(r1)	; 0x0012
    cb80:	0c 47       	mov	r7,	r12	;
    cb82:	0d 46       	mov	r6,	r13	;
    cb84:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    cb88:	b0 12 0e d3 	call	#54030		;#0xd30e
    cb8c:	81 4c 06 00 	mov	r12,	6(r1)	;
    cb90:	81 4d 08 00 	mov	r13,	8(r1)	;
    cb94:	38 40 16 d1 	mov	#53526,	r8	;#0xd116
    cb98:	0c 47       	mov	r7,	r12	;
    cb9a:	0d 43       	clr	r13		;
    cb9c:	0e 49       	mov	r9,	r14	;
    cb9e:	0f 4d       	mov	r13,	r15	;
    cba0:	88 12       	call	r8		;
    cba2:	04 4c       	mov	r12,	r4	;
    cba4:	81 4c 14 00 	mov	r12,	20(r1)	; 0x0014
    cba8:	05 4d       	mov	r13,	r5	;
    cbaa:	0c 47       	mov	r7,	r12	;
    cbac:	0d 43       	clr	r13		;
    cbae:	1e 41 02 00 	mov	2(r1),	r14	;
    cbb2:	1f 41 04 00 	mov	4(r1),	r15	;
    cbb6:	88 12       	call	r8		;
    cbb8:	07 4c       	mov	r12,	r7	;
    cbba:	0a 4d       	mov	r13,	r10	;
    cbbc:	1c 41 06 00 	mov	6(r1),	r12	;
    cbc0:	1d 41 08 00 	mov	8(r1),	r13	;
    cbc4:	1e 41 02 00 	mov	2(r1),	r14	;
    cbc8:	1f 41 04 00 	mov	4(r1),	r15	;
    cbcc:	88 12       	call	r8		;
    cbce:	81 4c 02 00 	mov	r12,	2(r1)	;
    cbd2:	81 4d 04 00 	mov	r13,	4(r1)	;
    cbd6:	1c 41 06 00 	mov	6(r1),	r12	;
    cbda:	1d 41 08 00 	mov	8(r1),	r13	;
    cbde:	0e 49       	mov	r9,	r14	;
    cbe0:	0f 43       	clr	r15		;
    cbe2:	88 12       	call	r8		;
    cbe4:	09 47       	mov	r7,	r9	;
    cbe6:	09 5c       	add	r12,	r9	;
    cbe8:	08 4a       	mov	r10,	r8	;
    cbea:	08 6d       	addc	r13,	r8	;
    cbec:	0c 44       	mov	r4,	r12	;
    cbee:	0d 45       	mov	r5,	r13	;
    cbf0:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    cbf4:	b0 12 0e d3 	call	#54030		;#0xd30e
    cbf8:	09 5c       	add	r12,	r9	;
    cbfa:	0d 68       	addc	r8,	r13	;
    cbfc:	0d 9a       	cmp	r10,	r13	;
    cbfe:	04 28       	jnc	$+10     	;abs 0xcc08
    cc00:	0a 9d       	cmp	r13,	r10	;
    cc02:	06 20       	jnz	$+14     	;abs 0xcc10
    cc04:	09 97       	cmp	r7,	r9	;
    cc06:	04 2c       	jc	$+10     	;abs 0xcc10
    cc08:	81 53 02 00 	add	#0,	2(r1)	;r3 As==00
    cc0c:	91 63 04 00 	addc	#1,	4(r1)	;r3 As==01
    cc10:	0c 49       	mov	r9,	r12	;
    cc12:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    cc16:	b0 12 0e d3 	call	#54030		;#0xd30e
    cc1a:	15 41 02 00 	mov	2(r1),	r5	;
    cc1e:	05 5c       	add	r12,	r5	;
    cc20:	1d 61 04 00 	addc	4(r1),	r13	;
    cc24:	07 4d       	mov	r13,	r7	;
    cc26:	0c 49       	mov	r9,	r12	;
    cc28:	0d 43       	clr	r13		;
    cc2a:	3e 40 10 00 	mov	#16,	r14	;#0x0010
    cc2e:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    cc32:	0f 43       	clr	r15		;
    cc34:	0e 4f       	mov	r15,	r14	;
    cc36:	1f 41 14 00 	mov	20(r1),	r15	;0x00014
    cc3a:	0c 5f       	add	r15,	r12	;
    cc3c:	0d 6e       	addc	r14,	r13	;
    cc3e:	08 4c       	mov	r12,	r8	;
    cc40:	09 4d       	mov	r13,	r9	;
    cc42:	0a 45       	mov	r5,	r10	;
    cc44:	34 40 16 d1 	mov	#53526,	r4	;#0xd116
    cc48:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    cc4c:	1d 41 0e 00 	mov	14(r1),	r13	;0x0000e
    cc50:	1e 41 1a 00 	mov	26(r1),	r14	;0x0001a
    cc54:	1f 41 1c 00 	mov	28(r1),	r15	;0x0001c
    cc58:	81 47 00 00 	mov	r7,	0(r1)	;
    cc5c:	84 12       	call	r4		;
    cc5e:	07 4c       	mov	r12,	r7	;
    cc60:	05 4d       	mov	r13,	r5	;
    cc62:	1c 41 12 00 	mov	18(r1),	r12	;0x00012
    cc66:	0d 46       	mov	r6,	r13	;
    cc68:	1e 41 16 00 	mov	22(r1),	r14	;0x00016
    cc6c:	1f 41 18 00 	mov	24(r1),	r15	;0x00018
    cc70:	84 12       	call	r4		;
    cc72:	07 5c       	add	r12,	r7	;
    cc74:	81 47 0a 00 	mov	r7,	10(r1)	; 0x000a
    cc78:	05 6d       	addc	r13,	r5	;
    cc7a:	81 45 0c 00 	mov	r5,	12(r1)	; 0x000c
    cc7e:	2b 41       	mov	@r1,	r11	;
    cc80:	1a 51 0a 00 	add	10(r1),	r10	;0x0000a
    cc84:	1b 61 0c 00 	addc	12(r1),	r11	;0x0000c
    cc88:	0c 48       	mov	r8,	r12	;
    cc8a:	0d 49       	mov	r9,	r13	;
    cc8c:	0e 4a       	mov	r10,	r14	;
    cc8e:	0f 4b       	mov	r11,	r15	;
    cc90:	31 50 1e 00 	add	#30,	r1	;#0x001e
    cc94:	30 40 68 d1 	br	#0xd168		;

0000cc98 <__lshrdi3>:
    cc98:	0a 12       	push	r10		;
    cc9a:	09 12       	push	r9		;
    cc9c:	08 12       	push	r8		;
    cc9e:	07 12       	push	r7		;
    cca0:	06 12       	push	r6		;
    cca2:	05 12       	push	r5		;
    cca4:	04 12       	push	r4		;
    cca6:	21 83       	decd	r1		;
    cca8:	14 41 12 00 	mov	18(r1),	r4	;0x00012
    ccac:	04 93       	cmp	#0,	r4	;r3 As==00
    ccae:	2f 24       	jz	$+96     	;abs 0xcd0e
    ccb0:	05 4d       	mov	r13,	r5	;
    ccb2:	81 4c 00 00 	mov	r12,	0(r1)	;
    ccb6:	37 40 20 00 	mov	#32,	r7	;#0x0020
    ccba:	07 84       	sub	r4,	r7	;
    ccbc:	0c 43       	clr	r12		;
    ccbe:	0c 97       	cmp	r7,	r12	;
    ccc0:	0b 38       	jl	$+24     	;abs 0xccd8
    ccc2:	09 4c       	mov	r12,	r9	;
    ccc4:	08 4c       	mov	r12,	r8	;
    ccc6:	0a 43       	clr	r10		;
    ccc8:	0a 87       	sub	r7,	r10	;
    ccca:	0c 4e       	mov	r14,	r12	;
    cccc:	0d 4f       	mov	r15,	r13	;
    ccce:	0e 4a       	mov	r10,	r14	;
    ccd0:	b0 12 0e d3 	call	#54030		;#0xd30e
    ccd4:	30 40 0a cd 	br	#0xcd0a		;
    ccd8:	0a 4e       	mov	r14,	r10	;
    ccda:	06 4f       	mov	r15,	r6	;
    ccdc:	0c 4e       	mov	r14,	r12	;
    ccde:	0d 4f       	mov	r15,	r13	;
    cce0:	0e 44       	mov	r4,	r14	;
    cce2:	b0 12 0e d3 	call	#54030		;#0xd30e
    cce6:	09 4c       	mov	r12,	r9	;
    cce8:	08 4d       	mov	r13,	r8	;
    ccea:	0c 4a       	mov	r10,	r12	;
    ccec:	0d 46       	mov	r6,	r13	;
    ccee:	0e 47       	mov	r7,	r14	;
    ccf0:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    ccf4:	06 4c       	mov	r12,	r6	;
    ccf6:	07 4d       	mov	r13,	r7	;
    ccf8:	2c 41       	mov	@r1,	r12	;
    ccfa:	0d 45       	mov	r5,	r13	;
    ccfc:	0e 44       	mov	r4,	r14	;
    ccfe:	b0 12 0e d3 	call	#54030		;#0xd30e
    cd02:	0d d7       	bis	r7,	r13	;
    cd04:	0b 46       	mov	r6,	r11	;
    cd06:	0b dc       	bis	r12,	r11	;
    cd08:	0c 4b       	mov	r11,	r12	;
    cd0a:	0e 49       	mov	r9,	r14	;
    cd0c:	0f 48       	mov	r8,	r15	;
    cd0e:	21 53       	incd	r1		;
    cd10:	30 40 68 d1 	br	#0xd168		;

0000cd14 <__ashldi3>:
    cd14:	0a 12       	push	r10		;
    cd16:	09 12       	push	r9		;
    cd18:	08 12       	push	r8		;
    cd1a:	07 12       	push	r7		;
    cd1c:	06 12       	push	r6		;
    cd1e:	05 12       	push	r5		;
    cd20:	04 12       	push	r4		;
    cd22:	21 83       	decd	r1		;
    cd24:	14 41 12 00 	mov	18(r1),	r4	;0x00012
    cd28:	04 93       	cmp	#0,	r4	;r3 As==00
    cd2a:	2f 24       	jz	$+96     	;abs 0xcd8a
    cd2c:	05 4f       	mov	r15,	r5	;
    cd2e:	81 4e 00 00 	mov	r14,	0(r1)	;
    cd32:	0e 4c       	mov	r12,	r14	;
    cd34:	37 40 20 00 	mov	#32,	r7	;#0x0020
    cd38:	07 84       	sub	r4,	r7	;
    cd3a:	0c 43       	clr	r12		;
    cd3c:	0c 97       	cmp	r7,	r12	;
    cd3e:	0b 38       	jl	$+24     	;abs 0xcd56
    cd40:	09 4c       	mov	r12,	r9	;
    cd42:	08 4c       	mov	r12,	r8	;
    cd44:	0f 43       	clr	r15		;
    cd46:	0f 87       	sub	r7,	r15	;
    cd48:	0c 4e       	mov	r14,	r12	;
    cd4a:	0e 4f       	mov	r15,	r14	;
    cd4c:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    cd50:	0e 4c       	mov	r12,	r14	;
    cd52:	30 40 84 cd 	br	#0xcd84		;
    cd56:	0a 4e       	mov	r14,	r10	;
    cd58:	06 4d       	mov	r13,	r6	;
    cd5a:	0c 4e       	mov	r14,	r12	;
    cd5c:	0e 44       	mov	r4,	r14	;
    cd5e:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    cd62:	09 4c       	mov	r12,	r9	;
    cd64:	08 4d       	mov	r13,	r8	;
    cd66:	0c 4a       	mov	r10,	r12	;
    cd68:	0d 46       	mov	r6,	r13	;
    cd6a:	0e 47       	mov	r7,	r14	;
    cd6c:	b0 12 0e d3 	call	#54030		;#0xd30e
    cd70:	06 4c       	mov	r12,	r6	;
    cd72:	07 4d       	mov	r13,	r7	;
    cd74:	2c 41       	mov	@r1,	r12	;
    cd76:	0d 45       	mov	r5,	r13	;
    cd78:	0e 44       	mov	r4,	r14	;
    cd7a:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    cd7e:	0d d7       	bis	r7,	r13	;
    cd80:	0e 46       	mov	r6,	r14	;
    cd82:	0e dc       	bis	r12,	r14	;
    cd84:	0f 4d       	mov	r13,	r15	;
    cd86:	0c 49       	mov	r9,	r12	;
    cd88:	0d 48       	mov	r8,	r13	;
    cd8a:	21 53       	incd	r1		;
    cd8c:	30 40 68 d1 	br	#0xd168		;

0000cd90 <__ashrdi3>:
    cd90:	0a 12       	push	r10		;
    cd92:	09 12       	push	r9		;
    cd94:	08 12       	push	r8		;
    cd96:	07 12       	push	r7		;
    cd98:	06 12       	push	r6		;
    cd9a:	05 12       	push	r5		;
    cd9c:	04 12       	push	r4		;
    cd9e:	21 83       	decd	r1		;
    cda0:	17 41 12 00 	mov	18(r1),	r7	;0x00012
    cda4:	07 93       	cmp	#0,	r7	;r3 As==00
    cda6:	3e 24       	jz	$+126    	;abs 0xce24
    cda8:	05 4d       	mov	r13,	r5	;
    cdaa:	81 4c 00 00 	mov	r12,	0(r1)	;
    cdae:	36 40 20 00 	mov	#32,	r6	;#0x0020
    cdb2:	06 87       	sub	r7,	r6	;
    cdb4:	0c 43       	clr	r12		;
    cdb6:	0c 96       	cmp	r6,	r12	;
    cdb8:	16 38       	jl	$+46     	;abs 0xcde6
    cdba:	07 4e       	mov	r14,	r7	;
    cdbc:	08 4f       	mov	r15,	r8	;
    cdbe:	0c 4e       	mov	r14,	r12	;
    cdc0:	0d 4f       	mov	r15,	r13	;
    cdc2:	3e 40 1f 00 	mov	#31,	r14	;#0x001f
    cdc6:	b0 12 5a d2 	call	#53850		;#0xd25a
    cdca:	09 4c       	mov	r12,	r9	;
    cdcc:	0a 4d       	mov	r13,	r10	;
    cdce:	0e 43       	clr	r14		;
    cdd0:	0e 86       	sub	r6,	r14	;
    cdd2:	0c 47       	mov	r7,	r12	;
    cdd4:	0d 48       	mov	r8,	r13	;
    cdd6:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    cdda:	0f 7f       	subc	r15,	r15	;
    cddc:	3f e3       	inv	r15		;
    cdde:	b0 12 5a d2 	call	#53850		;#0xd25a
    cde2:	30 40 20 ce 	br	#0xce20		;
    cde6:	08 4e       	mov	r14,	r8	;
    cde8:	04 4f       	mov	r15,	r4	;
    cdea:	0c 4e       	mov	r14,	r12	;
    cdec:	0d 4f       	mov	r15,	r13	;
    cdee:	0e 47       	mov	r7,	r14	;
    cdf0:	3e b0 00 80 	bit	#32768,	r14	;#0x8000
    cdf4:	0f 7f       	subc	r15,	r15	;
    cdf6:	3f e3       	inv	r15		;
    cdf8:	b0 12 5a d2 	call	#53850		;#0xd25a
    cdfc:	09 4c       	mov	r12,	r9	;
    cdfe:	0a 4d       	mov	r13,	r10	;
    ce00:	0c 48       	mov	r8,	r12	;
    ce02:	0d 44       	mov	r4,	r13	;
    ce04:	0e 46       	mov	r6,	r14	;
    ce06:	b0 12 e6 d1 	call	#53734		;#0xd1e6
    ce0a:	06 4c       	mov	r12,	r6	;
    ce0c:	04 4d       	mov	r13,	r4	;
    ce0e:	2c 41       	mov	@r1,	r12	;
    ce10:	0d 45       	mov	r5,	r13	;
    ce12:	0e 47       	mov	r7,	r14	;
    ce14:	b0 12 0e d3 	call	#54030		;#0xd30e
    ce18:	0d d4       	bis	r4,	r13	;
    ce1a:	0e 46       	mov	r6,	r14	;
    ce1c:	0e dc       	bis	r12,	r14	;
    ce1e:	0c 4e       	mov	r14,	r12	;
    ce20:	0e 49       	mov	r9,	r14	;
    ce22:	0f 4a       	mov	r10,	r15	;
    ce24:	21 53       	incd	r1		;
    ce26:	30 40 68 d1 	br	#0xd168		;

0000ce2a <udivmodhi4>:
    ce2a:	0a 12       	push	r10		;
    ce2c:	09 12       	push	r9		;
    ce2e:	08 12       	push	r8		;
    ce30:	07 12       	push	r7		;
    ce32:	06 12       	push	r6		;
    ce34:	09 4c       	mov	r12,	r9	;
    ce36:	0a 4d       	mov	r13,	r10	;
    ce38:	06 4e       	mov	r14,	r6	;
    ce3a:	3c 40 11 00 	mov	#17,	r12	;#0x0011
    ce3e:	18 43       	mov	#1,	r8	;r3 As==01
    ce40:	0a 99       	cmp	r9,	r10	;
    ce42:	0a 2c       	jc	$+22     	;abs 0xce58
    ce44:	3c 53       	add	#-1,	r12	;r3 As==11
    ce46:	0c 93       	cmp	#0,	r12	;r3 As==00
    ce48:	06 24       	jz	$+14     	;abs 0xce56
    ce4a:	0a 93       	cmp	#0,	r10	;r3 As==00
    ce4c:	05 38       	jl	$+12     	;abs 0xce58
    ce4e:	0a 5a       	rla	r10		;
    ce50:	08 58       	rla	r8		;
    ce52:	30 40 40 ce 	br	#0xce40		;
    ce56:	08 4c       	mov	r12,	r8	;
    ce58:	07 43       	clr	r7		;
    ce5a:	08 93       	cmp	#0,	r8	;r3 As==00
    ce5c:	0e 24       	jz	$+30     	;abs 0xce7a
    ce5e:	09 9a       	cmp	r10,	r9	;
    ce60:	02 28       	jnc	$+6      	;abs 0xce66
    ce62:	09 8a       	sub	r10,	r9	;
    ce64:	07 d8       	bis	r8,	r7	;
    ce66:	0c 48       	mov	r8,	r12	;
    ce68:	b0 12 98 d2 	call	#53912		;#0xd298
    ce6c:	08 4c       	mov	r12,	r8	;
    ce6e:	0c 4a       	mov	r10,	r12	;
    ce70:	b0 12 98 d2 	call	#53912		;#0xd298
    ce74:	0a 4c       	mov	r12,	r10	;
    ce76:	30 40 5a ce 	br	#0xce5a		;
    ce7a:	06 93       	cmp	#0,	r6	;r3 As==00
    ce7c:	03 20       	jnz	$+8      	;abs 0xce84
    ce7e:	0c 47       	mov	r7,	r12	;
    ce80:	30 40 86 ce 	br	#0xce86		;
    ce84:	0c 49       	mov	r9,	r12	;
    ce86:	30 40 6c d1 	br	#0xd16c		;

0000ce8a <__mspabi_divi>:
    ce8a:	0a 12       	push	r10		;
    ce8c:	0e 4c       	mov	r12,	r14	;
    ce8e:	0f 4d       	mov	r13,	r15	;
    ce90:	3b 40 2a ce 	mov	#52778,	r11	;#0xce2a
    ce94:	0c 93       	cmp	#0,	r12	;r3 As==00
    ce96:	08 34       	jge	$+18     	;abs 0xcea8
    ce98:	0c 43       	clr	r12		;
    ce9a:	0c 8e       	sub	r14,	r12	;
    ce9c:	0e 4c       	mov	r12,	r14	;
    ce9e:	0d 93       	cmp	#0,	r13	;r3 As==00
    cea0:	12 34       	jge	$+38     	;abs 0xcec6
    cea2:	1a 43       	mov	#1,	r10	;r3 As==01
    cea4:	30 40 ae ce 	br	#0xceae		;
    cea8:	0d 93       	cmp	#0,	r13	;r3 As==00
    ceaa:	11 34       	jge	$+36     	;abs 0xcece
    ceac:	0a 43       	clr	r10		;
    ceae:	0d 43       	clr	r13		;
    ceb0:	0d 8f       	sub	r15,	r13	;
    ceb2:	0c 4e       	mov	r14,	r12	;
    ceb4:	0e 43       	clr	r14		;
    ceb6:	8b 12       	call	r11		;
    ceb8:	1a 93       	cmp	#1,	r10	;r3 As==01
    ceba:	0b 24       	jz	$+24     	;abs 0xced2
    cebc:	0d 43       	clr	r13		;
    cebe:	0d 8c       	sub	r12,	r13	;
    cec0:	0c 4d       	mov	r13,	r12	;
    cec2:	30 40 d2 ce 	br	#0xced2		;
    cec6:	0e 43       	clr	r14		;
    cec8:	8b 12       	call	r11		;
    ceca:	30 40 bc ce 	br	#0xcebc		;
    cece:	0e 43       	clr	r14		;
    ced0:	8b 12       	call	r11		;
    ced2:	3a 41       	pop	r10		;
    ced4:	30 41       	ret			

0000ced6 <__mspabi_remi>:
    ced6:	0a 12       	push	r10		;
    ced8:	0c 93       	cmp	#0,	r12	;r3 As==00
    ceda:	06 34       	jge	$+14     	;abs 0xcee8
    cedc:	0e 43       	clr	r14		;
    cede:	0e 8c       	sub	r12,	r14	;
    cee0:	0c 4e       	mov	r14,	r12	;
    cee2:	1a 43       	mov	#1,	r10	;r3 As==01
    cee4:	30 40 ea ce 	br	#0xceea		;
    cee8:	0a 43       	clr	r10		;
    ceea:	0d 93       	cmp	#0,	r13	;r3 As==00
    ceec:	03 34       	jge	$+8      	;abs 0xcef4
    ceee:	0e 43       	clr	r14		;
    cef0:	0e 8d       	sub	r13,	r14	;
    cef2:	0d 4e       	mov	r14,	r13	;
    cef4:	1e 43       	mov	#1,	r14	;r3 As==01
    cef6:	b0 12 2a ce 	call	#52778		;#0xce2a
    cefa:	0a 93       	cmp	#0,	r10	;r3 As==00
    cefc:	03 24       	jz	$+8      	;abs 0xcf04
    cefe:	0d 43       	clr	r13		;
    cf00:	0d 8c       	sub	r12,	r13	;
    cf02:	0c 4d       	mov	r13,	r12	;
    cf04:	3a 41       	pop	r10		;
    cf06:	30 41       	ret			

0000cf08 <__mspabi_divu>:
    cf08:	0e 43       	clr	r14		;
    cf0a:	b0 12 2a ce 	call	#52778		;#0xce2a
    cf0e:	30 41       	ret			

0000cf10 <__mspabi_remu>:
    cf10:	1e 43       	mov	#1,	r14	;r3 As==01
    cf12:	b0 12 2a ce 	call	#52778		;#0xce2a
    cf16:	30 41       	ret			

0000cf18 <udivmodsi4>:
    cf18:	0a 12       	push	r10		;
    cf1a:	09 12       	push	r9		;
    cf1c:	08 12       	push	r8		;
    cf1e:	07 12       	push	r7		;
    cf20:	06 12       	push	r6		;
    cf22:	0a 4c       	mov	r12,	r10	;
    cf24:	0b 4d       	mov	r13,	r11	;
    cf26:	3c 40 21 00 	mov	#33,	r12	;#0x0021
    cf2a:	18 43       	mov	#1,	r8	;r3 As==01
    cf2c:	09 43       	clr	r9		;
    cf2e:	0f 9b       	cmp	r11,	r15	;
    cf30:	04 28       	jnc	$+10     	;abs 0xcf3a
    cf32:	0d 9f       	cmp	r15,	r13	;
    cf34:	17 20       	jnz	$+48     	;abs 0xcf64
    cf36:	0e 9a       	cmp	r10,	r14	;
    cf38:	15 2c       	jc	$+44     	;abs 0xcf64
    cf3a:	3c 53       	add	#-1,	r12	;r3 As==11
    cf3c:	0c 93       	cmp	#0,	r12	;r3 As==00
    cf3e:	10 24       	jz	$+34     	;abs 0xcf60
    cf40:	0f 93       	cmp	#0,	r15	;r3 As==00
    cf42:	10 38       	jl	$+34     	;abs 0xcf64
    cf44:	06 4e       	mov	r14,	r6	;
    cf46:	07 4f       	mov	r15,	r7	;
    cf48:	06 5e       	add	r14,	r6	;
    cf4a:	07 6f       	addc	r15,	r7	;
    cf4c:	0e 46       	mov	r6,	r14	;
    cf4e:	0f 47       	mov	r7,	r15	;
    cf50:	06 48       	mov	r8,	r6	;
    cf52:	07 49       	mov	r9,	r7	;
    cf54:	06 58       	add	r8,	r6	;
    cf56:	07 69       	addc	r9,	r7	;
    cf58:	08 46       	mov	r6,	r8	;
    cf5a:	09 47       	mov	r7,	r9	;
    cf5c:	30 40 2e cf 	br	#0xcf2e		;
    cf60:	08 43       	clr	r8		;
    cf62:	09 43       	clr	r9		;
    cf64:	0c 43       	clr	r12		;
    cf66:	0d 4c       	mov	r12,	r13	;
    cf68:	07 48       	mov	r8,	r7	;
    cf6a:	07 d9       	bis	r9,	r7	;
    cf6c:	07 93       	cmp	#0,	r7	;r3 As==00
    cf6e:	12 24       	jz	$+38     	;abs 0xcf94
    cf70:	0b 9f       	cmp	r15,	r11	;
    cf72:	08 28       	jnc	$+18     	;abs 0xcf84
    cf74:	0f 9b       	cmp	r11,	r15	;
    cf76:	02 20       	jnz	$+6      	;abs 0xcf7c
    cf78:	0a 9e       	cmp	r14,	r10	;
    cf7a:	04 28       	jnc	$+10     	;abs 0xcf84
    cf7c:	0a 8e       	sub	r14,	r10	;
    cf7e:	0b 7f       	subc	r15,	r11	;
    cf80:	0c d8       	bis	r8,	r12	;
    cf82:	0d d9       	bis	r9,	r13	;
    cf84:	12 c3       	clrc			
    cf86:	09 10       	rrc	r9		;
    cf88:	08 10       	rrc	r8		;
    cf8a:	12 c3       	clrc			
    cf8c:	0f 10       	rrc	r15		;
    cf8e:	0e 10       	rrc	r14		;
    cf90:	30 40 68 cf 	br	#0xcf68		;
    cf94:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    cf98:	02 24       	jz	$+6      	;abs 0xcf9e
    cf9a:	0c 4a       	mov	r10,	r12	;
    cf9c:	0d 4b       	mov	r11,	r13	;
    cf9e:	30 40 6c d1 	br	#0xd16c		;

0000cfa2 <__mspabi_divli>:
    cfa2:	0a 12       	push	r10		;
    cfa4:	09 12       	push	r9		;
    cfa6:	08 12       	push	r8		;
    cfa8:	07 12       	push	r7		;
    cfaa:	06 12       	push	r6		;
    cfac:	05 12       	push	r5		;
    cfae:	21 83       	decd	r1		;
    cfb0:	0a 4c       	mov	r12,	r10	;
    cfb2:	0b 4d       	mov	r13,	r11	;
    cfb4:	08 4e       	mov	r14,	r8	;
    cfb6:	09 4f       	mov	r15,	r9	;
    cfb8:	37 40 18 cf 	mov	#53016,	r7	;#0xcf18
    cfbc:	0d 93       	cmp	#0,	r13	;r3 As==00
    cfbe:	0d 34       	jge	$+28     	;abs 0xcfda
    cfc0:	0c 43       	clr	r12		;
    cfc2:	0d 43       	clr	r13		;
    cfc4:	05 4c       	mov	r12,	r5	;
    cfc6:	06 4d       	mov	r13,	r6	;
    cfc8:	05 8a       	sub	r10,	r5	;
    cfca:	06 7b       	subc	r11,	r6	;
    cfcc:	0a 45       	mov	r5,	r10	;
    cfce:	0b 46       	mov	r6,	r11	;
    cfd0:	0f 93       	cmp	#0,	r15	;r3 As==00
    cfd2:	1c 34       	jge	$+58     	;abs 0xd00c
    cfd4:	16 43       	mov	#1,	r6	;r3 As==01
    cfd6:	30 40 e2 cf 	br	#0xcfe2		;
    cfda:	06 4f       	mov	r15,	r6	;
    cfdc:	0f 93       	cmp	#0,	r15	;r3 As==00
    cfde:	1d 34       	jge	$+60     	;abs 0xd01a
    cfe0:	06 43       	clr	r6		;
    cfe2:	0e 43       	clr	r14		;
    cfe4:	0f 43       	clr	r15		;
    cfe6:	0e 88       	sub	r8,	r14	;
    cfe8:	0f 79       	subc	r9,	r15	;
    cfea:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    cfee:	0c 4a       	mov	r10,	r12	;
    cff0:	0d 4b       	mov	r11,	r13	;
    cff2:	87 12       	call	r7		;
    cff4:	16 93       	cmp	#1,	r6	;r3 As==01
    cff6:	14 24       	jz	$+42     	;abs 0xd020
    cff8:	0e 43       	clr	r14		;
    cffa:	0f 43       	clr	r15		;
    cffc:	0a 4e       	mov	r14,	r10	;
    cffe:	0b 4f       	mov	r15,	r11	;
    d000:	0a 8c       	sub	r12,	r10	;
    d002:	0b 7d       	subc	r13,	r11	;
    d004:	0c 4a       	mov	r10,	r12	;
    d006:	0d 4b       	mov	r11,	r13	;
    d008:	30 40 20 d0 	br	#0xd020		;
    d00c:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d010:	0c 45       	mov	r5,	r12	;
    d012:	0d 46       	mov	r6,	r13	;
    d014:	87 12       	call	r7		;
    d016:	30 40 f8 cf 	br	#0xcff8		;
    d01a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d01e:	87 12       	call	r7		;
    d020:	21 53       	incd	r1		;
    d022:	30 40 6a d1 	br	#0xd16a		;

0000d026 <__mspabi_remli>:
    d026:	0a 12       	push	r10		;
    d028:	09 12       	push	r9		;
    d02a:	08 12       	push	r8		;
    d02c:	07 12       	push	r7		;
    d02e:	06 12       	push	r6		;
    d030:	21 83       	decd	r1		;
    d032:	0d 93       	cmp	#0,	r13	;r3 As==00
    d034:	0b 34       	jge	$+24     	;abs 0xd04c
    d036:	0a 43       	clr	r10		;
    d038:	0b 43       	clr	r11		;
    d03a:	06 4a       	mov	r10,	r6	;
    d03c:	07 4b       	mov	r11,	r7	;
    d03e:	06 8c       	sub	r12,	r6	;
    d040:	07 7d       	subc	r13,	r7	;
    d042:	0c 46       	mov	r6,	r12	;
    d044:	0d 47       	mov	r7,	r13	;
    d046:	1a 43       	mov	#1,	r10	;r3 As==01
    d048:	30 40 4e d0 	br	#0xd04e		;
    d04c:	0a 43       	clr	r10		;
    d04e:	09 4f       	mov	r15,	r9	;
    d050:	0f 93       	cmp	#0,	r15	;r3 As==00
    d052:	08 34       	jge	$+18     	;abs 0xd064
    d054:	08 43       	clr	r8		;
    d056:	09 43       	clr	r9		;
    d058:	06 48       	mov	r8,	r6	;
    d05a:	07 49       	mov	r9,	r7	;
    d05c:	06 8e       	sub	r14,	r6	;
    d05e:	07 7f       	subc	r15,	r7	;
    d060:	0e 46       	mov	r6,	r14	;
    d062:	0f 47       	mov	r7,	r15	;
    d064:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    d068:	b0 12 18 cf 	call	#53016		;#0xcf18
    d06c:	0a 93       	cmp	#0,	r10	;r3 As==00
    d06e:	08 24       	jz	$+18     	;abs 0xd080
    d070:	0e 43       	clr	r14		;
    d072:	0f 43       	clr	r15		;
    d074:	07 4e       	mov	r14,	r7	;
    d076:	08 4f       	mov	r15,	r8	;
    d078:	07 8c       	sub	r12,	r7	;
    d07a:	08 7d       	subc	r13,	r8	;
    d07c:	0c 47       	mov	r7,	r12	;
    d07e:	0d 48       	mov	r8,	r13	;
    d080:	21 53       	incd	r1		;
    d082:	30 40 6c d1 	br	#0xd16c		;

0000d086 <__mspabi_divlu>:
    d086:	21 83       	decd	r1		;
    d088:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00
    d08c:	b0 12 18 cf 	call	#53016		;#0xcf18
    d090:	21 53       	incd	r1		;
    d092:	30 41       	ret			

0000d094 <__mspabi_remul>:
    d094:	21 83       	decd	r1		;
    d096:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01
    d09a:	b0 12 18 cf 	call	#53016		;#0xcf18
    d09e:	21 53       	incd	r1		;
    d0a0:	30 41       	ret			

0000d0a2 <__mspabi_mpyi>:
    d0a2:	0a 12       	push	r10		;
    d0a4:	09 12       	push	r9		;
    d0a6:	08 12       	push	r8		;
    d0a8:	09 4c       	mov	r12,	r9	;
    d0aa:	0c 4d       	mov	r13,	r12	;
    d0ac:	3a 40 11 00 	mov	#17,	r10	;#0x0011
    d0b0:	08 43       	clr	r8		;
    d0b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    d0b4:	0d 24       	jz	$+28     	;abs 0xd0d0
    d0b6:	7a 53       	add.b	#-1,	r10	;r3 As==11
    d0b8:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    d0bc:	0a 93       	cmp	#0,	r10	;r3 As==00
    d0be:	08 24       	jz	$+18     	;abs 0xd0d0
    d0c0:	1c b3       	bit	#1,	r12	;r3 As==01
    d0c2:	01 24       	jz	$+4      	;abs 0xd0c6
    d0c4:	08 59       	add	r9,	r8	;
    d0c6:	09 59       	rla	r9		;
    d0c8:	b0 12 98 d2 	call	#53912		;#0xd298
    d0cc:	30 40 b2 d0 	br	#0xd0b2		;
    d0d0:	0c 48       	mov	r8,	r12	;
    d0d2:	30 40 70 d1 	br	#0xd170		;

0000d0d6 <__mulqi3>:
    d0d6:	0a 12       	push	r10		;
    d0d8:	09 12       	push	r9		;
    d0da:	08 12       	push	r8		;
    d0dc:	4a 4c       	mov.b	r12,	r10	;
    d0de:	4c 4d       	mov.b	r13,	r12	;
    d0e0:	38 40 09 00 	mov	#9,	r8	;
    d0e4:	09 43       	clr	r9		;
    d0e6:	0c 93       	cmp	#0,	r12	;r3 As==00
    d0e8:	13 24       	jz	$+40     	;abs 0xd110
    d0ea:	78 53       	add.b	#-1,	r8	;r3 As==11
    d0ec:	38 f0 ff 00 	and	#255,	r8	;#0x00ff
    d0f0:	08 93       	cmp	#0,	r8	;r3 As==00
    d0f2:	0e 24       	jz	$+30     	;abs 0xd110
    d0f4:	1c b3       	bit	#1,	r12	;r3 As==01
    d0f6:	03 24       	jz	$+8      	;abs 0xd0fe
    d0f8:	49 5a       	add.b	r10,	r9	;
    d0fa:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    d0fe:	4a 5a       	rla.b	r10		;
    d100:	3a f0 ff 00 	and	#255,	r10	;#0x00ff
    d104:	b0 12 98 d2 	call	#53912		;#0xd298
    d108:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    d10c:	30 40 e6 d0 	br	#0xd0e6		;
    d110:	4c 49       	mov.b	r9,	r12	;
    d112:	30 40 70 d1 	br	#0xd170		;

0000d116 <__mspabi_mpyl>:
    d116:	0a 12       	push	r10		;
    d118:	09 12       	push	r9		;
    d11a:	08 12       	push	r8		;
    d11c:	07 12       	push	r7		;
    d11e:	06 12       	push	r6		;
    d120:	0a 4c       	mov	r12,	r10	;
    d122:	0b 4d       	mov	r13,	r11	;
    d124:	3d 40 21 00 	mov	#33,	r13	;#0x0021
    d128:	08 43       	clr	r8		;
    d12a:	09 43       	clr	r9		;
    d12c:	0c 4e       	mov	r14,	r12	;
    d12e:	0c df       	bis	r15,	r12	;
    d130:	0c 93       	cmp	#0,	r12	;r3 As==00
    d132:	16 24       	jz	$+46     	;abs 0xd160
    d134:	7d 53       	add.b	#-1,	r13	;r3 As==11
    d136:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    d13a:	0d 93       	cmp	#0,	r13	;r3 As==00
    d13c:	11 24       	jz	$+36     	;abs 0xd160
    d13e:	0c 4e       	mov	r14,	r12	;
    d140:	1c f3       	and	#1,	r12	;r3 As==01
    d142:	0c 93       	cmp	#0,	r12	;r3 As==00
    d144:	02 24       	jz	$+6      	;abs 0xd14a
    d146:	08 5a       	add	r10,	r8	;
    d148:	09 6b       	addc	r11,	r9	;
    d14a:	06 4a       	mov	r10,	r6	;
    d14c:	07 4b       	mov	r11,	r7	;
    d14e:	06 5a       	add	r10,	r6	;
    d150:	07 6b       	addc	r11,	r7	;
    d152:	0a 46       	mov	r6,	r10	;
    d154:	0b 47       	mov	r7,	r11	;
    d156:	12 c3       	clrc			
    d158:	0f 10       	rrc	r15		;
    d15a:	0e 10       	rrc	r14		;
    d15c:	30 40 2c d1 	br	#0xd12c		;
    d160:	0c 48       	mov	r8,	r12	;
    d162:	0d 49       	mov	r9,	r13	;
    d164:	30 40 6c d1 	br	#0xd16c		;

0000d168 <__mspabi_func_epilog_7>:
    d168:	34 41       	pop	r4		;

0000d16a <__mspabi_func_epilog_6>:
    d16a:	35 41       	pop	r5		;

0000d16c <__mspabi_func_epilog_5>:
    d16c:	36 41       	pop	r6		;

0000d16e <__mspabi_func_epilog_4>:
    d16e:	37 41       	pop	r7		;

0000d170 <__mspabi_func_epilog_3>:
    d170:	38 41       	pop	r8		;

0000d172 <__mspabi_func_epilog_2>:
    d172:	39 41       	pop	r9		;

0000d174 <__mspabi_func_epilog_1>:
    d174:	3a 41       	pop	r10		;
    d176:	30 41       	ret			

0000d178 <__mspabi_slli_15>:
    d178:	0c 5c       	rla	r12		;

0000d17a <__mspabi_slli_14>:
    d17a:	0c 5c       	rla	r12		;

0000d17c <__mspabi_slli_13>:
    d17c:	0c 5c       	rla	r12		;

0000d17e <__mspabi_slli_12>:
    d17e:	0c 5c       	rla	r12		;

0000d180 <__mspabi_slli_11>:
    d180:	0c 5c       	rla	r12		;

0000d182 <__mspabi_slli_10>:
    d182:	0c 5c       	rla	r12		;

0000d184 <__mspabi_slli_9>:
    d184:	0c 5c       	rla	r12		;

0000d186 <__mspabi_slli_8>:
    d186:	0c 5c       	rla	r12		;

0000d188 <__mspabi_slli_7>:
    d188:	0c 5c       	rla	r12		;

0000d18a <__mspabi_slli_6>:
    d18a:	0c 5c       	rla	r12		;

0000d18c <__mspabi_slli_5>:
    d18c:	0c 5c       	rla	r12		;

0000d18e <__mspabi_slli_4>:
    d18e:	0c 5c       	rla	r12		;

0000d190 <__mspabi_slli_3>:
    d190:	0c 5c       	rla	r12		;

0000d192 <__mspabi_slli_2>:
    d192:	0c 5c       	rla	r12		;

0000d194 <__mspabi_slli_1>:
    d194:	0c 5c       	rla	r12		;
    d196:	30 41       	ret			
    d198:	3d 53       	add	#-1,	r13	;r3 As==11
    d19a:	0c 5c       	rla	r12		;

0000d19c <__mspabi_slli>:
    d19c:	0d 93       	cmp	#0,	r13	;r3 As==00
    d19e:	fc 23       	jnz	$-6      	;abs 0xd198
    d1a0:	30 41       	ret			

0000d1a2 <__mspabi_slll_15>:
    d1a2:	0c 5c       	rla	r12		;
    d1a4:	0d 6d       	rlc	r13		;

0000d1a6 <__mspabi_slll_14>:
    d1a6:	0c 5c       	rla	r12		;
    d1a8:	0d 6d       	rlc	r13		;

0000d1aa <__mspabi_slll_13>:
    d1aa:	0c 5c       	rla	r12		;
    d1ac:	0d 6d       	rlc	r13		;

0000d1ae <__mspabi_slll_12>:
    d1ae:	0c 5c       	rla	r12		;
    d1b0:	0d 6d       	rlc	r13		;

0000d1b2 <__mspabi_slll_11>:
    d1b2:	0c 5c       	rla	r12		;
    d1b4:	0d 6d       	rlc	r13		;

0000d1b6 <__mspabi_slll_10>:
    d1b6:	0c 5c       	rla	r12		;
    d1b8:	0d 6d       	rlc	r13		;

0000d1ba <__mspabi_slll_9>:
    d1ba:	0c 5c       	rla	r12		;
    d1bc:	0d 6d       	rlc	r13		;

0000d1be <__mspabi_slll_8>:
    d1be:	0c 5c       	rla	r12		;
    d1c0:	0d 6d       	rlc	r13		;

0000d1c2 <__mspabi_slll_7>:
    d1c2:	0c 5c       	rla	r12		;
    d1c4:	0d 6d       	rlc	r13		;

0000d1c6 <__mspabi_slll_6>:
    d1c6:	0c 5c       	rla	r12		;
    d1c8:	0d 6d       	rlc	r13		;

0000d1ca <__mspabi_slll_5>:
    d1ca:	0c 5c       	rla	r12		;
    d1cc:	0d 6d       	rlc	r13		;

0000d1ce <__mspabi_slll_4>:
    d1ce:	0c 5c       	rla	r12		;
    d1d0:	0d 6d       	rlc	r13		;

0000d1d2 <__mspabi_slll_3>:
    d1d2:	0c 5c       	rla	r12		;
    d1d4:	0d 6d       	rlc	r13		;

0000d1d6 <__mspabi_slll_2>:
    d1d6:	0c 5c       	rla	r12		;
    d1d8:	0d 6d       	rlc	r13		;

0000d1da <__mspabi_slll_1>:
    d1da:	0c 5c       	rla	r12		;
    d1dc:	0d 6d       	rlc	r13		;
    d1de:	30 41       	ret			
    d1e0:	3e 53       	add	#-1,	r14	;r3 As==11
    d1e2:	0c 5c       	rla	r12		;
    d1e4:	0d 6d       	rlc	r13		;

0000d1e6 <__mspabi_slll>:
    d1e6:	0e 93       	cmp	#0,	r14	;r3 As==00
    d1e8:	fb 23       	jnz	$-8      	;abs 0xd1e0
    d1ea:	30 41       	ret			

0000d1ec <__mspabi_srai_15>:
    d1ec:	0c 11       	rra	r12		;

0000d1ee <__mspabi_srai_14>:
    d1ee:	0c 11       	rra	r12		;

0000d1f0 <__mspabi_srai_13>:
    d1f0:	0c 11       	rra	r12		;

0000d1f2 <__mspabi_srai_12>:
    d1f2:	0c 11       	rra	r12		;

0000d1f4 <__mspabi_srai_11>:
    d1f4:	0c 11       	rra	r12		;

0000d1f6 <__mspabi_srai_10>:
    d1f6:	0c 11       	rra	r12		;

0000d1f8 <__mspabi_srai_9>:
    d1f8:	0c 11       	rra	r12		;

0000d1fa <__mspabi_srai_8>:
    d1fa:	0c 11       	rra	r12		;

0000d1fc <__mspabi_srai_7>:
    d1fc:	0c 11       	rra	r12		;

0000d1fe <__mspabi_srai_6>:
    d1fe:	0c 11       	rra	r12		;

0000d200 <__mspabi_srai_5>:
    d200:	0c 11       	rra	r12		;

0000d202 <__mspabi_srai_4>:
    d202:	0c 11       	rra	r12		;

0000d204 <__mspabi_srai_3>:
    d204:	0c 11       	rra	r12		;

0000d206 <__mspabi_srai_2>:
    d206:	0c 11       	rra	r12		;

0000d208 <__mspabi_srai_1>:
    d208:	0c 11       	rra	r12		;
    d20a:	30 41       	ret			
    d20c:	3d 53       	add	#-1,	r13	;r3 As==11
    d20e:	0c 11       	rra	r12		;

0000d210 <__mspabi_srai>:
    d210:	0d 93       	cmp	#0,	r13	;r3 As==00
    d212:	fc 23       	jnz	$-6      	;abs 0xd20c
    d214:	30 41       	ret			

0000d216 <__mspabi_sral_15>:
    d216:	0d 11       	rra	r13		;
    d218:	0c 10       	rrc	r12		;

0000d21a <__mspabi_sral_14>:
    d21a:	0d 11       	rra	r13		;
    d21c:	0c 10       	rrc	r12		;

0000d21e <__mspabi_sral_13>:
    d21e:	0d 11       	rra	r13		;
    d220:	0c 10       	rrc	r12		;

0000d222 <__mspabi_sral_12>:
    d222:	0d 11       	rra	r13		;
    d224:	0c 10       	rrc	r12		;

0000d226 <__mspabi_sral_11>:
    d226:	0d 11       	rra	r13		;
    d228:	0c 10       	rrc	r12		;

0000d22a <__mspabi_sral_10>:
    d22a:	0d 11       	rra	r13		;
    d22c:	0c 10       	rrc	r12		;

0000d22e <__mspabi_sral_9>:
    d22e:	0d 11       	rra	r13		;
    d230:	0c 10       	rrc	r12		;

0000d232 <__mspabi_sral_8>:
    d232:	0d 11       	rra	r13		;
    d234:	0c 10       	rrc	r12		;

0000d236 <__mspabi_sral_7>:
    d236:	0d 11       	rra	r13		;
    d238:	0c 10       	rrc	r12		;

0000d23a <__mspabi_sral_6>:
    d23a:	0d 11       	rra	r13		;
    d23c:	0c 10       	rrc	r12		;

0000d23e <__mspabi_sral_5>:
    d23e:	0d 11       	rra	r13		;
    d240:	0c 10       	rrc	r12		;

0000d242 <__mspabi_sral_4>:
    d242:	0d 11       	rra	r13		;
    d244:	0c 10       	rrc	r12		;

0000d246 <__mspabi_sral_3>:
    d246:	0d 11       	rra	r13		;
    d248:	0c 10       	rrc	r12		;

0000d24a <__mspabi_sral_2>:
    d24a:	0d 11       	rra	r13		;
    d24c:	0c 10       	rrc	r12		;

0000d24e <__mspabi_sral_1>:
    d24e:	0d 11       	rra	r13		;
    d250:	0c 10       	rrc	r12		;
    d252:	30 41       	ret			
    d254:	3e 53       	add	#-1,	r14	;r3 As==11
    d256:	0d 11       	rra	r13		;
    d258:	0c 10       	rrc	r12		;

0000d25a <__mspabi_sral>:
    d25a:	0e 93       	cmp	#0,	r14	;r3 As==00
    d25c:	fb 23       	jnz	$-8      	;abs 0xd254
    d25e:	30 41       	ret			

0000d260 <__mspabi_srli_15>:
    d260:	12 c3       	clrc			
    d262:	0c 10       	rrc	r12		;

0000d264 <__mspabi_srli_14>:
    d264:	12 c3       	clrc			
    d266:	0c 10       	rrc	r12		;

0000d268 <__mspabi_srli_13>:
    d268:	12 c3       	clrc			
    d26a:	0c 10       	rrc	r12		;

0000d26c <__mspabi_srli_12>:
    d26c:	12 c3       	clrc			
    d26e:	0c 10       	rrc	r12		;

0000d270 <__mspabi_srli_11>:
    d270:	12 c3       	clrc			
    d272:	0c 10       	rrc	r12		;

0000d274 <__mspabi_srli_10>:
    d274:	12 c3       	clrc			
    d276:	0c 10       	rrc	r12		;

0000d278 <__mspabi_srli_9>:
    d278:	12 c3       	clrc			
    d27a:	0c 10       	rrc	r12		;

0000d27c <__mspabi_srli_8>:
    d27c:	12 c3       	clrc			
    d27e:	0c 10       	rrc	r12		;

0000d280 <__mspabi_srli_7>:
    d280:	12 c3       	clrc			
    d282:	0c 10       	rrc	r12		;

0000d284 <__mspabi_srli_6>:
    d284:	12 c3       	clrc			
    d286:	0c 10       	rrc	r12		;

0000d288 <__mspabi_srli_5>:
    d288:	12 c3       	clrc			
    d28a:	0c 10       	rrc	r12		;

0000d28c <__mspabi_srli_4>:
    d28c:	12 c3       	clrc			
    d28e:	0c 10       	rrc	r12		;

0000d290 <__mspabi_srli_3>:
    d290:	12 c3       	clrc			
    d292:	0c 10       	rrc	r12		;

0000d294 <__mspabi_srli_2>:
    d294:	12 c3       	clrc			
    d296:	0c 10       	rrc	r12		;

0000d298 <__mspabi_srli_1>:
    d298:	12 c3       	clrc			
    d29a:	0c 10       	rrc	r12		;
    d29c:	30 41       	ret			
    d29e:	3d 53       	add	#-1,	r13	;r3 As==11
    d2a0:	12 c3       	clrc			
    d2a2:	0c 10       	rrc	r12		;

0000d2a4 <__mspabi_srli>:
    d2a4:	0d 93       	cmp	#0,	r13	;r3 As==00
    d2a6:	fb 23       	jnz	$-8      	;abs 0xd29e
    d2a8:	30 41       	ret			

0000d2aa <__mspabi_srll_15>:
    d2aa:	12 c3       	clrc			
    d2ac:	0d 10       	rrc	r13		;
    d2ae:	0c 10       	rrc	r12		;

0000d2b0 <__mspabi_srll_14>:
    d2b0:	12 c3       	clrc			
    d2b2:	0d 10       	rrc	r13		;
    d2b4:	0c 10       	rrc	r12		;

0000d2b6 <__mspabi_srll_13>:
    d2b6:	12 c3       	clrc			
    d2b8:	0d 10       	rrc	r13		;
    d2ba:	0c 10       	rrc	r12		;

0000d2bc <__mspabi_srll_12>:
    d2bc:	12 c3       	clrc			
    d2be:	0d 10       	rrc	r13		;
    d2c0:	0c 10       	rrc	r12		;

0000d2c2 <__mspabi_srll_11>:
    d2c2:	12 c3       	clrc			
    d2c4:	0d 10       	rrc	r13		;
    d2c6:	0c 10       	rrc	r12		;

0000d2c8 <__mspabi_srll_10>:
    d2c8:	12 c3       	clrc			
    d2ca:	0d 10       	rrc	r13		;
    d2cc:	0c 10       	rrc	r12		;

0000d2ce <__mspabi_srll_9>:
    d2ce:	12 c3       	clrc			
    d2d0:	0d 10       	rrc	r13		;
    d2d2:	0c 10       	rrc	r12		;

0000d2d4 <__mspabi_srll_8>:
    d2d4:	12 c3       	clrc			
    d2d6:	0d 10       	rrc	r13		;
    d2d8:	0c 10       	rrc	r12		;

0000d2da <__mspabi_srll_7>:
    d2da:	12 c3       	clrc			
    d2dc:	0d 10       	rrc	r13		;
    d2de:	0c 10       	rrc	r12		;

0000d2e0 <__mspabi_srll_6>:
    d2e0:	12 c3       	clrc			
    d2e2:	0d 10       	rrc	r13		;
    d2e4:	0c 10       	rrc	r12		;

0000d2e6 <__mspabi_srll_5>:
    d2e6:	12 c3       	clrc			
    d2e8:	0d 10       	rrc	r13		;
    d2ea:	0c 10       	rrc	r12		;

0000d2ec <__mspabi_srll_4>:
    d2ec:	12 c3       	clrc			
    d2ee:	0d 10       	rrc	r13		;
    d2f0:	0c 10       	rrc	r12		;

0000d2f2 <__mspabi_srll_3>:
    d2f2:	12 c3       	clrc			
    d2f4:	0d 10       	rrc	r13		;
    d2f6:	0c 10       	rrc	r12		;

0000d2f8 <__mspabi_srll_2>:
    d2f8:	12 c3       	clrc			
    d2fa:	0d 10       	rrc	r13		;
    d2fc:	0c 10       	rrc	r12		;

0000d2fe <__mspabi_srll_1>:
    d2fe:	12 c3       	clrc			
    d300:	0d 10       	rrc	r13		;
    d302:	0c 10       	rrc	r12		;
    d304:	30 41       	ret			
    d306:	3e 53       	add	#-1,	r14	;r3 As==11
    d308:	12 c3       	clrc			
    d30a:	0d 10       	rrc	r13		;
    d30c:	0c 10       	rrc	r12		;

0000d30e <__mspabi_srll>:
    d30e:	0e 93       	cmp	#0,	r14	;r3 As==00
    d310:	fa 23       	jnz	$-10     	;abs 0xd306
    d312:	30 41       	ret			

0000d314 <__mulhi2>:
    d314:	02 12       	push	r2		;
    d316:	32 c2       	dint			
    d318:	03 43       	nop			
    d31a:	82 4c 30 01 	mov	r12,	&0x0130	;
    d31e:	82 4d 38 01 	mov	r13,	&0x0138	;
    d322:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    d326:	00 13       	reti			

0000d328 <__mulsihi2>:
    d328:	02 12       	push	r2		;
    d32a:	32 c2       	dint			
    d32c:	03 43       	nop			
    d32e:	82 4c 32 01 	mov	r12,	&0x0132	;
    d332:	82 4d 38 01 	mov	r13,	&0x0138	;
    d336:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    d33a:	1d 42 3c 01 	mov	&0x013c,r13	;0x013c
    d33e:	00 13       	reti			

0000d340 <__umulsihi2>:
    d340:	02 12       	push	r2		;
    d342:	32 c2       	dint			
    d344:	03 43       	nop			
    d346:	82 4c 30 01 	mov	r12,	&0x0130	;
    d34a:	82 4d 38 01 	mov	r13,	&0x0138	;
    d34e:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    d352:	1d 42 3c 01 	mov	&0x013c,r13	;0x013c
    d356:	00 13       	reti			

0000d358 <__mulsi2>:
    d358:	02 12       	push	r2		;
    d35a:	32 c2       	dint			
    d35c:	03 43       	nop			
    d35e:	82 4c 30 01 	mov	r12,	&0x0130	;
    d362:	82 4e 38 01 	mov	r14,	&0x0138	;
    d366:	82 4c 34 01 	mov	r12,	&0x0134	;
    d36a:	1c 42 3a 01 	mov	&0x013a,r12	;0x013a
    d36e:	92 42 3c 01 	mov	&0x013c,&0x013a	;0x013c
    d372:	3a 01 
    d374:	82 4f 38 01 	mov	r15,	&0x0138	;
    d378:	82 4d 34 01 	mov	r13,	&0x0134	;
    d37c:	82 4e 38 01 	mov	r14,	&0x0138	;
    d380:	1d 42 3a 01 	mov	&0x013a,r13	;0x013a
    d384:	00 13       	reti			
	...

0000d388 <__mulsi2_hw32>:
    d388:	02 12       	push	r2		;
    d38a:	32 c2       	dint			
    d38c:	03 43       	nop			
    d38e:	82 4c 40 01 	mov	r12,	&0x0140	;
    d392:	82 4d 42 01 	mov	r13,	&0x0142	;
    d396:	82 4e 50 01 	mov	r14,	&0x0150	;
    d39a:	82 4f 52 01 	mov	r15,	&0x0152	;
    d39e:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    d3a2:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    d3a6:	00 13       	reti			

0000d3a8 <__muldisi2_hw32>:
    d3a8:	02 12       	push	r2		;
    d3aa:	32 c2       	dint			
    d3ac:	03 43       	nop			
    d3ae:	82 4c 44 01 	mov	r12,	&0x0144	;
    d3b2:	82 4d 46 01 	mov	r13,	&0x0146	;
    d3b6:	82 4e 50 01 	mov	r14,	&0x0150	;
    d3ba:	82 4f 52 01 	mov	r15,	&0x0152	;
    d3be:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    d3c2:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    d3c6:	1e 42 58 01 	mov	&0x0158,r14	;0x0158
    d3ca:	1f 42 5a 01 	mov	&0x015a,r15	;0x015a
    d3ce:	00 13       	reti			

0000d3d0 <__umuldisi2_hw32>:
    d3d0:	02 12       	push	r2		;
    d3d2:	32 c2       	dint			
    d3d4:	03 43       	nop			
    d3d6:	82 4c 40 01 	mov	r12,	&0x0140	;
    d3da:	82 4d 42 01 	mov	r13,	&0x0142	;
    d3de:	82 4e 50 01 	mov	r14,	&0x0150	;
    d3e2:	82 4f 52 01 	mov	r15,	&0x0152	;
    d3e6:	1c 42 54 01 	mov	&0x0154,r12	;0x0154
    d3ea:	1d 42 56 01 	mov	&0x0156,r13	;0x0156
    d3ee:	1e 42 58 01 	mov	&0x0158,r14	;0x0158
    d3f2:	1f 42 5a 01 	mov	&0x015a,r15	;0x015a
    d3f6:	00 13       	reti			

0000d3f8 <__mulhi2_f5>:
    d3f8:	02 12       	push	r2		;
    d3fa:	32 c2       	dint			
    d3fc:	03 43       	nop			
    d3fe:	82 4c c0 04 	mov	r12,	&0x04c0	;
    d402:	82 4d c8 04 	mov	r13,	&0x04c8	;
    d406:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    d40a:	00 13       	reti			

0000d40c <__mulsihi2_f5>:
    d40c:	02 12       	push	r2		;
    d40e:	32 c2       	dint			
    d410:	03 43       	nop			
    d412:	82 4c c2 04 	mov	r12,	&0x04c2	;
    d416:	82 4d c8 04 	mov	r13,	&0x04c8	;
    d41a:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    d41e:	1d 42 cc 04 	mov	&0x04cc,r13	;0x04cc
    d422:	00 13       	reti			

0000d424 <__umulsihi2_f5>:
    d424:	02 12       	push	r2		;
    d426:	32 c2       	dint			
    d428:	03 43       	nop			
    d42a:	82 4c c0 04 	mov	r12,	&0x04c0	;
    d42e:	82 4d c8 04 	mov	r13,	&0x04c8	;
    d432:	1c 42 ca 04 	mov	&0x04ca,r12	;0x04ca
    d436:	1d 42 cc 04 	mov	&0x04cc,r13	;0x04cc
    d43a:	00 13       	reti			

0000d43c <__mulsi2_f5>:
    d43c:	02 12       	push	r2		;
    d43e:	32 c2       	dint			
    d440:	03 43       	nop			
    d442:	82 4c d0 04 	mov	r12,	&0x04d0	;
    d446:	82 4d d2 04 	mov	r13,	&0x04d2	;
    d44a:	82 4e e0 04 	mov	r14,	&0x04e0	;
    d44e:	82 4f e2 04 	mov	r15,	&0x04e2	;
    d452:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    d456:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    d45a:	00 13       	reti			

0000d45c <__muldisi2_f5>:
    d45c:	02 12       	push	r2		;
    d45e:	32 c2       	dint			
    d460:	03 43       	nop			
    d462:	82 4c d4 04 	mov	r12,	&0x04d4	;
    d466:	82 4d d6 04 	mov	r13,	&0x04d6	;
    d46a:	82 4e e0 04 	mov	r14,	&0x04e0	;
    d46e:	82 4f e2 04 	mov	r15,	&0x04e2	;
    d472:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    d476:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    d47a:	1e 42 e8 04 	mov	&0x04e8,r14	;0x04e8
    d47e:	1f 42 ea 04 	mov	&0x04ea,r15	;0x04ea
    d482:	00 13       	reti			

0000d484 <__umuldisi2_f5>:
    d484:	02 12       	push	r2		;
    d486:	32 c2       	dint			
    d488:	03 43       	nop			
    d48a:	82 4c d0 04 	mov	r12,	&0x04d0	;
    d48e:	82 4d d2 04 	mov	r13,	&0x04d2	;
    d492:	82 4e e0 04 	mov	r14,	&0x04e0	;
    d496:	82 4f e2 04 	mov	r15,	&0x04e2	;
    d49a:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    d49e:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    d4a2:	1e 42 e8 04 	mov	&0x04e8,r14	;0x04e8
    d4a6:	1f 42 ea 04 	mov	&0x04ea,r15	;0x04ea
    d4aa:	00 13       	reti			

0000d4ac <memmove>:
    d4ac:	0a 12       	push	r10		;
    d4ae:	0d 9c       	cmp	r12,	r13	;
    d4b0:	11 2c       	jc	$+36     	;abs 0xd4d4
    d4b2:	0b 4d       	mov	r13,	r11	;
    d4b4:	0b 5e       	add	r14,	r11	;
    d4b6:	0c 9b       	cmp	r11,	r12	;
    d4b8:	0d 2c       	jc	$+28     	;abs 0xd4d4
    d4ba:	0d 4e       	mov	r14,	r13	;
    d4bc:	3d 53       	add	#-1,	r13	;r3 As==11
    d4be:	3d 93       	cmp	#-1,	r13	;r3 As==11
    d4c0:	15 24       	jz	$+44     	;abs 0xd4ec
    d4c2:	0f 4d       	mov	r13,	r15	;
    d4c4:	0f 8e       	sub	r14,	r15	;
    d4c6:	0f 5b       	add	r11,	r15	;
    d4c8:	0a 4c       	mov	r12,	r10	;
    d4ca:	0a 5d       	add	r13,	r10	;
    d4cc:	ea 4f 00 00 	mov.b	@r15,	0(r10)	;
    d4d0:	30 40 bc d4 	br	#0xd4bc		;
    d4d4:	0f 43       	clr	r15		;
    d4d6:	0f 9e       	cmp	r14,	r15	;
    d4d8:	09 24       	jz	$+20     	;abs 0xd4ec
    d4da:	0a 4d       	mov	r13,	r10	;
    d4dc:	0a 5f       	add	r15,	r10	;
    d4de:	0b 4c       	mov	r12,	r11	;
    d4e0:	0b 5f       	add	r15,	r11	;
    d4e2:	eb 4a 00 00 	mov.b	@r10,	0(r11)	;
    d4e6:	1f 53       	inc	r15		;
    d4e8:	30 40 d6 d4 	br	#0xd4d6		;
    d4ec:	3a 41       	pop	r10		;
    d4ee:	30 41       	ret			

0000d4f0 <memset>:
    d4f0:	0f 4c       	mov	r12,	r15	;
    d4f2:	0e 5c       	add	r12,	r14	;
    d4f4:	0f 9e       	cmp	r14,	r15	;
    d4f6:	05 24       	jz	$+12     	;abs 0xd502
    d4f8:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    d4fc:	1f 53       	inc	r15		;
    d4fe:	30 40 f4 d4 	br	#0xd4f4		;
    d502:	30 41       	ret			

0000d504 <__do_global_ctors_aux>:
    d504:	0a 12       	push	r10		;
    d506:	1c 42 60 82 	mov	&0x8260,r12	;0x8260
    d50a:	3c 93       	cmp	#-1,	r12	;r3 As==11
    d50c:	08 24       	jz	$+18     	;abs 0xd51e
    d50e:	3a 40 60 82 	mov	#33376,	r10	;#0x8260
    d512:	8c 12       	call	r12		;
    d514:	3a 50 fe ff 	add	#65534,	r10	;#0xfffe
    d518:	2c 4a       	mov	@r10,	r12	;
    d51a:	3c 93       	cmp	#-1,	r12	;r3 As==11
    d51c:	fa 23       	jnz	$-10     	;abs 0xd512
    d51e:	3a 41       	pop	r10		;
    d520:	30 41       	ret			

0000d522 <call___do_global_ctors_aux>:
    d522:	30 41       	ret			

0000d524 <__msp430_init>:
    d524:	b0 12 6e 83 	call	#33646		;#0x836e
    d528:	b0 12 04 d5 	call	#54532		;#0xd504
    d52c:	b0 12 a6 82 	call	#33446		;#0x82a6
    d530:	b0 12 98 82 	call	#33432		;#0x8298
    d534:	30 41       	ret			

0000d536 <__msp430_fini>:
    d536:	b0 12 b4 82 	call	#33460		;#0x82b4
    d53a:	b0 12 20 83 	call	#33568		;#0x8320
    d53e:	30 41       	ret			
